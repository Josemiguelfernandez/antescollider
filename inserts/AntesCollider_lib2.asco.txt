////////SUPERCOLLIDER

// command line boot
// ./scsynth -u 57110 -i 43 -o 43 -b 1026 -d 2048 -n 16384 -m 1048576 -w 256  -S 48000 &

// indique qu'il faut gerer les arrays OSC pour piloter SuperCollider
 @set_osc_handling_tab(1) ///SuperCollider a diferencia de antescofo/sclang

antescofo::bypass_temporeset on


// oscsend ambiX "localhost" : 6668 "/ambi_test/ambiX" @persistent
// oscsend ambiY "localhost" : 6668 "/ambi_test/ambiY" @persistent
// oscsend ambiZ "localhost" : 6668 "/ambi_test/ambiZ" @persistent

// gui SCLang for GUI

oscsend gui_antes "localhost" :7002 "/gui_antes" //@persistent
oscsend gui_data "localhost" :7002 "/gui_data" //@persistent
oscsend plot "localhost" :7002 "/plot" //@persistent // plot NIMS in SC
oscsend plotnim "localhost" :7002 "/plotnim" //@persistent // plot NIMS in SC

oscsend hoa_circ3 "localhost" :7002 "/hoa_circ3" //@persistent

// SMIR Analyzes from SC-lang
oscsend smir_analyze "localhost" :7002 "/smir_analyze" //@persistent
oscsend concat_smir_analyze "localhost" :7002 "/concat_smir_analyze" //@persistent
oscrecv from_smir 1111 * $from_smir //@persistent

// openframeworks visualization

oscsend master_meter_out "localhost" : 12345 "/master_meter_out" //@persistent // vers oFx master audio visual

oscsend of_list3D "localhost" :12345 "/of_list3D" //@persistent
oscsend of_list "localhost" :12345 "/of_list" //@persistent
oscsend of_traj "localhost" :12345 "/of_traj" //@persistent
oscsend of_molecules "localhost" :12345 "/of_molecules" //@persistent
oscsend of_concat_list_num "localhost" :12345 "/of_concat_list_num" //@persistent
oscsend of_concat3D "localhost" :12345 "/of_concat3D" //@persistent

oscsend of_grains "localhost" :12345 "/of_grains"

oscsend of_grains1 "localhost" :12345 "/of_grains1" //@persistent
oscsend of_grains2 "localhost" :12345 "/of_grains2" //@persistent
oscsend of_grains3 "localhost" :12345 "/of_grains3" //@persistent
oscsend of_grains4 "localhost" :12345 "/of_grains4" //@persistent
oscsend of_grains5 "localhost" :12345 "/of_grains5" //@persistent
oscsend of_grains6 "localhost" :12345 "/of_grains6" //@persistent

oscsend knn_search_list "localhost" :12345 "/knn_search_list" //@persistent

// send to oF GUI

/*oscsend concat_x "localhost" : 6665 "/parameters/concat_xyz/c_x" //@persistent
oscsend concat_y "localhost" : 6665 "/parameters/concat_xyz/c_y" //@persistent
oscsend concat_z "localhost" : 6665 "/parameters/concat_xyz/c_z" //@persistent*/



// recever OSC from openFrameworks

oscrecv 3D_knn_index 23456 * $knn_index //@persistent


	// recever OSC from openFrameworks GUI
oscrecv 3D_plane_oFx 6666 * $from_of_gui //@persistent



/*oscsend osc_send_descriptors "192.168.1.12" : 9999 //@persistent // $host : $port //("/"+$name)

oscsend send_osc @global "192.168.1.12" : 9999


	// recever OSC from openFrameworks GUI
oscrecv from_video 6667 * $from_video //@persistent // from Raph*/


// oscsend sample "169.254.157.190" : 5555 "/sample" @persistent



/// maps
// $servers := map{}

// @global $groups @persistent
// @global $tracks @persistent
// @global $aux @persistent
// if (@is_undef($groups)) { $groups := map{} }
// if (@is_undef($tracks)) { $tracks := map{} }
// if (@is_undef($aux)) { $aux := map{} }

/// bach 

oscsend to_bach "localhost" :9543 "/rand_note" //@persistent

oscrecv from_bach 65534 * $from_bach_notes // @persistent
oscrecv from_bach2 6555 * $from_bach2 // @persistent
oscrecv from_bach2 6556 * $from_bach3 // @persistent

///////

/// Vezer

oscrecv from_vezer 8000 * $electro // @persistent

@global $home @persistent
@global $path @persistent
@global $SF_dir @persistent
@global $path_rec @persistent
@global $path_hrir @persistent
@global $hrir_dir @persistent
@global $vst_file @persistent
@global $path_automation @persistent
@global $vezer_path @persistent
@global $vezer_nims @persistent
@global $path_arrays @persistent

/// home directory
$home := @user_directory() // this is the user dirctory $home + ""



$current_dir := @current_load_directory()
/// patch soundFiles
// $path := $home + "/Library/Application\ Support/SuperCollider/sounds/"

$path := $home + "/sounds/"
// $path := $home + "/sound_test/"

// $path := $home + "/Users/josephfernandez/Documents/Lara-ali/bandes-d-ali"

$SF_dir := @directory_read($path, 2, ["aif", "aiff", "WAVE"])
// print (""+$SF_dir)

// recording

$path_rec := $home + "/Library/Application\ Support/SuperCollider/recordings/"

// temp

$path_tmp := $home + "/Library/Application\ Support/SuperCollider/tmp/"

// fluid-data

$path_fluid := $home + "/Library/Application\ Support/SuperCollider/fluid-data/"

/// patch hrir

$path_hrir := $home + "/Library/Application Support/SuperCollider/downloaded-quarks/SC-HOA/FIR/hrir/"
$hrir_dir := @directory_read($path_hrir, 2)

// vst
$vst_file := $home + "/Library/Application\ Support/SuperCollider/tmp/vst_all"

// (""+$vst_all_map.domain())

// vst presets

$vst_presets := $home + "/Library/Audio/Presets/"

// Spat automation

$path_automation := $home + "/Library/Application\ Support/SuperCollider/automation/"

// Vezer curves

$vezer_path := $current_dir + "vezer_xml/"
$vezer_nims := @directory_read($vezer_path, 2, ["xml"])
// print (""+$vezer_nims)

// tablaux (delays, buffers, positions)

$path_arrays := $home + "/Library/Application\ Support/SuperCollider/arrays/"

$store_tab := []

whenever ($store_tab==$store_tab)
{
	@local $tab_file_name, $tab_data
	$tab_file_name := $store_tab.car()
	$tab_data := $store_tab.cdr()
	@savevalue($path_arrays + $tab_file_name, $tab_data)
}

// print (""+$vst_param_map)
@global $vst_param_map @persistent
if (@is_undef($vst_param_map)) { $vst_param_map := map{} }

  @r_compile(0, "\\[plugin\\]((.*\n)*?)\\[keys\\]")
  @r_compile(1, "([[:alnum:]]+=.+\n)")
  @r_compile(2, "([[:alnum:]]+)=(.+)\n")
  @r_compile(3, "\\[parameters\\]\nn=[[:digit:]]+\n") //n=[[:digit:]]+\nzzzzzzz
  @r_compile(4, "([[:alnum:][:space:]]+),[^,]*,([[:digit:]abcdef]+)\n")
  
@fun_def make_vst_map($s)
{
    @local $ident := [$e | $e in @r_findall(1, $s), $e.is_tab()]
    @local $param_section := @r_search(3, $s)

    if ($ident.is_tab() && $param_section.is_tab())
    {
	    @local $ps := @r_findall(4, $param_section[2])
	    @local $map := MAP{}
	    @local $map_p := MAP{}

	    forall $x in $ident
	    {
		    $e := @r_search(2, $x[0])
		    if ($e.is_tab()) { $map.add_pair($e[1], $e[2]) }
	    }

	    if ($ps.is_tab())
	    {
		    @local $params := [$e | $e in $ps, $e.is_tab()]
		    forall $e in $params
		    {
			if ($e.is_tab()) { $map_p.add_pair($e[0], @base2i(16, $e[1])) }
		    }
	    }

	    $map.add_pair("parameters", $map_p)
	    return $map
    }
    else { return MAP{} }
}


@fun_def make_all_vst($s)
{
    @local $content := @read_file($vst_file)
    @local $tab := [$e | $e in @r_findall(0, $content), $e.is_tab() ]

    $gmap := MAP{}
    forall $e in $tab
    {
	   $map := @make_vst_map($e[0])
	   if ($map.is_defined("name"))
	   {
		   $gmap.add_pair($map("name"), $map)
	   }         
    }
    return $gmap
}


@proc_def list_vst()
{
	@local $find_server
	$find_server := $Servers.range()[0] // cherche un objet serveur instancié
	$find_server.cmd(["/vst_search", 15, $vst_file]) // create the vst_all file
	0.1 $vst_all_map := @make_all_vst(@read_file($vst_file))
	print "//// ALL VST ////"
	print "//////////"
	forall $k, $v in $vst_all_map
	{
		print $k
	}
}


// $vst_file := "/Users/fernandez/Library/Application\ Support/SuperCollider/tmp/vst_all"
//  
// $file := "/Users/fernandez/Library/Application\ Support/SuperCollider/tmp/vst_all"

$vst_all_map := @make_all_vst(@read_file($vst_file))

// forall $k, $v in $map
// {
//      print $k "==>" (""+$v)
// }

// print (""+$vst_all_map("DualDelay")("parameters")("Ambisonics Order"))


// objets : ne peuvent pas être gardé après un stop marche pas @persistent
$groups := map{}
$tracks := map{}
$aux := map{}


@global $sc_group_struct @persistent
if (@is_undef($sc_group_struct)) { $sc_group_struct := map{} }


@global $SC_Servers @persistent
// @global $Servers @persistent
// @global $SC_Groups @persistent
if (@is_undef($SC_Servers)) { $SC_Servers := map{} }
// if (@is_undef($Servers)) { $Servers := map{} }
// if (@is_undef($SC_Groups)) { $SC_Groups := map{} }

// $SC_Servers := map{}
$Servers := map{}
$SC_Groups := map{}


@global $synths_map @persistent
@global $track_proc @persistent
@global $space_group @persistent
@global $group_proc @persistent
@global $vst_plugins @persistent
if (@is_undef($synths_map)) { $synths_map := map{} }
if (@is_undef($track_proc)) { $track_proc := map{} }
if (@is_undef($space_group)) { $space_group := map{} }
if (@is_undef($group_proc)) { $group_proc := map{} }
if (@is_undef($vst_plugins)) { $vst_plugins := map{} }

@global $sc_group_id @persistent
$sc_group_id := 300
// $sc_id := 0

@global $node_id @persistent
@global $bus_index @persistent
$node_id := 100 
$bus_index := 86  // depende de los IN/out de la carte son



$from_sc_server := 0

// enveloppes
@global $envs @persistent
@global $buff_alloc_from_server @persistent
if (@is_undef($envs)) { $envs := map{} }
if (@is_undef($buff_alloc_from_server)) { $buff_alloc_from_server := 0 }

print envs_init (""+$envs)
/////SC tree basic MAP

// $sc_struct := map{("localhost", map{(0, [1]), // root tree 0 -> default group 1
// 				  (1, [])} 
// 				  )}

@global $sc_struct @persistent
if (@is_undef($sc_struct)) { $sc_struct := map{} }

$sc_server_notifications := 0

/// Max interaction
/// envoie liste serveurs actives vers Max "servers_max"

$cu_servers := 0
$cu_tracks := 0

@global $HOA_global_x @persistent
@global $HOA_global_y @persistent
@global $HOA_global_z @persistent
@global $HOA_global_xyz @persistent
if (@is_undef($HOA_global_x)) { $HOA_global_x := 0 }
if (@is_undef($HOA_global_y)) { $HOA_global_y := 0 }
if (@is_undef($HOA_global_z)) { $HOA_global_z := 0 }
if (@is_undef($HOA_global_xyz)) { $HOA_global_xyz := [0, 0, 0] }


$firefly_coord := [0, 0, 0]
$firefly_radius := 50

$firefly_coord2 := [0, 0, 0]
$firefly_radius2 := 50

// /parameters/concat_xyz/c_x -0.079401


whenever ($from_of_gui == $from_of_gui)
{
	// print from_of_gui $from_of_gui 
	switch ($from_of_gui[0])
	{
		case "/parameters/concat_xyz/c_x":
		$firefly_coord[0] := $from_of_gui[1]
		// print $from_of_gui
		case "/parameters/concat_xyz/c_y":
		$firefly_coord[1] := $from_of_gui[1]
		case "/parameters/concat_xyz/c_z":
		$firefly_coord[2] := $from_of_gui[1]
		case "/parameters/concat_xyz/radius":
		$firefly_radius := $from_of_gui[1]

		case "/parameters/concat_xyz2/c_x":
		$firefly_coord2[0] := $from_of_gui[1]
		// print $from_of_gui
		case "/parameters/concat_xyz2/c_y":
		$firefly_coord2[1] := $from_of_gui[1]
		case "/parameters/concat_xyz2/c_z":
		$firefly_coord2[2] := $from_of_gui[1]
		case "/parameters/concat_xyz2/radius":
		$firefly_radius2 := $from_of_gui[1]

	}
	$update := 1
}

// oscsend head_pos "localhost" :12345 "/head_pos"


// oscsend of_grains_label "localhost" :12345 "/of_grains_label"

//// RiOT

//oscrecv riot 8888 * $raw

whenever ($raw)
{
	// print (@slice($raw, 19, 22))
	head_pos (@slice($raw, 19, 22))
	quater (@slice($raw, 15, 19))
	raw $raw
}

// of_grains1 1000 0.2 0.2 0.2

// abort toto
// print startTIme

// of_list 1.5 0.5 0
// of_grains 1.5 2.0 0.0
// of_grains 0.5 0.5 0

// openframeworks GUI

@global $gui_enabled @persistent
@global $gui @persistent
$gui_enabled := false
$gui := false

// Global variables

@global $sampling_rate @persistent
if(@is_undef($sampling_rate)) { $sampling_rate := 48000 } //48000


$bus_index := 86-8
$group := 0
$out_synth := 0
$SC_Buffers_index := 0 // index for buffers
$server_sync := 0





// // server commands falta "Synth Definition Commands"
// $osc_server_commands := ["quit", "notify", "status", "cmd", "dumpOSC", "sync", "clearSched", "error", "version", "n_free", "n_run", "n_set", "n_setn", "n_fill", "n_map", "n_mapn", "n_mapa", "n_mapan", "n_before", "n_after", "n_query", "n_trace", "n_order", "s_new", "s_get", "s_getn", "s_noid", "g_new", "p_new", "g_head", "g_tail", "g_freeAll", "g_freeAll", "g_dumpTree", "g_queryTree", "b_alloc", "b_allocRead", "b_allocReadChannel", "b_read", "b_readChannel", "b_write", "b_free", "b_zero", "b_set", "b_setn", "b_fill", "b_gen", "b_close", "b_query", "b_get", "b_get"]

$knn_matches := map{}
$knn_matches2 := map{}
$i2m := MAP{}

// concat_smir_analyse onset $home + "/Library/Application\ Support/SuperCollider/sounds/concat/comedien-expresif-SVP1.aif" ([["Tartini"], ["Loudness"], ["SpecCentroid"], ["SpecFlatness"], ["SensoryDissonance"],["MFCC",4]])

@obj_def scmir_analyse($buf, $features, $segmentation) // analyse and extract features from audio file
{
	@local $smir_analyse_tab := [], $ana_count := 0, $analyse_active := 0, $out_pos_final, $index := 0 , $width := 2 , $height := 2 , $radius := [], $tab_of_size := 5 //8
	@init
	{
		$THISOBJ.analyse($buf, $features, $segmentation) 
	}

	@proc_def analyse($buf, $features, $segmentation)
	{
		@set_osc_handling_tab(true)
		print $path
		print segmentation $segmentation
		print features (""+$features)
		concat_smir_analyse $segmentation ($path+$buf) $features
		$analyse_active := 1
		@set_osc_handling_tab(1)
	}
	@whenever ($from_smir == $from_smir && $analyse_active) 
	{
		// print $from_smir
		if($from_smir[1] != "end")
		{
			$from_smir.push_back($ana_count)
			$smir_analyse_tab.push_back($from_smir.cdr())
			$ana_count += 1
		}
		else
		{
			print "Processing Finished...analysis ready for use."
			$analyse_active := 0
		}
		// print (""+$smir_analyse_tab)
	}
	@proc_def print_analyse()
	{
		print analyse_tab (""+$smir_analyse_tab)
	}
	@proc_def map2oF($x, $y, $z, $radius, $col)
	{
		@local $pos_x, $pos_y, $pos_z, $pos_radius, $color, $features_flat := []

		forall $feat in $features
		{
			$features_flat.push_back($feat[0])
		}

		$out_pos_final := [  0 | ($smir_analyse_tab.size()*$tab_of_size) ]
		
		$pos_x :=  @occurs($features_flat, $x)
		$pos_y :=  @occurs($features_flat, $y)
		$pos_z :=  @occurs($features_flat, $z)
		$pos_radius :=  @occurs($features_flat, $radius)
		$color := @occurs($features_flat, $col)
		// print pos_x $pos_x
		// print pos_y $pos_y
		// print pos_z $pos_z
		// print pos_radius $pos_radius

		forall $anatab in $smir_analyse_tab
		{
			// $radius.push_back((15*$anatab[4].linexp(0,1,0.8,2)) * @linexp($anatab.last(),0,1,0.285,1.0))

			// print toto (""+(15*$anatab[4].linexp(0,1,0.8,2)) * @linexp($vector.last(),0,1,0.285,1.0))
			// $center := [($anatab[0]+$anatab[4]*1.25)*($width*$anatab[0]),(($anatab[1]).linlin(0,1,0.001,1.0)*$height)+50,$radius[$index],$radius[$index], $index]
			// $center := [($anatab[0]+$anatab[4]*1.25)*($width*$anatab[0]),(($anatab[1]).linlin(0,1,-1,1.0)*$height)+0,$radius[$index],$radius[$index], $index]

			// $center := [($anatab[0]*$width),(($anatab[1]).linlin(0,1,-1,1.0)*$height)+0,$radius[$index],$radius[$index], $index]


			$out_pos_final[$index*$tab_of_size] := $anatab[$pos_x].linlin(0,1,-1,1)
			$out_pos_final[$index*$tab_of_size+1] := $anatab[$pos_y].linlin(0,1,-1,1)
			$out_pos_final[$index*$tab_of_size+2] := $anatab[$pos_z].linlin(0,1,0,1)
			$out_pos_final[$index*$tab_of_size+3] := $anatab[$pos_radius].linlin(0,1,1,5)
			$out_pos_final[$index*$tab_of_size+4] := $anatab[$color].linlin(0,1,42,255)

			// $out_pos_final[$index*$tab_of_size+4] := $anatab[5].linlin(0,1,0,255)
			// $out_pos_final[$index*$tab_of_size+5] := $anatab[6].linlin(0,1,1,255)
			// $out_pos_final[$index*$tab_of_size+6] := $anatab[7].linlin(0,1,1,255)
			// $out_pos_final[$index*$tab_of_size+7] := $anatab[8].linlin(0,1,1,255)

			// print ($anatab[3].linlin(0,1,5,10))
			// print ($out_pos_final[$index*3+3])

			$index += 1

			// print (""+$toto)
			// print (""+$out_pos_final)
			// of_molecules $out_pos_final

		}	
	

		// print index3 ($out_pos_final[0*3+3])

		print (""+$out_pos_final)
		of_concat3D $out_pos_final

	}	
	@proc_def play_concat($buff, $env, $group)
	{

		whenever ($knn_index == $knn_index)
		{
			@local $tab_ind_val := $knn_index.cdr(), $i1 := 0, $i2 := 0, $idx, $val


			Loop 0
			{
				// $tab_result.push_back($tab_ind_val[$i1])
				// $tab_result.push_back($tab_ind_val[$i1+1])
				$idx := $tab_ind_val[$i1]
				$val := $tab_ind_val[$i1+1]
				// print index_val ([$idx, $val])
				// print def ($knn_matches($idx))
				if($knn_matches($idx).is_undef() && $val > 0.4)
				{
					$knn_matches.add_pair($idx, $val)
					// print index $idx $val
					// print ($smir_analyse_tab[$idx])
					// print ($smir_analyse_tab[$idx][10])
					// print ($smir_analyse_tab[$idx][9])
										// HOA_grain_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07) 
					// print ($SF_map("localhost")($buff)) ($envs("localhost")("rond")) 1 ($smir_analyse_tab[$idx][10]) ($smir_analyse_tab[$idx][9]) @rand_range(-1, 1) @rand_range(-1, 1) @rand_range(0, 1) 0 $group
					
					sample ($out_pos_final[$idx*$tab_of_size]) ($out_pos_final[$idx*$tab_of_size+1]) ($out_pos_final[$idx*$tab_of_size+2]) ($smir_analyse_tab[$idx][0].linlin(-1, 1, 0, 1))

					::HOA_grain2_xyz($buff, $env, 1, $smir_analyse_tab[$idx][10], $smir_analyse_tab[$idx][9], $out_pos_final[$idx*$tab_of_size], $out_pos_final[$idx*$tab_of_size+1], $out_pos_final[$idx*$tab_of_size+2], 0, $group)

				}
				else
				{
					if($knn_matches.is_defined($idx) && $val <= 0.4)
					{
						$knn_matches.remove($idx)
						// print remove $idx $val
					}
				}
				$i1 += 2
			   
			} during [$tab_ind_val.size() / 2 #]
		}
	}
}


$coords := [0, 0, 0]


$fact := 300;

@obj_def scmir_analyze_knn($buf, $features, $segmentation, $chop_size = 0.125, $onset_thresh = 0.5) // analyze and extract features from audio file
{
	@local $smir_analyze_tab := [], $ana_count := 0, $analyze_active := 0, $out_pos_final := [], $out_pos_to_knn := [], $index := 0 , $width := 2 , $height := 2 , $radius := [], $tab_of_size := 5, $knn_matches := MAP{}, $sound_id := 0, $bufmun_map := MAP{},  $max_tab_size := 1000, $of_tab_size, $slice_size//8
	@init
	{
		$THISOBJ.analyze() 
		// $bufmun := $SF_map($server_name)($buf)
		$bufmun_map.add_pair($sound_id, $buf)
	}

	@proc_def analyze()
	{
		@set_osc_handling_tab(true)
		print $path
		if($SF_path($buf).is_undef())
		{
			print "load soundfiles !!"
		}
		else
		{
			print params (""+([$segmentation, $chop_size, $onset_thresh, ($SF_path($buf)), $features]))
			concat_smir_analyze $segmentation $chop_size $onset_thresh ($SF_path($buf)) $features 
			$analyze_active := 1
			// $sound_id += 1
			@set_osc_handling_tab(1)
		}

	}



	@proc_def add_analyze($buf_add, $segment_add, $chop_size = 0.125, $onset_thresh = 0.5)
	{
		print add_analyze
		$bufmun_map.add_pair($sound_id, $buf_add)
		// $bufmun := $SF_map($server_name)($buf_add)
		$from_smir := "init"
		@set_osc_handling_tab(true)
		print $path
		concat_smir_analyze $segment_add  $chop_size $onset_thresh ($SF_path($buf_add)) $features
		$analyze_active := 1
		// $sound_id += 1
		@set_osc_handling_tab(1)
		// 0.1 $analyze_active := 1
	}
	
	@whenever ($from_smir == $from_smir && $analyze_active) 
	{
		print tototot $from_smir
		if($from_smir[1] != "end")
		{
			if($from_smir != "init")
			{
				$from_smir.push_back($ana_count) // add index
				$from_smir.push_back($sound_id) // add buffer number
				$smir_analyze_tab.push_back($from_smir.cdr())
				$ana_count += 1
				print features_frames $ana_count
			}
		}
		else
		{
				print "Processing Finished...analysis ready for use."
				$analyze_active := 0
				$sound_id += 1
		}
		// print smir_analyze_tab (""+$smir_analyze_tab)
	}
	@proc_def print_analyze()
	{
		print analyze_tab (""+$smir_analyze_tab)
	}
	@proc_def map2knn($x, $y, $z, $radius, $col, $map_pos_x = [0, 1, -1, 1], $map_pos_y = [0, 1, -1, 1], $map_pos_z = [0, 1, 0, 1])
	{
		@local $pos_x, $pos_y, $pos_z, $pos_final_x, $pos_final_y, $pos_final_z, $pos_radius, $color, $features_flat := [], $map_list_buff, $counter_map := 0

		// reset //
		$out_pos_final := []
		$out_pos_to_knn := []
		$index := 0

		forall $feat in $features
		{
			$features_flat.push_back($feat[0])
		}

		$out_pos_final := [  0 | ($smir_analyze_tab.size()*$tab_of_size) ]

		
		$pos_x :=  @occurs($features_flat, $x)
		$pos_y :=  @occurs($features_flat, $y)
		$pos_z :=  @occurs($features_flat, $z)
		$pos_radius :=  @occurs($features_flat, $radius)
		$color := @occurs($features_flat, $col)
		// print pos_x $pos_x
		// print pos_y $pos_y
		// print pos_z $pos_z
		// print pos_radius $pos_radius

		forall $anatab in $smir_analyze_tab
		{
			// print anatab $anatab
			$pos_final_x := $anatab[$pos_x].linlin($map_pos_x[0],$map_pos_x[1],$map_pos_x[2],$map_pos_x[3]) * $fact
			$pos_final_y := $anatab[$pos_y].linlin($map_pos_y[0],$map_pos_y[1],$map_pos_y[2],$map_pos_y[3]) * $fact
			$pos_final_z := $anatab[$pos_z].linlin($map_pos_z[0],$map_pos_z[1],$map_pos_z[2],$map_pos_z[3]) * $fact
			print xx $pos_final_x
			print yy $pos_final_y
			print zz $pos_final_z
			$out_pos_to_knn.push_back([$pos_final_x, $pos_final_y, $pos_final_z])
			// to oFx
			$out_pos_final[$index*$tab_of_size] := $pos_final_x
			$out_pos_final[$index*$tab_of_size+1] := $pos_final_y
			$out_pos_final[$index*$tab_of_size+2] := $pos_final_z
			$out_pos_final[$index*$tab_of_size+3] := $anatab[$pos_radius].linlin(0,1,1,5)
			$out_pos_final[$index*$tab_of_size+4] := $anatab[$color].linlin(0,1,42,255)

			$index += 1
		}	
		// print index3 ($out_pos_final[0*3+3])
		$of_tab_size := $out_pos_final.size()
		$slice_size := $of_tab_size/$max_tab_size // $max_tab_size == 1000 max elements  
		$slice_size := @floor($slice_size) // convert to int segments

		$map_list_buff := [$x*$max_tab_size | $x in $slice_size+1]
		$map_list_buff.push_back($of_tab_size-($slice_size*$max_tab_size)+$map_list_buff.last())

		print map_list_buff $map_list_buff

		// of_concat_list_num $slice_size // send to of num segments
		of_concat_list_num $of_tab_size $max_tab_size // send to of tab_size + num segments

		// print (3435 - (@floor(3435/1000)*1000))
		// print ((3435/1000)-3)
		// print (@ceil(3.234))

		// [0, 1000, 2000, 3000, 435]

		loop 0
		{
			// print send_of ($map_list_buff[$counter_map]) ($map_list_buff[$counter_map+1])
			// print toto @slice($test_tab, $x*1024, $x*1024+1024)
			// $test_tab_map.push_back(@slice($test_tab, $x*20, $x*20+20))
			of_concat3D (@slice($out_pos_final, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1]))
			print of_concat3D (@slice($out_pos_final, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1]))
			$counter_map += 1
		}until ($counter_map == $map_list_buff.size()-1)

		// print knn_create (""+$out_pos_final)
		// of_concat3D $out_pos_final
		print knn_tree
		@knn_create($out_pos_to_knn)
	}	
	
	@proc_def play_concat($buff, $env, $group)
	{
		whenever ($update == $update)
		{
		  @local $tab_ind_val, $i1 := 0, $i2 := 0, $idx, $val, $r, $normalized_dist

			// print firefly_coord (""+$firefly_coord)

			$r := @zip(@knn_rsearch($out_pos_to_knn, $firefly_coord, $firefly_radius*$firefly_radius)) //@knn_rsearch($out_pos_to_knn, $coords*$fact, 50*$fact))
		 
			// print zip (""+$r)

			forall $knn_pair in $r
			{
			   $idx := $knn_pair[0]
			   $val := $knn_pair[1]
			   $normalized_dist := @scale($val, $firefly_radius*$firefly_radius, 0, 0, 1, 1)
			   // print idx $idx
			//    if ($val != <undef>)
			//    {
			//    	print val0 $val
			//    	print val (""+@scale($val, $firefly_radius*$firefly_radius, 0, 0, 1, 1))
			// }

			   if($knn_matches($idx).is_undef() && $normalized_dist > 0.4)
			   {
				$knn_matches.add_pair($idx, $normalized_dist)
				   // print sample ($out_pos_final[$idx*$tab_of_size]) ($out_pos_final[$idx*$tab_of_size+1]) ($out_pos_final[$idx*$tab_of_size+2]) ($smir_analyze_tab[$idx][0].linlin(-1, 1, 0, 1))
				   // print matches (""+$knn_matches)
				   // print idx val $idx $val
				   //HOA_grain2_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07)
				::HOA_grain2_xyz($buff, $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0], $out_pos_to_knn[$idx][1], $out_pos_to_knn[$idx][2], 0, $group)

					knn_search_list ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					// print knn_list $idx $normalized_dist ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					// print index0 ($out_pos_to_knn[2][0]) ($out_pos_to_knn[2][1]) ($out_pos_to_knn[2][2])
					// print index $idx ($out_pos_final[$idx]) ($out_pos_final[$idx]) ($out_pos_final[$idx])
			   }
			   else
			   {
					if($knn_matches.is_defined($idx) && $normalized_dist <= 0.4)
					{
					$knn_matches.remove($idx)
					// print remove $idx $normalized_dist
					}
			   }
			}
		// print knn_size ($knn_matches.size())
		}
	}

	@proc_def play_concat_multi1($env, $tracks_concat)
	{
		whenever ($update == $update)
		{
		  @local $tab_ind_val, $i1 := 0, $i2 := 0, $idx, $val, $r, $normalized_dist, $knn_matches_size := 0, $trig_thresh_in := 0.2, $trig_thresh_out := 0.1

			// print firefly_coord (""+$firefly_coord)

			$r := @zip(@knn_rsearch($out_pos_to_knn, $firefly_coord, $firefly_radius*$firefly_radius)) //@knn_rsearch($out_pos_to_knn, $coords*$fact, 50*$fact))

		 
			// print zip (""+$r)

			forall $knn_pair in $r
			{
			   $idx := $knn_pair[0]
			   $val := $knn_pair[1]
			   $normalized_dist := @scale($val, $firefly_radius*$firefly_radius, 0, 0, 1, 1)
			   // print idx $idx
			//    if ($val != <undef>)
			//    {
			//    	print val0 $val
			//    	print val (""+@scale($val, $firefly_radius*$firefly_radius, 0, 0, 1, 1))
			// }

			   if($knn_matches($idx).is_undef() && $normalized_dist > $trig_thresh_in)
			   {
				$knn_matches.add_pair($idx, $normalized_dist)
				$knn_matches_size := $knn_matches.size()
				// print (""+$knn_matches)
				// print knn_size $knn_matches_size
				// print smir_completa ($smir_analyze_tab[$idx])
				   // print sample ($out_pos_final[$idx*$tab_of_size]) ($out_pos_final[$idx*$tab_of_size+1]) ($out_pos_final[$idx*$tab_of_size+2]) ($smir_analyze_tab[$idx][0].linlin(-1, 1, 0, 1))
				   // print matches (""+$knn_matches)
				   // print idx val $idx $val
				   //HOA_grain2_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07)   
				  switch
				  {
					 case $knn_matches_size < 20:

					 // print 0 (""+$bufmun_map)
					 // print 1 (""+($smir_analyze_tab[$idx][11]))
					 // print 2 ($bufmun_map($smir_analyze_tab[$idx][11]))
					 // print smir_test (""+[$bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, ($smir_analyze_tab[$idx][10]), ($smir_analyze_tab[$idx][9]), ($out_pos_to_knn[$idx][0]/300), ($out_pos_to_knn[$idx][1]/300), ($out_pos_to_knn[$idx][2]/300), 0, "group_hoa1"])

			// 	@proc_def HOA_grain2_xyz ($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07) 
			// @proc_def HOA_grain_xyz_track($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $track_HOA_NE, $spk_radius = 1.07) 

			// print: smir_test TAB["Raggi-p3-concat.aif", "perc", 1, 0.0696602, 17.2176, -282.188, 63.8533, 126.24, 0, "group_hoa1"]

					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[0])
					 case $knn_matches_size < 40:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[1])
					 case $knn_matches_size < 60:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[2])
					 case $knn_matches_size < 80:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[3])
					 case $knn_matches_size < 100:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[4])
					 case $knn_matches_size < 120:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[5])
					 case $knn_matches_size < 140:
					 print "overload"
				  } 			     
				   // if($knn_matches_size > 20)
				   // {
				   // 	::HOA_grain2_xyz($buff, $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0], $out_pos_to_knn[$idx][1], $out_pos_to_knn[$idx][2], 0, $group)
				   // }
				   // else
				   // {
				   // 	::HOA_grain2_xyz($buff, $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0], $out_pos_to_knn[$idx][1], $out_pos_to_knn[$idx][2], 0, $group2)
				   // }

					knn_search_list ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					
					// print knn_list $idx $normalized_dist ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					// print index0 ($out_pos_to_knn[2][0]) ($out_pos_to_knn[2][1]) ($out_pos_to_knn[2][2])
					// print index $idx ($out_pos_final[$idx]) ($out_pos_final[$idx]) ($out_pos_final[$idx])
			   }
			   else
			   {
					if($knn_matches.is_defined($idx) && $normalized_dist <= $trig_thresh_out)
					{
					$knn_matches.remove($idx)
					// print remove $idx $normalized_dist
					}
			   }
			}
		// print knn_size ($knn_matches.size())
		
		}
	}	

	@proc_def play_concat_multi2($env, $tracks_concat)
	{
		whenever ($update == $update)
		{
		  @local $tab_ind_val, $i1 := 0, $i2 := 0, $idx, $val, $normalized_dist, $knn_matches_size := 0, $trig_thresh_in := 0.2, $trig_thresh_out := 0.1, $r2

			// print firefly_coord (""+$firefly_coord)

			$r2 := @zip(@knn_rsearch($out_pos_to_knn, $firefly_coord2, $firefly_radius2*$firefly_radius2)) //@knn_rsearch($out_pos_to_knn, $coords*$fact, 50*$fact))

		 
			// print zip (""+$r)

			forall $knn_pair in $r2
			{
			   $idx := $knn_pair[0]
			   $val := $knn_pair[1]
			   $normalized_dist := @scale($val, $firefly_radius2*$firefly_radius2, 0, 0, 1, 1)
			   // print idx $idx
			//    if ($val != <undef>)
			//    {
			//    	print val0 $val
			//    	print val (""+@scale($val, $firefly_radius*$firefly_radius, 0, 0, 1, 1))
			// }

			   if($knn_matches2($idx).is_undef() && $normalized_dist > $trig_thresh_in)
			   {
				$knn_matches2.add_pair($idx, $normalized_dist)
				// print smir_completa ($smir_analyze_tab[$idx])
				   // print sample ($out_pos_final[$idx*$tab_of_size]) ($out_pos_final[$idx*$tab_of_size+1]) ($out_pos_final[$idx*$tab_of_size+2]) ($smir_analyze_tab[$idx][0].linlin(-1, 1, 0, 1))
				   // print matches (""+$knn_matches)
				   // print idx val $idx $val
				   //HOA_grain2_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07)   
				  switch
				  {
					 case $knn_matches_size < 20:

					 // print 0 (""+$bufmun_map)
					 // print 1 (""+($smir_analyze_tab[$idx][11]))
					 // print 2 ($bufmun_map($smir_analyze_tab[$idx][11]))
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[0])
					 case $knn_matches_size < 40:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[1])
					 case $knn_matches_size < 65:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[2])
					 case $knn_matches_size < 80:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[3])
					 case $knn_matches_size < 100:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[4])
					 case $knn_matches_size < 120:
					 ::HOA_grain_xyz_track2($bufmun_map($smir_analyze_tab[$idx][12]), $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0]/300, $out_pos_to_knn[$idx][1]/300, $out_pos_to_knn[$idx][2]/300, 0, $tracks_concat[5])
					 case $knn_matches_size < 140:
					 print "overload"
				  } 			     
				   // if($knn_matches_size > 20)
				   // {
				   // 	::HOA_grain2_xyz($buff, $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0], $out_pos_to_knn[$idx][1], $out_pos_to_knn[$idx][2], 0, $group)
				   // }
				   // else
				   // {
				   // 	::HOA_grain2_xyz($buff, $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0], $out_pos_to_knn[$idx][1], $out_pos_to_knn[$idx][2], 0, $group2)
				   // }

					knn_search_list ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					$knn_matches_size := $knn_matches2.size()
					// print knn_list $idx $normalized_dist ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					// print index0 ($out_pos_to_knn[2][0]) ($out_pos_to_knn[2][1]) ($out_pos_to_knn[2][2])
					// print index $idx ($out_pos_final[$idx]) ($out_pos_final[$idx]) ($out_pos_final[$idx])
			   }
			   else
			   {
					if($knn_matches2.is_defined($idx) && $normalized_dist <= $trig_thresh_out)
					{
					$knn_matches2.remove($idx)
					// print remove $idx $normalized_dist
					}
			   }
			}
		// print knn_size ($knn_matches.size())
		}
	}
}

// ofMap(searchResults[i].second, concat_radius * concat_radius, 0, 0, 1, true);

$corpus_map := map{}

@obj_def scmir_segmentation($corpus_name, $audio_file_folder, $features, $segmentation) // analyze and extract features from audio file
{
	@local $smir_analyze_tab := [], $ana_count := 0, $analyze_active := 0, $out_pos_final := [], $out_pos_to_knn := [], $index := 0 , $width := 2 , $height := 2 , $radius := [], $tab_of_size := 5, $knn_matches := MAP{}, $dir_analyze //8
	@init
	{
		// $THISOBJ.analyze($buf, $features, $segmentation) 
		$dir_analyze := @directory_read($audio_file_folder)

		if($dir_analyze.is_undef())
		{
			print file
			$THISOBJ.analyze($buf, $features, $segmentation) 
		}
		else
		{
			print dir (""+$dir_test)
			
			$THISOBJ.analyze_dir($buf, $features, $segmentation) 
		}
	}

	@proc_def analyze($buf, $features, $segmentation)
	{
		@set_osc_handling_tab(true)
		print $path
		concat_smir_analyze $segmentation ($path+$buf) $features
		$analyze_active := 1
		@set_osc_handling_tab(1)
	}

	@proc_def analyze_dir($buf, $features, $segmentation)
	{
		@set_osc_handling_tab(true)
		print $path
		concat_smir_analyze $segmentation ($path+$buf) $features
		$analyze_active := 1
		@set_osc_handling_tab(1)
	}

	@proc_def add_analyze($buf, $segmentation)
	{
		print add_analyze
		@set_osc_handling_tab(true)
		print $path
		concat_smir_analyze $segmentation ($path+$buf) $features
		$analyze_active := 1
		@set_osc_handling_tab(1)
	}
	
	@whenever ($from_smir == $from_smir && $analyze_active) 
	{
		// print $from_smir
		if($from_smir[1] != "end")
		{
			$from_smir.push_back($ana_count)
			$smir_analyze_tab.push_back($from_smir.cdr())
			$ana_count += 1
			print features_frames $ana_count
		}
		else
		{
			print "Processing Finished...analysis ready for use."
			$analyze_active := 0
		}
		// print (""+$smir_analyze_tab)
	}
	@proc_def print_analyze()
	{
		print analyze_tab (""+$smir_analyze_tab)
	}
	@proc_def map2knn($x, $y, $z, $radius, $col)
	{
		@local $pos_x, $pos_y, $pos_z, $pos_final_x, $pos_final_y, $pos_final_z, $pos_radius, $color, $features_flat := []

		forall $feat in $features
		{
			$features_flat.push_back($feat[0])
		}

		$out_pos_final := [  0 | ($smir_analyze_tab.size()*$tab_of_size) ]
		
		$pos_x :=  @occurs($features_flat, $x)
		$pos_y :=  @occurs($features_flat, $y)
		$pos_z :=  @occurs($features_flat, $z)
		$pos_radius :=  @occurs($features_flat, $radius)
		$color := @occurs($features_flat, $col)
		// print pos_x $pos_x
		// print pos_y $pos_y
		// print pos_z $pos_z
		// print pos_radius $pos_radius

		forall $anatab in $smir_analyze_tab
		{
			// print anatab $anatab
			$pos_final_x := $anatab[$pos_x].linlin(0,1,-1,1) * $fact
			$pos_final_y := $anatab[$pos_y].linlin(0,1,-1,1) * $fact
			$pos_final_z := $anatab[$pos_z].linlin(0,1,0,1) * $fact

			$out_pos_to_knn.push_back([$pos_final_x, $pos_final_y, $pos_final_z])
			// to oFx
			$out_pos_final[$index*$tab_of_size] := $pos_final_x
			$out_pos_final[$index*$tab_of_size+1] := $pos_final_y
			$out_pos_final[$index*$tab_of_size+2] := $pos_final_z
			$out_pos_final[$index*$tab_of_size+3] := $anatab[$pos_radius].linlin(0,1,1,5)
			$out_pos_final[$index*$tab_of_size+4] := $anatab[$color].linlin(0,1,42,255)

			$index += 1
		}	
		// print index3 ($out_pos_final[0*3+3])

		print knn_create (""+$out_pos_final)
		of_concat3D $out_pos_final
		print knn_tree
		@knn_create($out_pos_to_knn)
	}	
	
	@proc_def play_concat($buff, $env, $group)
	{
		whenever ($update == $update)
		{
		  @local $tab_ind_val, $i1 := 0, $i2 := 0, $idx, $val, $r, $normalized_dist

			// print firefly_coord (""+$firefly_coord)

			$r := @zip(@knn_rsearch($out_pos_to_knn, $firefly_coord, $firefly_radius*$firefly_radius)) //@knn_rsearch($out_pos_to_knn, $coords*$fact, 50*$fact))
		 
			// print zip (""+$r)

			forall $knn_pair in $r
			{
			   $idx := $knn_pair[0]
			   $val := $knn_pair[1]
			   $normalized_dist := @scale($val, $firefly_radius*$firefly_radius, 0, 0, 1, 1)
			   // print idx $idx
			//    if ($val != <undef>)
			//    {
			//    	print val0 $val
			//    	print val (""+@scale($val, $firefly_radius*$firefly_radius, 0, 0, 1, 1))
			// }

			   if($knn_matches($idx).is_undef() && $normalized_dist > 0.4)
			   {
				$knn_matches.add_pair($idx, $normalized_dist)
				   // print sample ($out_pos_final[$idx*$tab_of_size]) ($out_pos_final[$idx*$tab_of_size+1]) ($out_pos_final[$idx*$tab_of_size+2]) ($smir_analyze_tab[$idx][0].linlin(-1, 1, 0, 1))
				   // print matches (""+$knn_matches)
				   // print idx val $idx $val
				   //HOA_grain2_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07)
				::HOA_grain2_xyz($buff, $env, 1, $smir_analyze_tab[$idx][10], $smir_analyze_tab[$idx][9], $out_pos_to_knn[$idx][0], $out_pos_to_knn[$idx][1], $out_pos_to_knn[$idx][2], 0, $group)

					knn_search_list ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					// print knn_list $idx $normalized_dist ($out_pos_to_knn[$idx][0]) ($out_pos_to_knn[$idx][1]) ($out_pos_to_knn[$idx][2]) $normalized_dist
					// print index0 ($out_pos_to_knn[2][0]) ($out_pos_to_knn[2][1]) ($out_pos_to_knn[2][2])
					// print index $idx ($out_pos_final[$idx]) ($out_pos_final[$idx]) ($out_pos_final[$idx])
			   }
			   else
			   {
					if($knn_matches.is_defined($idx) && $normalized_dist <= 0.4)
					{
					$knn_matches.remove($idx)
					// print remove $idx $normalized_dist
					}
			   }
			}
		}
	}
}







whenever ($current_servers)
{
	servers_max ($Servers.domain())
}

whenever ($current_groups)
{
	print (""+($sc_struct))
	print __________________
	print (""+($synths_map($current_groups)))
	$cu_servers := $current_groups
	forall $x in $synths_map($current_groups).domain()
	{
		groups_max ($synths_map($current_groups)($x)("group")) $x $cu_servers // return node_id mix_group name
	}
	// groups_max ($synths_map($current_groups).domain())	
}



whenever ($current_tracks)
{
	// tracks_max (""+($synths_map($current_groups)($current_tracks)))
	if($current_tracks.is_tab())
	{
		$cu_servers := $current_tracks[1]
		$cu_tracks := $current_tracks[0]
		forall $k, $v in $synths_map($cu_servers)($cu_tracks)
		{
			if($k != "group")
			{
				tracks_max ($v("group")) $k
			}
			// tracks_max ($x("group")) tracks
			// tracks_max (""+($x))
		}
	}
	else
	{
		if($synths_map($cu_servers)($current_tracks) != <undef>)
		{
		forall $k, $v in $synths_map($cu_servers)($current_tracks)
			{
				$cu_tracks := $current_tracks
				if($k != "group")
				{
					tracks_max ($v("group")) $k
				}
				// tracks_max ($x("group")) tracks
				// tracks_max (""+($x))
			}
		}
	}
}

whenever ($current_synths)
{
	// synths_max (""+($synths_map($current_groups)($current_tracks)($current_synths)))
	if($current_synths.is_tab())
	{
		$cu_servers := $current_synths[2]
		$cu_tracks := $current_synths[1]
		forall $k, $v in $synths_map($cu_servers)($cu_tracks)($current_synths[0])
		{
			if($k != "group")
			{
				if($v.is_tab())
				{
					forall $t in $v
					{
						synths_max $t $k
					}

				}
				else
				{
					synths_max $v $k
				}
			}
		}
	}
	else
	{
		forall $k, $v in $synths_map($cu_servers)($cu_tracks)($current_synths)
		{
			if($k != "group")
			{
				if($v.is_tab())
				{
					forall $t in $v
					{
						synths_max $t $k
					}

				}
				else
				{
					synths_max $v $k
				}
			}
		}
	}
}

whenever ($current_groups_all)
{
	synth_groups_all clear
	print (""+($synths_map.domain()))
	forall $x, $y in $synths_map
	{
		// synth_groups_all (""+($x))
		forall $k, $v in $y
		{
			synth_groups_all ($v("group")) $k $x
		}
		 
	}
}


whenever ($stop_groups_all)
{
	print stop all groups in all servers

	forall $k, $g in $groups
	{
		$g.free(0.5)
	}

	// forall $k, $v in $Servers
	// {
	// 	$v.g_freeAll(1)
	// }
	// 0.6 $SC_Groups := map{}
	// $groups := map{} // clean dico
	// $tracks := map{} // clean dico
	// print synths_map (""+$synths_map)
	// forall $k, $v in $synths_map
	// {
	// 	$synths_map.add_pair($k, map{}) // remove maps
	// }
	// print synths_map2 (""+$synths_map)
	synth_groups_all clear 
}





whenever ($current_tracks_all)
{
	synth_tracks_all clear
	// print (""+($synths_map.rand_range()))
	forall $x, $y in $synths_map
	{
		forall $k, $v in $y
		{
			forall $tr, $trv in $v
			{
				if($tr != "group")
				{
					synth_tracks_all ($trv("group")) $tr $k $x // node track group server
				}	
			}

		}		 
	}
}

whenever ($free_tracks)
{
	forall $k, $v in $tracks
	{
		$v.free($free_tracks)
	}
	// ($free_tracks+0.005) $tracks := map{} // clean dico
	forall $k, $v in $SC_Servers
	{
		// print (""+$k)
		$SC_Servers($k).insert("bus_index", 500) // reset all bus to index 500
	}
}

whenever ($free_select_track)
{
	// synth_groups_all clear
	// print (""+($synths_map)($cu_servers)($cu_tracks))
	// print free ($free_select_track[1])
	print free (""+$free_select_track)
	// $Servers($cu_servers).n_set($free_select_track[0], ["out_ramp", 0.01, "gatee", 0])
	// $synths_map($cu_servers)($cu_tracks).remove($free_select_track[1])
	$tracks($free_select_track[1]).free(0.1)
	// $tracks.remove($free_select_track[1])

}



whenever ($free_select_group)
{
	print groups $free_select_group
	print groups2 (""+$SC_Groups)
	print groups3 (""+$groups)

	// print synths_map (""+$synths_map($cu_servers))
	if($free_select_group.size() == 3) // si Max interface select with server name
	{
		$cu_servers := $free_select_group[2]
	}
	print free_group ($free_select_group[1])

	// $Servers($cu_servers).n_set($free_select_group[0], ["out_ramp", 0.01, "gatee", 0]) // free group in $time

	$groups($free_select_group[1]).free(0.1)

	forall $k in $synths_map($cu_servers)($free_select_group[1]).domain() // remove tracks map
	{
		if($k != "group")
		{
			$tracks.remove($k)
		}
	}

	// $synths_map($cu_servers).remove($free_select_group[1])
	$groups.remove($free_select_group[1])
	// $SC_Groups.remove($free_select_group[1])


}

whenever ($reconstruct_ob) // reconstruction des objets 
{
	@sc_build_map_from_id($sc_struct)
}

whenever ($free_groups) // reponse server
{
	// print reponse scServer $server
	// scServer "g_freeAll" 1


	if ($groups.size() > 0)
	{
		forall $k, $g in $groups
		{
			$g.free(0.5)
		}
	}

	0.6 forall $s, $o in $Servers
	{
		$o.g_freeAll(1)
	}

	// openframeworks GUI
	$gui_enabled := false
	$gui := false

	// Global variables

	// $bus_index := 86-8
	// $group := 0
	// $out_synth := 0
	// $SC_Buffers_index := 0 // index for buffers
	// $server_sync := 0

	/// patch soundFiles
	// $path := $home + "/Library/Application\ Support/SuperCollider/sounds/"



	// // server commands falta "Synth Definition Commands"
	// $osc_server_commands := ["quit", "notify", "status", "cmd", "dumpOSC", "sync", "clearSched", "error", "version", "n_free", "n_run", "n_set", "n_setn", "n_fill", "n_map", "n_mapn", "n_mapa", "n_mapan", "n_before", "n_after", "n_query", "n_trace", "n_order", "s_new", "s_get", "s_getn", "s_noid", "g_new", "p_new", "g_head", "g_tail", "g_freeAll", "g_freeAll", "g_dumpTree", "g_queryTree", "b_alloc", "b_allocRead", "b_allocReadChannel", "b_read", "b_readChannel", "b_write", "b_free", "b_zero", "b_set", "b_setn", "b_fill", "b_gen", "b_close", "b_query", "b_get", "b_get"]

	 // 
	// $sc_struct.add_pair("localhost", map{(1, map{ ("default_group", [] )}) }) // root tree 0 -> default group 1

	// $SC_Servers := map{}
	// $Servers := map{}
	/*
	$sc_group_struct := map{ }
	$SC_Groups := map{}
	$synths_map := map{}
	$track_proc := map{}
	$sc_group_id := 300
	// $sc_id := 0
	$node_id := 100
	$bus_index := 86 // depende de los IN/out de la carte son
	$from_sc_server := 0
	*/

	// print toto
}


whenever($server_lev==$server_lev)
{
	$Servers("server1").volume($server_lev)
}
whenever($server_lev2==$server_lev2)
{
	$Servers("server2").volume($server_lev2)
}	
whenever($server_le3==$server_le3)
{
	$Servers("server3").volume($server_lev)
}
whenever($server_lev4==$server_lev4)
{
	$Servers("server4").volume($server_lev4)
}
whenever($server_le5==$server_le5)
{
	$Servers("server5").volume($server_le5)
}
whenever($server_lev6==$server_lev6)
{
	$Servers("server6").volume($server_lev6)
}


whenever($reset_buffers==$reset_buffers)
{
	forall $k, $v in $buffers
	{
		forall $key, $val in $v
		{
			$Servers($k).b_zero($val)	// reset all buf values to zero
		}
	}
	forall $k, $v in $gran_buf
	{
		forall $i in ($v[1]-$v[0])+1
		{
			// print ($i+$v[0])
			$Servers($k).b_zero($i+$v[0])	// reset all buf values to zero			
		}

	}	
	forall $k, $v in $fft_buf
	{
		forall $i in ($v[1]-$v[0])+1
		{
			// print ($i+$v[0])
			$Servers($k).b_zero($i+$v[0])	// reset all buf values to zero						
		}

	}		
}


// whenever($HOA_global_x==$HOA_global_x)
// {
// 	print $HOA_global_x
// }

///// Vezer XML
// SC plot

// oscsend plot "localhost" :7002 "/plot" // plot NIMS in SC
// oscsend plotnim "localhost" :7002 "/plotnim" // plot NIMS in SC



// Function @extract is used to extract the first tag with a given "name"

@fun_def @extract($tab, $name)
{
	if ($tab.is_tab())
	{
	    if ($tab[0] == $name)
	 { return $tab }
	 else
	 {
		if ($tab.size() == 3)
		{ return $tab[2].extract2(0, $name) }
		else
		{ return <undef> }
	 }
	}
	else
	{ return <undef> }
}

@fun_def @extract2($tab, $index, $name)
{
    if ($tab.is_tab() && $index < $tab.size() && $tab[$index].is_tab())
    {
	if ($tab[$index, 0] == $name)
	{ return $tab[$index] }
	else
	{
		@local $ret := @extract2($tab[$index, 2], 0, $name)
		if ($ret.is_tab())
		{ return $ret }
		else
		{ return @extract2($tab, $index + 1, $name) }
	}
    }
    else
    { return <undef> }
}


// Functions HOA grains

// cartesian
@fun_def set_HOA_rand_x($o, $val) { $o.rand_x($val) }
@fun_def set_HOA_rand_y($o, $val) { $o.rand_y($val) }
@fun_def set_HOA_rand_z($o, $val) { $o.rand_z($val) }
@fun_def set_HOA_rand_rate($o, $val) { $o.rate($val) }
@fun_def set_HOA_rand_pos($o, $val) { $o.pos($val) }
@fun_def set_HOA_rand_env_dur($o, $val) { $o.env_dur($val) }
@fun_def set_HOA_rand_ryth($o, $val) { $o.ryth($val) }
// @fun_def set_HOA_rand_env_dur2($o, $val) { $o.env_dur2($val) }
@fun_def set_HOA_rand_pos_lfo($o, $val) { $o.pos_lfo($val) }
@fun_def set_HOA_rand_ifac($o, $val) { $o.ifac($val) }


// polar
@fun_def set_HOA_rand_theta($o, $val) { $o.rand_theta($val) }
@fun_def set_HOA_rand_phi($o, $val) { $o.rand_phi($val) }
@fun_def set_HOA_rand_radio($o, $val) { $o.rand_radio($val) }


// @proc_def ::nim2buffer($nim_in)
// {
// 	@local $t_nim, $t_inc := 0
// 	@set_osc_handling_tab(true) ///SuperCollider

// 	if($nim_in.is_tab())
//   	{
//   		loop 0.2 // $nim_ind in $nim_in
//   		{
// 	  		b_alloclocalhost $SC_Buffers_index 1000 // $SC_Buffers_index variable globale de incrementation de buffers
// 			// synclocalhost 1
// 			// whenever when bidirectional OSC
// 			$t_nim := [ $nim_in[$t_inc]($x) | $x in 0 .. @max_key($nim_in[$t_inc]) : @max_key($nim_in[$t_inc])/1000 ] //1024 elements for SC buffers
// 			0.1 b_setnlocalhost $SC_Buffers_index 0 1000 $t_nim 
// 			$SC_Buffers_index += 1
// 			$t_inc += 1
//   		}until ($t_inc == $nim_in.size())
//   	}
//   	else
//   	{
// 		b_alloclocalhost $SC_Buffers_index 1000 // $SC_Buffers_index variable globale de incrementation de buffers
// 		// synclocalhost 1
// 		// whenever when bidirectional OSC
// 		$t_nim := [ $nim_in($x) | $x in 0 .. @max_key($nim_in) : @max_key($nim_in)/1000 ] //1024 elements for SC buffers
// 		0.1 b_setnlocalhost $SC_Buffers_index 0 1000 $t_nim 
// 		$SC_Buffers_index += 1
// 	}
// }


@proc_def ::plotnim($nim_in)
{
  @local $t_nim, $tab_nim, $max_nim_key_ant := 0, $max_nim_key := 0
  @set_osc_handling_tab(0)/// send OSC Arrays to SuperCollider Language
  // print (""+$nim_in)
  $tab_nim := []
  if($nim_in.is_tab())
  {
	forall $nim_ind in $nim_in
	{
		$tab_nim.push_back([ $nim_ind($x) | $x in 0 .. @max_key($nim_ind) : @max_key($nim_ind)/(1000/$nim_ind.size()) ]) //40 elements !!narrive pas à 1 /@max_key($nim_in)
		$max_nim_key := @max_key($nim_ind)
		if($max_nim_key > $max_nim_key_ant)
		{
			$max_nim_key_ant := $max_nim_key
		}else{
			$max_nim_key := $max_nim_key_ant
		}
		$max_nim_key_ant := @max_key($nim_ind)
	}
	plotnim $max_nim_key $tab_nim
  }
  else
  {
	  $t_nim := [ $nim_in($x) | $x in 0 .. @max_key($nim_in) : @max_key($nim_in)/1000 ] //40 elements !!narrive pas à 1 /@max_key($nim_in)
	  plotnim @max_key($nim_in) $t_nim 
  }
  @set_osc_handling_tab(1)
}


// $vezer_curves := map{}
// $interpol_types := map {("linear", "linear"), ("quadratic-in", "quad_in"), ("quadratic-out", "quad_out"), ("quadratic-in-out", "quad_in_out"), ("cubic-in", "cubic_in"), ("cubic-out", "cubic_out"), ("cubic-in-out", "cubic_in_out"), ("quartic-in", "quart_in"), ("quartic-out", "quart_out"), ("quartic-in-out", "quart_in_out"), ("quintic-in", "quint_in"), ("quintic-out", "quint_out"), ("quintic-in-out", "quint_in_out"), ("sine-in", "sine_in"), ("sine-out", "sine_out"), ("sine-in-out", "sine_in_out"), ("circular-in", "circ_in"), ("circular-out", "circ_out"), ("circular-in-out", "circ_in_out"), ("exponential-in", "exp_in"), ("exponential-out", "exp_out"), ("exponential-in-out", "exp_in_out"), ("elastic-in", "elastic_in"), ("elastic-out", "elastic_out"), ("elastic-in-out", "elastic_in_out"), ("back-in", "back_in"), ("back-out", "back_out"), ("back-in-out", "back_in_out"), ("bounce-in", "bounce_in"), ("bounce-out", "bounce_out"), ("bounce-in-out", "bounce_in_out")}

@global $vezer_curves @persistent
@global $interpol_types @persistent
if (@is_undef($vezer_curves)) { $vezer_curves := map{} }
if (@is_undef($interpol_types)) { $interpol_types := map {("linear", "linear"), ("quadratic-in", "quad_in"), ("quadratic-out", "quad_out"), ("quadratic-in-out", "quad_in_out"), ("cubic-in", "cubic_in"), ("cubic-out", "cubic_out"), ("cubic-in-out", "cubic_in_out"), ("quartic-in", "quart_in"), ("quartic-out", "quart_out"), ("quartic-in-out", "quart_in_out"), ("quintic-in", "quint_in"), ("quintic-out", "quint_out"), ("quintic-in-out", "quint_in_out"), ("sine-in", "sine_in"), ("sine-out", "sine_out"), ("sine-in-out", "sine_in_out"), ("circular-in", "circ_in"), ("circular-out", "circ_out"), ("circular-in-out", "circ_in_out"), ("exponential-in", "exp_in"), ("exponential-out", "exp_out"), ("exponential-in-out", "exp_in_out"), ("elastic-in", "elastic_in"), ("elastic-out", "elastic_out"), ("elastic-in-out", "elastic_in_out"), ("back-in", "back_in"), ("back-out", "back_out"), ("back-in-out", "back_in_out"), ("bounce-in", "bounce_in"), ("bounce-out", "bounce_out"), ("bounce-in-out", "bounce_in_out")} }


// ::plotnim($envs_map("perc"))

@proc_def ::vezerxml2nim($xml, $nom)
{
	@local $tracks, $fps, $inc_nim := 0, $prec_time := 0, $time, $value, $typ  //, $result := [] //bug??

	$result := []
	$tracks := @extract($xml, "tracks")[2]
	$fps := @extract($xml, "fps")[2]

	// $nom := $nom

	forall $res in $tracks
	{
		$result.push_back($res.extract("keyframes"))
	}

	// print result (""+$result)
	if($tracks.size() > 1) // si multichannel
	{
		$vezer_curves.add_pair($nom, [ <undef> | $array in $tracks.size() ])
	}

	forall $keyframes in $result
	{
		if($tracks.size() > 1) // si multichannel
		{
			forall $item in $keyframes[2]
			{
				$time := $item[2,0,2,0]/$fps
				$value := $item[2,1,2,0]
				$typ := $item[2,2,2,0]

				
				if ($vezer_curves($nom)[$inc_nim].is_undef())
				{ 			 		
					let $vezer_curves($nom)[$inc_nim] := NIM{ $time $value, 0 $value "linear"}
					// print ("====== "+$vezer_curves)

				}
				_ := $vezer_curves($nom)[$inc_nim].push_back($time - $prec_time, $value, $interpol_types($typ))
				$prec_time := $time
				// print ($vezer_curves($nom))
			}
		}
		else
		{
			$vezer_curves.remove($nom)
			
			forall $item in $keyframes[2]
			{
				$time := $item[2,0,2,0]/$fps
				$value := $item[2,1,2,0]
				$typ := $item[2,2,2,0]

				
				if ($vezer_curves($nom).is_undef())
				{ 
					// $nim := NIM{ $time $value, 0 $value "linear"} 
					$vezer_curves.add_pair($nom, NIM{ $time $value, 0 $value "linear"} )
					// print ("====== "+$vezer_curves)

				}
				$vezer_curves($nom).push_back($time - $prec_time, $value, $interpol_types($typ))
				$prec_time := $time
				// print ($vezer_curves($nom))

			}
		}
		$inc_nim := $inc_nim + 1
		$prec_time := 0 // reset time pour chaque nim
	}
}

@proc_def ::vezerxml2nim_param($xml, $nom)
{
	@local $tracks, $fps, $on_occur := 0, $params, $inc_nim := 0, $prec_time := 0, $time, $value, $typ, $result, $state  //, $result := [] //bug??

	$result := []
	$state := []
	$tracks := @extract($xml, "tracks")[2]
	$fps := @extract($xml, "fps")[2]
	$params := []
	// $nom := $nom
	
	forall $res in $tracks
	{
		if($res.extract("state")[2, 0] == "on") // si le track est on
		{
			$state.push_back($res.extract("state")[2, 0])
			$result.push_back($res.extract("keyframes"))
			$params.push_back($res.extract("name")[2, 0])	
		}
	}

	if($tracks.size() > 1) // si multichannel
	{
		$vezer_curves.add_pair($nom, [ <undef> | $array in $state.size() ])
	}

	forall $keyframes in $result
	{
			if($tracks.size() > 1) // si multichannel
			{
				forall $item in $keyframes[2]
				{
					$time := $item[2,0,2,0]/$fps
					$value := $item[2,1,2,0]
					$typ := $item[2,2,2,0]

					
					if ($vezer_curves($nom)[$inc_nim].is_undef())
					{ 			 		
						let $vezer_curves($nom)[$inc_nim] := NIM{ $time $value, 0 $value "linear"}
						// print ("====== "+$vezer_curves)
					}

					_ := $vezer_curves($nom)[$inc_nim].push_back($time - $prec_time, $value, $interpol_types($typ))
					$prec_time := $time
					// print ($vezer_curves($nom))
						
				}
			}
			else
			{
				$vezer_curves.remove($nom)
			
				forall $item in $keyframes[2]
				{
					$time := $item[2,0,2,0]/$fps
					$value := $item[2,1,2,0]
					$typ := $item[2,2,2,0]
					
					if ($vezer_curves($nom).is_undef())
					{ 
						// $nim := NIM{ $time $value, 0 $value "linear"} 
						$vezer_curves.add_pair($nom, NIM{ $time $value, 0 $value "linear"} )
						// print ("====== "+$vezer_curves)
					}
					$vezer_curves($nom).push_back($time - $prec_time, $value, $interpol_types($typ))
					$prec_time := $time
					// print ($vezer_curves($nom))
				}
					
			}
			let $vezer_curves($nom)[$inc_nim] := [$params[$inc_nim], $vezer_curves($nom)[$inc_nim]]
			// print vezer_curves (""+$vezer_curves($nom)[$inc_nim])

			$inc_nim := $inc_nim + 1
			$prec_time := 0 // reset time pour chaque nim
	}
}

@proc_def ::load_vezer2nim_param() // read hrir audio files into buffers
{
	forall $k, $v in $vezer_nims
	{
		::vezerxml2nim_param(@xml_read($vezer_path+$v), $k.drop(-4))
		print load verzer xml $v
	}
}

@proc_def ::refresh_vezer2nim() // read hrir audio files into buffers
{
	$vezer_nims := @directory_read($vezer_path, 2, ["xml"])
	0.1 forall $k, $v in $vezer_nims
	{
		::vezerxml2nim_param(@xml_read($vezer_path+$v), $k.drop(-4))
		print load verzer xml $v
	}
}

// agragate NIM

@proc_def ::play_vezer_nim($cmd, $name)
{
	@local $nim_play, $val, $curve_index := 0, $debut, $fin

	$nim_play := $vezer_curves($name)

	// if($nim_play.is_tab())
	// {
		$nim_play := @aggregate($nim_play)
		$debut := $nim_play.min_key()
		$fin := $nim_play.max_key()
		print debut $debut
		print fin $fin
		print NIMS (""+$nim_play)
			curve 
			@grain := 0.01, 
			@action  { //$val_array[$curve_index] := $val 
				// print $val //($nim_play($val) )
				// @command($cmd) $val
				print $val 
				} 

			{ $val : $nim_play }
}


// print cos (""+@cos(195))

// print cosh (@cosh(195))
// print acos (@acos(195))

// print sin (""+@sin(195))
// print acos (@acos(5))
//////////////////////// Vezér Import/export /////////////////////////

// map Vezér2Antescofo interpolation
// $interpol_types := map {("linear", "linear"), ("quadratic-in", "quad_in"), ("quadratic-out", "quad_out"), ("quadratic-in-out", "quad_in_out"), ("cubic-in", "cubic_in"), ("cubic-out", "cubic_out"), ("cubic-in-out", "cubic_in_out"), ("quartic-in", "quart_in"), ("quartic-out", "quart_out"), ("quartic-in-out", "quart_in_out"), ("quintic-in", "quint_in"), ("quintic-out", "quint_out"), ("quintic-in-out", "quint_in_out"), ("sine-in", "sine_in"), ("sine-out", "sine_out"), ("sine-in-out", "sine_in_out"), ("circular-in", "circ_in"), ("circular-out", "circ_out"), ("circular-in-out", "circ_in_out"), ("exponential-in", "exp_in"), ("exponential-out", "exp_out"), ("exponential-in-out", "exp_in_out"), ("elastic-in", "elastic_in"), ("elastic-out", "elastic_out"), ("elastic-in-out", "elastic_in_out"), ("back-in", "back_in"), ("back-out", "back_out"), ("back-in-out", "back_in_out"), ("bounce-in", "bounce_in"), ("bounce-out", "bounce_out"), ("bounce-in-out", "bounce_in_out")}
// $vezer_curves := map{}

// @proc_def ::vezerxml2nim($xml, $nom) // extract keyframes from Vezer and convert to NIM
// {
// 	@local $tracks, $fps, $inc_nim := 0, $prec_time := 0, $time, $value, $typ  //, $result := [] //bug??

// 	$result := []
// 	$tracks := @extract($xml, "tracks")[2] // extract tracks
// 	$fps := @extract($xml, "fps")[2] // extract FPS

// 	// $nom := $nom

// 	forall $res in $tracks
// 	{
// 		$result.push_back($res.extract("keyframes"))
// 	}

// 	// print result (""+$result)
// 	if($tracks.size > 1) // si multichannel
// 	{
// 		$vezer_curves.add_pair($nom, [ <undef> | $array in $tracks.size ])
// 	}

// 	forall $keyframes in $result
// 	{
// 		if($tracks.size > 1) // si multichannel
// 		{
// 			forall $item in $keyframes[2]
// 			{
// 				$time := $item[2,0,2,0]/$fps
// 			 	$value := $item[2,1,2,0]
// 			 	$typ := $item[2,2,2,0]

				
// 				if ($vezer_curves($nom)[$inc_nim].is_undef)
// 			 	{ 			 		
// 			 		let $vezer_curves($nom)[$inc_nim] := NIM{ $time $value, 0 $value "linear"}
// 			 		// print ("====== "+$vezer_curves)

// 			 	}
// 			 	$vezer_curves($nom)[$inc_nim].push_back($time - $prec_time, $value, $interpol_types($typ))
// 				$prec_time := $time
// 				// print ($vezer_curves($nom))
// 			}
// 		}
// 		else
// 		{
// 			$vezer_curves.remove($nom)
			
// 			forall $item in $keyframes[2]
// 			{
// 				$time := $item[2,0,2,0]/$fps
// 			 	$value := $item[2,1,2,0]
// 			 	$typ := $item[2,2,2,0]

				
// 				if ($vezer_curves($nom).is_undef)
// 			 	{ 
// 			 		// $nim := NIM{ $time $value, 0 $value "linear"} 
// 			 		$vezer_curves.add_pair($nom, NIM{ $time $value, 0 $value "linear"} )
// 			 		// print ("====== "+$vezer_curves)

// 			 	}
// 			 	$vezer_curves($nom).push_back($time - $prec_time, $value, $interpol_types($typ))
// 				$prec_time := $time
// 				// print ($vezer_curves($nom))

// 			}
// 		}
// 		$inc_nim := $inc_nim + 1
// 		$prec_time := 0 // reset time pour chaque nim
// 	}
// }

// // Function @extract is used to extract the first tag with a given "name"

// @fun_def @extract($tab, $name)
// {
//      if ($tab.is_tab())
//      {
//          if ($tab[0] == $name)
// 	 { return $tab }
// 	 else
// 	 {
// 		if ($tab.size() == 3)
// 	 	{ return $tab[2].extract2(0, $name) }
// 	 	else
// 		{ return <undef> }
// 	 }
//      }
//      else
//      { return <undef> }
// }

// @fun_def @extract2($tab, $index, $name)
// {
//     if ($tab.is_tab() && $index < $tab.size() && $tab[$index].is_tab())
//     {
// 	if ($tab[$index, 0] == $name)
// 	{ return $tab[$index] }
// 	else
// 	{
// 		@local $ret := @extract2($tab[$index, 2], 0, $name)
// 		if ($ret.is_tab())
// 		{ return $ret }
// 		else
// 		{ return @extract2($tab, $index + 1, $name) }
// 	}
//     }
//     else
//     { return <undef> }
// }


// $xml_file := @xml_read($home + "/Documents/Doctorado/xml-vezer/2-tracks-xml-p1-1.xml")
// $xml_file1 := @xml_read($home + "/Documents/Doctorado/xml-vezer/1-track.xml")
// $xml_file5 := @xml_read($home + "/Documents/Doctorado/xml-vezer/5-tracks-xml.xml")

// $m := NIM{ 0 0, 50 0.7 "cubic", 20 0.3 "circ_out", 20 1 "sine", 20 0 "cubic_out"}
// $perc_rond :=  NIM{ 0 0, 10 1 "exp_out", 50 0.9, 100 0 "quint_out"}
// $perc :=  NIM{ 0 0, 10 1 "exp", 90 0 "exp_out"}
// $carre :=  NIM{ 0 0, 0.005 1 "cubic", 0.99 1, 0.005 0 "cubic_out"}


// @json_write($home + "/Documents/Doctorado/m2.json", @nim2vezer($m ))
// @json_write($home + "/Documents/Doctorado/perc_rond.json", @nim2vezer($perc_rond))
// @json_write($home + "/Documents/Doctorado/perc.json", @nim2vezer($perc))


// ::plotnim($m)
// ::plotnim($perc_rond)
// ::plotnim($perc)


// // agragate NIM

// @proc_def ::play_vezer_nim($cmd, $name)
// {
// 	@local $nim_play, $val, $curve_index := 0

// 	$nim_play := $vezer_curves($name)
// 	if($nim_play.is_tab)
// 	{
// 		$nim_play := @aggregate($nim_play)
// 			curve 
// 			@grain := 0.01, 
// 			@action  { 
// 				@command($cmd) $val 
// 				} 
// 			{ $val  : $nim_play }
// 	}
// 	else
// 	{
// 		curve 
// 		@grain := 0.01, 
// 		@action  { @command($cmd) $val } 
// 		{ $val : $nim_play }
// 	}

// }


// // Processus pour plotter nims dans SC
// @proc_def ::plot($nim_in)
// {
//   @local $t_nim
//   @set_osc_handling_tab(false)///SuperCollider
//   $t_nim := [ $nim_in($x) | $x in 0 .. @max_key($nim_in) : @max_key($nim_in)/1000 ] //40 elements !!narrive pas à 1
//   plot $t_nim 
//   // @set_osc_handling_tab(true)   
// }

// @proc_def ::plotnim($nim_in)
// {
//   @local $t_nim, $tab_nim, $max_nim_key_ant := 0, $max_nim_key := 0
//   @set_osc_handling_tab(true)///SuperCollider
//   // print (""+$nim_in)
//   $tab_nim := []
//   if($nim_in.is_tab)
//   {
//   	forall $nim_ind in $nim_in
//   	{
//   		$tab_nim.push_back([ $nim_ind($x) | $x in 0 .. @max_key($nim_ind) : @max_key($nim_ind)/(1000/$nim_ind.size) ]) //40 elements !!narrive pas à 1 /@max_key($nim_in)
//   		$max_nim_key := @max_key($nim_ind)
//   		if($max_nim_key > $max_nim_key_ant)
//   		{
//   			$max_nim_key_ant := $max_nim_key
//   		}else{
//   			$max_nim_key := $max_nim_key_ant
//   		}
//   		$max_nim_key_ant := @max_key($nim_ind)
//   	}
//   	plotnim $max_nim_key $tab_nim
//   }
//   else
//   {
// 	  $t_nim := [ $nim_in($x) | $x in 0 .. @max_key($nim_in) : @max_key($nim_in)/1000 ] //40 elements !!narrive pas à 1 /@max_key($nim_in)
// 	  plotnim @max_key($nim_in) $t_nim 
//   }
// }


//// Buffers



// @proc_def ::nim2buffer($nim_in, $server_name)
// {
// 	@local $t_nim, $t_inc := 0
// 	// @set_osc_handling_tab(true) ///SuperCollider

// 	if($nim_in.is_tab())
//   	{
//   		loop 0.2 // Utiliser whenever when bidirectional OSC will be available
//   		{
// 	  		$Servers($server_name).b_alloc($SC_Buffers_index, 1024) // $SC_Buffers_index variable globale de incrementation de buffers
// 			// synclocalhost 1
// 			// whenever when bidirectional OSC
// 			$t_nim := [ $nim_in[$t_inc]($x) | $x in 0 .. @max_key($nim_in[$t_inc]) : @max_key($nim_in[$t_inc])/1024 ] //1024 elements for SC buffers
// 			0.1 $Servers($server_name).b_setn($SC_Buffers_index, [0, 1024, $t_nim])
// 			$SC_Buffers_index += 1
// 			$t_inc += 1
//   		}until ($t_inc == $nim_in.size())
//   	}
//   	else
//   	{
// 		$Servers($server_name).b_alloc($SC_Buffers_index, 1024) // $SC_Buffers_index variable globale de incrementation de buffers
// 		// synclocalhost 1
// 		// whenever when bidirectional OSC
// 		$t_nim := [ $nim_in($x) | $x in 0 .. @max_key($nim_in) : @max_key($nim_in)/1024 ] //1024 elements for SC buffers
// 		0.1 $Servers($server_name).b_setn($SC_Buffers_index, [0, 1024, $t_nim])
// 		$SC_Buffers_index += 1
// 	}
// }


$path_HOA_hrir_christophe_lebedev50 := $home + "/Library/Application Support/SuperCollider/downloaded-quarks/SC-HOA/FIR/hrir/hrir_christophe_lebedev50/"
$path_HOA_hrir_ku100_lebedev50 := $home + "/Library/Application Support/SuperCollider/downloaded-quarks/SC-HOA/FIR/hrir/hrir_ku100_lebedev50/"
$path_HOA_hrir_pierre_lebedev50_diffuse := $home + "/Library/Application Support/SuperCollider/downloaded-quarks/SC-HOA/FIR/hrir/hrir_pierre_lebedev50_diffuse/"

@global $hrir_folder @persistent
@global $hrir_init_buf_map @persistent
if (@is_undef($hrir_folder)) { $hrir_folder := map{} }
if (@is_undef($hrir_init_buf_map)) { $hrir_init_buf_map := map{} }

@proc_def ::load_hrir($server_name)
{
	@local $buff_id

	$buff_id := $SC_Servers($server_name)("buffer_id")
	$hrir_folder.add_pair($server_name, map{}) // create a new map for store each sf in a server
	$hrir_init_buf_map.add_pair($server_name, map{}) // create a new map for store each sf in a server


	forall $k, $v in $hrir_dir
	{
		print key $k
		$hrir_folder($server_name).add_pair($k, map{})
		// $hrir_init_buf_map($server_name).add_pair($k, map{})

		if($v != ".DS_Store") // enleve ".DS_Store"
		{
			$hrir_init_buf_map($server_name).add_pair($k, $buff_id)
			// print (""+$v)
			forall $ke, $sf in $v
			{	
				if($sf != ".DS_Store") // enleve ".DS_Store"
				{
					// print folder $k soundFile ($path+$k+"/"+$sf)
					// print $server_name $buff_id ($path+$k+"/"+$sf)
					// scServer "/b_allocRead" $SC_Buffers_index ($path+$k+"/"+$sf)
					$Servers($server_name).b_allocRead($buff_id, ($path_hrir+$k+"/"+$sf))
					// b_allocReadserver2 $buff_id ($path+$k+"/"+$sf) // pour server2
					$hrir_folder($server_name)($k).add_pair($sf, $buff_id)
					// print $sf $buff_id
					$buff_id += 1
					$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le buff_id dans le dico des serveurs

				}
			}
		}
	}
}


$hrir_start_buffer := 0 // variable to store the start buffer for hrir convolution

@proc_def ::read_hrir_buffer_HOA($server_name, $path_dir) // read hrir audio files into buffers
{
	@local $HOA_buf_dir, $buff_id

	// $SC_Buffers_index := $buf_start_index
	// $hrir_start_buffer := $SC_Buffers_index
	$hrir_start_buffer := $SC_Servers($server_name)("buffer_id")
	$buff_id := $hrir_start_buffer

	print start hrir_buffer $server_name $hrir_start_buffer

	$HOA_buf_dir := @directory_read($path_dir, 2)

	forall $k, $v in $HOA_buf_dir
	{
		// print key $k
		if($v != ".DS_Store") // enleve ".DS_Store"
		{

			$Servers($server_name).b_allocRead($buff_id, $path_dir+$v)

			$buff_id += 1
			$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // load incremente le node_id dans le dico des serveurs

			// $SC_Buffers_index := $SC_Buffers_index + 1

		}
	}
	// @local $tab_inc := 0

	// 	whenever read_buffer_HOA ($buff_read_HOA_index == $buff_read_HOA_index)
	// 	{

	// 		$Servers($server_name).b_read($SC_Buffers_index, $path) // $SC_Buffers_index variable globale de incrementation de buffers
	// 		// synclocalhost 1
	// 		// whenever when bidirectional OSC
	// 		// $Servers($server_name).b_setn($SC_Buffers_index, [0, $num_frames, $t_nim])
	// 		// $envs.add_pair($tab_key[$tab_inc], $SC_Buffers_index) // associe l'index/env_key
	// 		print read_buffer_HOA buff $SC_Buffers_index
	// 		$SC_Buffers_index += 1
	// 		// $tab_inc += 1
	// 		// if ($tab_inc == $tab_key.size()) // abort whenever
	// 		// {
	// 		// 	abort read_buffer_HOA
	// 		// }
	// 	}
	// $buff_read_HOA_index := 1 // trig first whenever
}

@global $ir_map @persistent
@global $ir_buf @persistent
if (@is_undef($ir_map)) { $ir_map := map{} }
if (@is_undef($ir_buf)) { $ir_buf := map{} }


@proc_def ::read_multi_mono_IR($ir_name, $server_name, $path_dir) // read hrir audio files into buffers
{
	@local $IR_buf_dir, $IR_buf_init, $IR_buf_end, $buff_id

	// $IR_buf_init := $SC_Buffers_index
	$IR_buf_init := $SC_Servers($server_name)("buffer_id")
	$buff_id := $IR_buf_init

	$IR_buf_dir := @directory_read($path_dir, 2)

	forall $k, $v in $IR_buf_dir
	{
		// print key $k
		if($v != ".DS_Store") // enleve ".DS_Store"
		{
			print $v
			$Servers($server_name).b_allocRead($buff_id, $path_dir+$v)
			print $buff_id
			$buff_id += 1
			// print bff_ind ($IR_buf_dir.size()+$buff_id)
			// print bff_ind ($IR_buf_dir.size())
			$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs

			// $SC_Buffers_index += 1
			// if ($buff_id == $IR_buf_dir.size()+$buff_id)
			// {
			// 	print done
			// }

		}
	}
	
	// $IR_buf_end := $SC_Buffers_index
	$IR_buf_end := $SC_Servers($server_name)("buffer_id")

	$ir_map.add_pair($ir_name, [$IR_buf_init, $IR_buf_end-1])
	print $ir_name (""+$ir_map)
	// print done 
}


@obj_def read_multichanls_IR($ir_name, $server_name, $path_dir, $fftsize) // read hrir audio files into buffers
{

	@local $IR_buf_init, $IR_buf_end, $IR_multiBuf, $sync, $tab_inc := 0, $num_channels := 0, $buff_id, $proc_multi_ir, $init_trig := true, $load_trig1 := true, $load_trig2 := true

	@init
	{
	// $IR_multiBuf := $SC_Buffers_index
	$IR_multiBuf := $SC_Servers($server_name)("buffer_id")
	$buff_id := $IR_multiBuf

	// store ir buffers index
	if ($ir_map($server_name).is_undef()) // si ça existe
	{
		$ir_map.add_pair($server_name, map {})
	}

	// print ir_map_ir_map (""+$ir_map($server_name))
	

	// print IR_multiBuf $server_name $IR_multiBuf
	// print buff_id $server_name $buff_id

	$sync := (@rand_int(1000)+500) // sync rand ID

	$Servers($server_name).b_allocRead($IR_multiBuf, $path_dir) // load multichannel buf to extract number of channels
	$buff_id += 1
	$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
	$Servers($server_name).sync($sync) // sync with server

	// $SC_Buffers_index += 1 // increment buffer in SC server
	
	// $IR_buf_init := $SC_Buffers_index
	$IR_buf_init := $SC_Servers($server_name)("buffer_id")
	// print IR_buf_init $IR_buf_init

	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync) && $init_trig) // wait for server syc
	{
		$Servers($server_name).b_query($IR_multiBuf) // query buffer send $buf_info for whenever
		whenever (($buf_info[0] == $server_name) && ($buf_info[2] == $IR_multiBuf)) // wait for server syc
		{
			$num_channels := $buf_info[4] // element 3, number of channels
			// print num_channels $num_channels
			$THISOBJ.load_buff1($num_channels)
			$init_trig := false
			$Servers($server_name).sync($tab_inc) // send sync to server
		}
	}

	}
	@proc_def load_buff1($num_chl)
	{
		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $tab_inc) && $load_trig1) // wait for server syc
		{
		if($tab_inc <= $num_chl-1)
			{
				// print load__1 channel $buff_id of $ir_name in $server_name
				// print tab_inc_1 $tab_inc
				// print server_sync_1 ($server_sync[1])
															// $buf_id, $path, $startFrame, $numFrames, $channelIndex
				$Servers($server_name).b_allocReadChannel($buff_id, $path_dir, 0, 0, $tab_inc) // $SC_Buffers_index variable globale de incrementation de buffers
				// $SC_Buffers_index += 1
				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
				// $SC_Servers($server_name).add_pair("buffer_id", $SC_Servers($server_name)("buffer_id") + 1) // incremente le node_id dans le dico des serveurs

				$tab_inc += 1
				$Servers($server_name).sync($tab_inc) // send sync to server
			}
					else
					{
							// print load__2 channel $buff_id of $ir_name in $server_name
							// print tab_inc_2 $tab_inc
															// $IR_buf_end := $sc_buffers_index
							$load_trig1 := false								
							$IR_buf_end := $buff_id
							$ir_map($server_name).add_pair($ir_name, [$IR_buf_init, $IR_buf_end-1])
							// print map_ir $ir_name (""+$ir_map)
							$THISOBJ.calcNumPartitions($ir_name, $server_name, $fftsize) // calcul for Patitions Partconv $tab_inc -> last sync
							// abort loadMultichlIR	
							$Servers($server_name).b_free($IR_multiBuf) // libere le multi-buf après avoir extrait le nombre de channels
							// abort $proc_multi_ir //@norec
							// abort $THISOBJ

						
					}
				}
	}

	@proc_def calcNumPartitions($ir_name, $server_name, $fftsize)
	{
		@local $irbuffer_numFrames, $partitionsize, $tab_inc, $trig, $number_buff, $buff_id

		$buff_id := $SC_Servers($server_name)("buffer_id")
		$tab_inc := $ir_map($server_name)($ir_name)[0]
		// print tab_inc $tab_inc	
		// print ir_name (""+$ir_map($server_name)($ir_name))
		// print last_sync $last_sync

		$ir_map($server_name)($ir_name).push_back($buff_id) // add init bufnum
		// print IR_init__buf_ $buff_id

		// print ir_name_entero (""+$ir_map)

		$number_buff := $ir_map($server_name)($ir_name)[1] - $ir_map($server_name)($ir_name)[0]
		// print number_buff $number_buff

		// if ($ir_buf($server_name).is_undef())
		// {
		// 	$ir_buf.add_pair($server_name, map{})
		// }

		// $ir_buf($server_name).add_pair($ir_name, $buff_id) // plus facile de recuperer la valeur du buff
			whenever ($trig == $trig)
	{
		$Servers($server_name).b_query($tab_inc)
		$Servers($server_name).sync($trig)

		// print server_sync0 ($server_sync[0])
		// print server_sync1 ($server_sync[1])
		// print trig $trig
		// print server_sync3 $server_sync
	}


		// whenever ($server_sync == $trig) // wait for server buf_info
		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $trig) && $load_trig2) // wait for server syc
		{
			// print trig $trig
			// print number_buff $number_buff
			if ($trig <= $number_buff) // abort whenever
			{
				// print buf $tab_inc buf_frames ($buf_info[3])

				// print partitionsize (@partitionsize($fftsize, $buf_info[2]))

				// print ir_buf $tab_inc new_buf $buff_id size (@partitionsize($fftsize, $buf_info[3])) chanl 1

				$Servers($server_name).b_alloc($buff_id, @partitionsize($fftsize, $buf_info[3]), 1)				
				// let $ir_map($ir_name)[3] := $SC_Buffers_index // put last
				// $SC_Buffers_index += 1
				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs


				// server.listSendMsg(["/b_gen", bufnum, "PreparePartConv", buf.bufnum, fftsize]);
				$tab_inc += 1
				// print trig $trig
				$trig += 1
				// ~irspectrum = Buffer.alloc(s, bufsize, 1);
			}
			else
			{
				::load_partconv($ir_name, $server_name, $fftsize) //load fft_ir representation into buffers	
				$load_trig2 := false
				abort $THISOBJ
				// abort loadMultichlIR
				// abort $obj_ir
			}
		}	
	$trig := 0
	}
	@abort
	{
		print "abort" object read_multichanls_IR
		abort $THISOBJ		
	}
}

// @obj_def read_multichanls_IR($ir_name, $server_name, $path_dir, $fftsize) // read hrir audio files into buffers
// {

// 	@local $IR_buf_init, $IR_buf_end, $IR_multiBuf, $sync, $tab_inc := 0, $num_channels := 0, $buff_id, $proc_multi_ir

// 	@init
// 	{
// 	// $IR_multiBuf := $SC_Buffers_index
// 	$IR_multiBuf := $SC_Servers($server_name)("buffer_id")
// 	$buff_id := $IR_multiBuf

// 	// store ir buffers index
// 	if ($ir_map($server_name).is_undef()) // si ça existe
// 	{
// 		$ir_map.add_pair($server_name, map {})
// 	}

// 	print ir_map_ir_map (""+$ir_map($server_name))
	

// 	print IR_multiBuf $server_name $IR_multiBuf
// 	print buff_id $server_name $buff_id

// 	$sync := (@rand_int(1000)+500) // sync rand ID

// 	$Servers($server_name).b_allocRead($IR_multiBuf, $path_dir) // load multichannel buf to extract number of channels
// 	$buff_id += 1
// 	$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
// 	$Servers($server_name).sync($sync) // sync with server

// 	// $SC_Buffers_index += 1 // increment buffer in SC server
	
// 	// $IR_buf_init := $SC_Buffers_index
// 	$IR_buf_init := $SC_Servers($server_name)("buffer_id")
// 	print IR_buf_init $IR_buf_init
	
// 	$proc_multi_ir := {
// 		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
// 		{
// 			$Servers($server_name).b_query($IR_multiBuf) // query buffer send $buf_info for whenever

// 			// whenever ($buf_info[0] == $server_name) // wait for server syc
// 			whenever (($buf_info[0] == $server_name) && ($buf_info[2] == $IR_multiBuf)) // wait for server syc
// 			{
// 				// print buf_info_desde adentro ($buf_info[3]) 
// 				$num_channels := $buf_info[4] // element 3, number of channels
// 				$Servers($server_name).sync($tab_inc) // send sync to server

// 				whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $tab_inc)) // wait for server syc
// 				{
// 					print tab_inctab_inctab_inctab_inctab_inctab_inctab_inctab_inc $tab_inc
// 					print num_channelsnum_channelsnum_channelsnum_channelsnum_channels $num_channels
// 					if($tab_inc < $num_channels-1)
// 					{
// 						print load__1 channel $buff_id of $ir_name in $server_name
// 						print tab_inc_1 $tab_inc
// 						print server_sync_1 ($server_sync[1])
// 																	// $buf_id, $path, $startFrame, $numFrames, $channelIndex
// 						$Servers($server_name).b_allocReadChannel($buff_id, $path_dir, 0, 0, $tab_inc) // $SC_Buffers_index variable globale de incrementation de buffers
// 						// $SC_Buffers_index += 1
// 						$buff_id += 1
// 						$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
// 						// $SC_Servers($server_name).add_pair("buffer_id", $SC_Servers($server_name)("buffer_id") + 1) // incremente le node_id dans le dico des serveurs

// 						$tab_inc += 1
// 						$Servers($server_name).sync($tab_inc) // send sync to server
// 					}
// 					else
// 					{
// 						if($tab_inc == $num_channels-1) // load last buffer
// 						{
// 							print load__2 channel $buff_id of $ir_name in $server_name
// 							print tab_inc_2 $tab_inc
// 							// $buf_id, $path, $startFrame, $numFrames, $channelIndex
// 							$Servers($server_name).b_allocReadChannel($buff_id, $path_dir, 0, 0, $tab_inc) 
// 							$buff_id += 1
// 							$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
// 							// $SC_Servers($server_name).add_pair("buffer_id", $SC_Servers($server_name)("buffer_id") + 1) // incremente le node_id dans le dico des serveurs

// 															// $IR_buf_end := $SC_Buffers_index
// 							$IR_buf_end := $buff_id
// 							$ir_map($server_name).add_pair($ir_name, [$IR_buf_init, $IR_buf_end-1])
// 							print map_ir $ir_name (""+$ir_map)
// 							::calcNumPartitions($ir_name, $server_name, $fftsize, $THISOBJ) // calcul for Patitions Partconv $tab_inc -> last sync
// 							// abort loadMultichlIR	
// 							$Servers($server_name).b_free($IR_multiBuf) // libere le multi-buf après avoir extrait le nombre de channels
// 							// abort $proc_multi_ir //@norec
// 							// abort $THISOBJ

// 						}
// 						// else
// 						// {
// 						// 	if($tab_inc == $num_channels)
// 						// 	{
// 						// 		// $IR_buf_end := $SC_Buffers_index
// 						// 		$IR_buf_end := $buff_id
// 						// 		$ir_map($server_name).add_pair($ir_name, [$IR_buf_init, $IR_buf_end-1])
// 						// 		print map_ir $ir_name (""+$ir_map)
// 						// 		::calcNumPartitions($ir_name, $server_name, $fftsize, $THISOBJ) // calcul for Patitions Partconv
// 						// 		// abort loadMultichlIR	
// 						// 		$Servers($server_name).b_free($IR_multiBuf) // libere le multi-buf après avoir extrait le nombre de channels
// 						// 		// abort $proc_multi_ir @norec
// 						// 	abort $THISOBJ
// 						// 	}
// 						// }
// 					}
// 				}
// 			}
// 		}
// 	}
// 		// 0.1 $Servers($server_name).b_free($IR_multiBuf) // libere le multi-buf après avoir extrait le nombre de channels
// 	}
// 	@abort
// 	{
// 		print "abort" object read_multichanls_IR
// 		abort $THISOBJ		
// 	}
// }



@proc_def ::create_synthetic_IRs($ir_name, $server_name, $fftsize, $order)
{
	@local $IR_corp, $result := 0, $result_ir, $tab_init1, $tab_init2, $num_frames, $tab_inc := 0, $chnl_size_order, $buff_alloc, $IR_buf_init, $IR_buf_end, $buff_id, $proc_ir_synth

	$tab_init1 := [ ($i-1)*-1 | $i in 1 : 0.0007] // [ ($i-1)*-1 | $i in 1 : 0.0002]

	$chnl_size_order := ($order+1).pow(2)

	// $IR_buf_init := $SC_Buffers_index
	$IR_buf_init := $SC_Servers($server_name)("buffer_id")
	$buff_id := $IR_buf_init

	// store ir buffers index
	if ($ir_map($server_name).is_undef()) // si ça existe
	{
		$ir_map.add_pair($server_name, map {})
	}

	$proc_ir_synth := {	

	whenever load_ir ($buff_alloc == $buff_alloc)
		{
			$result_ir := [] // init
			$tab_init2 := [ 0 | $i in (30)] //init

			forall $x in $tab_init1 // creation de ir, chercher des méthodes plus adaptes, ici random
			{
				$result := @sqrt($x.sqrt())
				$result := ((@coin_compiled($result)) ? 0: $result.sqrt())
				$result := ((@coin_compiled(0.5)) ? @neg_compiled($result): $result)
				$result := $result * 0.1
				$result_ir.push_back($result)
				
			}
			$result_ir.push_front(1)
			
			$tab_init2  := $tab_init2.push_front(1)
			$result_ir := $tab_init2.concat($result_ir)
			$num_frames := $result_ir.size()
			$Servers($server_name).b_alloc($buff_id, $num_frames, 1) // $SC_Buffers_index variable globale de incrementation de buffers
			$Servers($server_name).sync($tab_inc)

				// whenever sync ($server_sync == $tab_inc) // wait for server syc
				whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $tab_inc)) // wait for server syc
				{
					// $Servers($server_name).b_setn($buff_id, [0, $num_frames, $result_ir]) // 0.01 del for wait to alloc
					$Servers($server_name).b_setn([$buff_id, 0, $num_frames, $result_ir].flatten()) // 0.01 del for wait to alloc

					// $IR_buf_end := $SC_Buffers_index
					$IR_buf_end := $buff_id

					// print  load_Ir in bufnum $SC_Buffers_index
					print  load_Ir in bufnum $buff_id
					print print2 $tab_inc
					print server_sync2 $server_sync

					// $SC_Buffers_index += 1
					$buff_id += 1
					$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs

					$tab_inc += 1
					if ($tab_inc == $chnl_size_order) // abort whenever
					{

						print IR_buf_init $IR_buf_init
						print IR_buf_end $IR_buf_end
						$ir_map($server_name).add_pair($ir_name, [$IR_buf_init, $IR_buf_end])	
						print ir_map (""+$ir_map)

						::calcNumPartitions($ir_name, $server_name, $fftsize, $tab_inc)  // calcul for Patitions Partconv

						plot $result_ir		
						abort $proc_ir_synth @norec
						// abort load_ir @norec
						// abort sync @norec
					}
					$buff_alloc := 1
					// print $tab_init2
					
					print size Synth_IR $num_frames
					$buff_alloc := 1
				}
			}
		}
	$buff_alloc := 1 // trig first whenever
	// $IR_buf_end := $SC_Buffers_index
	$IR_buf_end := $buff_id // $SC_Servers($server_name)("buffer_id")

}

// @proc_def ::calcNumPartitions($ir_name, $server_name, $fftsize, $last_sync)
// {	
// 	@local $irbuffer_numFrames, $partitionsize, $tab_inc, $trig, $number_buff, $buff_id, , $buff_alloc, $proc_when_part

// 	$proc_when_part := {
// 		whenever ($buff_alloc == $buff_alloc)
// 		{

// 			$Servers($server_name).b_alloc($buff_id, $num_frames, 1) // $buffer_id variable globale de incrementation de buffers
// 			$Servers($server_name).sync($tab_inc)
// 			// print alloc buff $buffer_id
// 			// synclocalhost 1
// 			// whenever when bidirectional OSC
// 			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $tab_inc)) // wait for server syc $server_sync = $server_name sync_index
// 			{
// 				print syc $server_sync
// 				$t_nim := [ $current_nim($x) | $x in 0 .. @max_key($current_nim) : @max_key($current_nim)/$num_frames ] //1000 elements for SC buffers
// 				$Servers($server_name).b_setn($buff_id, [0, $num_frames, $t_nim]) // 0.01 del for wait to alloc
// 				$envs.add_pair($tab_key[$tab_inc], $buff_id) // associe l'index/env_key

// 				// $SC_Buffers_index += 1
// 				$buff_id += 1
// 				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs

// 				$tab_inc += 1		
// 				if ($tab_inc == $tab_key.size()) // abort whenevers
// 				{
// 					abort $proc_when_envs
// 					// abort load_envs
// 					// abort sync
// 				}
// 				$buff_alloc := 1
// 			}
// 		}
// 	}
// 	$buff_alloc := 1 // trig first whenever



@proc_def ::calcNumPartitions($ir_name, $server_name, $fftsize, $tab_inc_ext)
{	
	@local $irbuffer_numFrames, $partitionsize, $tab_inc, $trig := $tab_inc_ext+1, $number_buff, $buff_id

	whenever ($server_sync)
	{
		print server_sync_server_sync_3 $server_sync
	}

	// loop 1
	// {
	// 	print toto
	// }
	$buff_id := $SC_Servers($server_name)("buffer_id")
	$tab_inc := $ir_map($server_name)($ir_name)[0]
	print tab_inc $tab_inc	
	print ir_name (""+$ir_map($server_name)($ir_name))
	// print last_sync $last_sync

	$ir_map($server_name)($ir_name).push_back($buff_id) // add init bufnum
	print IR_init__buf_ $buff_id

	print ir_name_entero (""+$ir_map)

	$number_buff := $ir_map($server_name)($ir_name)[1] - $ir_map($server_name)($ir_name)[0]
	print number_buff $number_buff

	if ($ir_buf($server_name).is_undef())
	{
		$ir_buf.add_pair($server_name, map{})
	}

	$ir_buf($server_name).add_pair($ir_name, $buff_id) // plus facile de recuperer la valeur du buff
	// $ir_map($ir_name).push_back(0) // prepare last bufnum

	// $Servers($server_name).b_query($tab_inc)
	// $Servers($server_name).sync($trig)



	// whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $last_sync)) // waiting for last sync
	// {
	// 	print trigger proc_ir_load
	// 	$trig := 0
	// }

		

	whenever ($trig == $trig)
	{
		print trigtrigtrigtrigtrigtrigtrigtrigtrigtrig
		// print server ($Servers($server_name))
		$Servers($server_name).b_query($tab_inc)
		$Servers($server_name).sync($trig)

		print server_sync0 ($server_sync[0])
		print server_sync1 ($server_sync[1])
		print trig $trig
		// print server_sync3 $server_sync
	}


		// whenever ($server_sync == $trig) // wait for server buf_info
		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $trig)) // wait for server syc
		{
			print trig $trig
			print number_buff $number_buff
			if ($trig <= $number_buff) // abort whenever
			{
				print buf $tab_inc buf_frames ($buf_info[3])

				// print partitionsize (@partitionsize($fftsize, $buf_info[2]))

				print ir_buf $tab_inc new_buf $buff_id size (@partitionsize($fftsize, $buf_info[3])) chanl 1

				$Servers($server_name).b_alloc($buff_id, @partitionsize($fftsize, $buf_info[3]), 1)				
				// let $ir_map($ir_name)[3] := $SC_Buffers_index // put last
				// $SC_Buffers_index += 1
				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs


				// server.listSendMsg(["/b_gen", bufnum, "PreparePartConv", buf.bufnum, fftsize]);
				$tab_inc += 1
				print trig $trig
				$trig += 1
				// ~irspectrum = Buffer.alloc(s, bufsize, 1);
			}
			else
			{
				::load_partconv($ir_name, $server_name, $fftsize) //load fft_ir representation into buffers	
				// abort loadMultichlIR
				// abort $obj_ir
			}
		}	
		// if ($trig > $number_buff) // abort whenever
		// {
		// 	::load_partconv($ir_name, $server_name, $fftsize) //load fft_ir representation into buffers	
		// 	abort loadMultichlIR
		// 	// abort $read_obj
		// }	
	
	// print trigger proc_ir_load
	$trig := 0
	// 0.1 $Servers($server_name).sync($last_sync+1)
}

@proc_def ::load_partconv($ir_name, $server_name, $fftsize)
{
	@local $number_buff, $tab_inc, $buff_id, $init_buff

	
	$buff_id := $SC_Servers($server_name)("buffer_id")
	print ir_map_load_partconv (""+$ir_map($server_name))
	$number_buff := $ir_map($server_name)($ir_name)[1] - $ir_map($server_name)($ir_name)[0]
	$init_buff := $ir_map($server_name)($ir_name)[2]
	$tab_inc := $ir_map($server_name)($ir_name)[0]

	if ($ir_buf($server_name).is_undef())
	{
		$ir_buf.add_pair($server_name, map{})
	}

	$ir_buf($server_name).add_pair($ir_name, $init_buff) // plus facile de recuperer la valeur du buff

	
	forall $x in $number_buff+1
	{
		$Servers($server_name).b_gen($x+$init_buff, "PreparePartConv", $x+$tab_inc, $fftsize) //$SC_Buffers_index -> b_alloc, "PreparePartConv", $tab_inc -> IR buff, fftsize
		print b_gen ($x+$init_buff) "PreparePartConv" ($x+$tab_inc) $fftsize
		
		$Servers($server_name).b_free($x+$tab_inc) // libere le buf après avoir extrait le nombre de channels 
		// $init_buff += 1
		// $SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
	}

}
			// $Servers($server_name).sync($tab_inc)
			// // print alloc buff $SC_Buffers_index
			// // synclocalhost 1
			// // whenever when bidirectional OSC
			// whenever sync ($server_sync == $tab_inc) // wait for server syc
			// {
			// 	print syc $server_sync

// @proc_def ::load_samples($server_name)
// {
// 	forall $k, $v in $SF_dir
// 	{
// 		// print key $k
// 		if($v != ".DS_Store") // enleve ".DS_Store"
// 		{
// 			// print (""+$v)
// 			$SF_folder.add_pair($k, [])
// 			forall $ke, $sf in $v
// 			{	
// 				if($sf != ".DS_Store") // enleve ".DS_Store"
// 				{
// 					print folder $k soundFile ($path+$k+"/"+$sf)
// 					// scServer "/b_allocRead" $SC_Buffers_index ($path+$k+"/"+$sf)
// 					$Servers($server_name).b_allocRead($SC_Buffers_index, ($path+$k+"/"+$sf))
// 					// b_allocReadserver2 $SC_Buffers_index ($path+$k+"/"+$sf) // pour server2
// 					$SF_map.add_pair($sf, $SC_Buffers_index)
// 					$SC_Buffers_index := $SC_Buffers_index + 1
// 					$SF_folder($k).push_back($sf)
// 				}
// 			}
// 		}
// 	}
// }




@proc_def ::envs_nim_map2buffer($server_name, $map_nim) // for map of nim into buffer
{
	@local $t_nim, $tab_key, $tab_inc := 0, $current_nim, $num_frames := 1024, $buff_alloc, $buff_id, $proc_when_envs

	$tab_key := $map_nim.domain()
	$buff_id := $SC_Servers($server_name)("buffer_id")
	$envs.add_pair($server_name, map{})
	
	$proc_when_envs := {
		whenever ($buff_alloc == $buff_alloc)
		{
			$current_nim := $map_nim($tab_key[$tab_inc])

			$Servers($server_name).b_alloc($buff_id, $num_frames, 1) // $buffer_id variable globale de incrementation de buffers
			$Servers($server_name).sync($tab_inc)
			// print alloc buff $buffer_id
			// synclocalhost 1
			// whenever when bidirectional OSC
			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $tab_inc)) // wait for server syc $server_sync = $server_name sync_index
			{
				print syc $server_sync
				$t_nim := [ $current_nim($x) | $x in 0 .. @max_key($current_nim) : @max_key($current_nim)/$num_frames ] //1000 elements for SC buffers
				// $Servers($server_name).b_setn($buff_id, [0, $num_frames, $t_nim]) // 0.01 del for wait to alloc
				$Servers($server_name).b_setn([$buff_id, 0, $num_frames, $t_nim].flatten()) // 0.01 del for wait to alloc

				$envs($server_name).add_pair($tab_key[$tab_inc], $buff_id) // associe l'index/env_key

				// $SC_Buffers_index += 1
				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs

				$tab_inc += 1		
				if ($tab_inc == $tab_key.size()) // abort whenevers
				{
					abort $proc_when_envs
					// abort load_envs
					// abort sync
				}
				$buff_alloc := 1
			}
		}
	}
	$buff_alloc := 1 // trig first whenever
}

// Envs

$envs_map := map{ 
	("pointe", NIM{ 0 0, 0.5 1 "exp", 0.5 0 "exp_out"}), 
	("rond", NIM{ 0 0, 0.5 1 "cubic_out", 0.5 0 "cubic"}), 
	("baleine", NIM{ 0 0, 0.2 1 "cubic_out", 0.8 0 "cubic"}), 
	("baleine_inv", NIM{ 0 0, 0.8 1 "cubic_out", 0.2 0 "cubic"}), 
	("perc", NIM{ 0 0, 0.1 1 "exp", 0.9 0 "exp_out"}),
	("perc_acc", NIM{ 0 0, 0.02 1 "exp", 0.9 0 "circ_out"}),
	("perc_sust", NIM{ 0 0, 0.01 1 "exp", 0.9 0 "sine_in"}),
	("perc_rel", NIM{ 0 0, 0.01 1 "exp", 0.1 0.7, 0.6 0.7, 0.29 0 "sine_out"}),
	("perc_s", NIM{ 0 0, 0.01 1 "exp", 0.9 0 "quart_in_out"}),
	("perc_rond", NIM{ 0 0, 0.1 1 "exp_out", 0.5 0.9, 1 0 "quint_out"}),
	("perc_elastic", NIM{ 0 0, 0.5 1 "elastic_out", 0.5 0 "sine_in"}),
	("inv", NIM{ 0 0, 0.9 1 "exp", 0.1 0 "sine"}),
	("m", NIM{ 0 0, 0.5 1 "circ", 0.2 0.5 "circ", 0.2 0.9 "sine", 0.5 0 "cubic_out"}),
	("m2", NIM{ 0 0, 0.5 0.7 "cubic", 0.2 0.3 "circ_out", 0.2 1 "sine", 0.2 0 "cubic_out"}),
	("m_carre", NIM{ 0 0, 0.005 1 "cubic", 0.295 1, 0.2 0, 0.2 1, 0.295 1, 0.005 0 "cubic_out"}),	
	("u", NIM{ 0 0, 0.02 1 "cubic", 0.48 0.3 "circ_out", 0.48 1 "exp", 0.02 0 "cubic_out"}),
	("carre", NIM{ 0 0, 0.005 1 "cubic", 0.99 1, 0.005 0 "cubic_out"}),
	("carre2", NIM{ 0 0, 0.005 1 "cubic", 0.99 1, 0.1 0 "cubic"}),
	("carre3", NIM{ 0 0, 0.05 1, 0.99 1, 0.05 0}),
	("bounce", NIM{ 0 0, 0.5 1 "bounce", 0.5 0 "bounce_out"}),
	("bounce2", NIM{ 0 0, 0.5 1 "bounce_out", 0.5 0 "bounce_out"}),
	("bounce2_inv", NIM{ 0 0, 0.5 1 "bounce_in", 0.5 0 "bounce_in"}),
	("elastic", NIM{ 0 0, 0.5 1 "elastic_out", 0.5 0 "elastic_in"})
}

::plotnim($envs_map("elastic"))

@global $gran_buf @persistent
@global $gran_buf_inc @persistent
if (@is_undef($gran_buf)) { $gran_buf := map{} }
if (@is_undef($gran_buf_inc)) { $gran_buf_inc := map{} }


@proc_def ::gran_alloc_buffer($server_name, $num_of_buff, $dur_in_sec) // for map of nim into buffer
{
	@local $b_inc := 0, $buff_alloc, $buff_id, $proc_when_envs

	$buff_id := $SC_Servers($server_name)("buffer_id")
	$gran_buf.add_pair($server_name, [$buff_id, 0]) // created dico with start and end buf_num (-1 compense le +1 de @buff_gran)

	$proc_when_envs := {
		whenever ($buff_alloc == $buff_alloc)
		{
			$Servers($server_name).b_alloc($buff_id, $sampling_rate*$dur_in_sec, 1) // $buffer_id variable globale de incrementation de buffers
			$Servers($server_name).sync($b_inc)

			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $b_inc)) // wait for server syc $server_sync = $server_name sync_index
			{
				print syc $server_sync buf_id $buff_id

				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs

				$b_inc += 1		
				if ($b_inc == $num_of_buff) // abort whenevers
				{
					let $gran_buf($server_name)[1] := $buff_id-1 // add last buf_num
					$gran_buf_inc.add_pair($server_name, $gran_buf($server_name)[0]) // initialise $gran_buf_inc with start buf

					print buff_start_end $server_name (""+$gran_buf($server_name))
					abort $proc_when_envs
				}
				$buff_alloc := 1
			}
		}
	}
	$buff_alloc := 1 // trig first whenever
}

@global $fft_buf @persistent
@global $fft_buf_inc @persistent
if (@is_undef($fft_buf)) { $fft_buf := map{} }
if (@is_undef($fft_buf_inc)) { $fft_buf_inc := map{} }

@proc_def ::gran_alloc_buffer_fft($server_name, $num_of_buff, $buf_size) // for map of nim into buffer
{
	@local $b_inc := 0, $buff_alloc, $buff_id, $proc_when_envs

	$buff_id := $SC_Servers($server_name)("buffer_id")
	$fft_buf.add_pair($server_name, [$buff_id, 0]) // created dico with start and end buf_num (-1 compense le +1 de @buff_gran)

	$proc_when_envs := {
		whenever ($buff_alloc == $buff_alloc)
		{
			$Servers($server_name).b_alloc($buff_id, $buf_size, 1) // $buffer_id variable globale de incrementation de buffers
			$Servers($server_name).sync($b_inc)

			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $b_inc)) // wait for server syc $server_sync = $server_name sync_index
			{
				print syc $server_sync buf_id $buff_id

				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs

				$b_inc += 1		
				if ($b_inc == $num_of_buff) // abort whenevers
				{
					let $fft_buf($server_name)[1] := $buff_id-1 // add last buf_num
					$fft_buf_inc.add_pair($server_name, $fft_buf($server_name)[0]) // initialise $fft_buf_inc with start buf

					print buff_start_end $server_name (""+$fft_buf($server_name))
					abort $proc_when_envs
				}
				$buff_alloc := 1
			}
		}
	}
	$buff_alloc := 1 // trig first whenever
}

@fun_def buff_gran($server_name)
{
	// @local $inc := 0
    $dummy := EXPR { 
	if($gran_buf_inc($server_name) == $gran_buf($server_name)[1]) {
		$gran_buf_inc.add_pair($server_name, $gran_buf($server_name)[0])
		}
		else
		{
			$gran_buf_inc.add_pair($server_name, $gran_buf_inc($server_name) + 1) 
		}
    }
    return $gran_buf_inc($server_name)
}


@fun_def buff_fft($server_name)
{
	// @local $inc := 0
    $dummy := EXPR { 
	if($fft_buf_inc($server_name) == $fft_buf($server_name)[1]) {
		$fft_buf_inc.add_pair($server_name, $fft_buf($server_name)[0])
		}
		else
		{
			$fft_buf_inc.add_pair($server_name, $fft_buf_inc($server_name) + 1) 
		}
    }
    return $fft_buf_inc($server_name)
}


@global $buff_map @persistent
if (@is_undef($buff_map)) { $buff_map := map{} }


@proc_def ::loadcollection($server_name, $buf_name, $tab_collection, $sync_inc = 0) // load table into buffer
{ 
	@local $tableSize, $nim_min_key, $nim_max_key, $interval, $t_nim, $tab_key, $tab_inc := 0, $current_nim, $buff_alloc, $buff_id, $proc_when_envs, $tab_index := 0, $waveTable := [], $max_osc_size := 1628, $osc_tab_size, $slice_size, $map_list_buff, $counter_map := 0

	$buff_id := $SC_Servers($server_name)("buffer_id") // new buffer id	

	$tableSize := $tab_collection.size() 

	if ($buff_map($server_name).is_undef())
	{
		$buff_map.add_pair($server_name, map{})
	}

	$buff_map($server_name).add_pair($buf_name, $buff_id) // plus facile de recuperer la valeur du buff


	print sc_buffer_size $tableSize
	print buff_id $buff_id

	$proc_when_envs := {
		whenever ($buff_alloc == $buff_alloc)
		{
			$Servers($server_name).b_alloc($buff_id, $tableSize, 1) // $buffer_id variable globale de incrementation de buffers
			$Servers($server_name).sync($sync_inc) // wait for sc server sync
			// print alloc buff $buffer_id
			// whenever when bidirectional OSC
			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc $server_sync = $server_name sync_index
			{
				$osc_tab_size := $tableSize	

				$slice_size := $osc_tab_size/$max_osc_size // $max_osc_size == 1628 max elements in antescofo OSC 
				$slice_size := @floor($slice_size) // convert to int segments
				$map_list_buff := [$x*$max_osc_size | $x in $slice_size+1]		
				$map_list_buff.push_back($osc_tab_size-($slice_size*$max_osc_size)+$map_list_buff.last())

				loop 0 // send list of splited list to fill buffers (à cause de la limite de 1628 elements par OSC de antescofo)
				{
					@local $tab_cut

					$tab_cut := @slice($tab_collection, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1])
					print tab_cut (""+$tab_cut)
					$Servers($server_name).b_setn([$buff_id, $map_list_buff[$counter_map], $tab_cut.size(), $tab_cut].flatten()) // 0.01 del for wait to alloc
					$counter_map += 1

				}until ($counter_map == $map_list_buff.size()-1)

				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
				
				abort $proc_when_envs // abort pour arreter les whenevers
			}
		}
	}
	$buff_alloc := 1 // trig first whenever
}

@global $wavetable @persistent
if (@is_undef($wavetable)) { $wavetable := map{} }

@proc_def ::asWavetable($server_name, $wave_map_name, $map_nim, $num_frames, $sync_inc = 0) // For wavetable synthesis 
{ 
	@local $tableSize, $nim_min_key, $nim_max_key, $interval, $t_nim, $tab_key, $tab_inc := 0, $current_nim, $buff_alloc, $buff_id, $proc_when_envs, $tab_index := 0, $waveTable := [], $max_osc_size := 1628, $osc_tab_size, $slice_size, $map_list_buff, $counter_map := 0

	print asWavetable $sync_inc
	// $tab_key := $map_nim.domain()
	$buff_id := $SC_Servers($server_name)("buffer_id") // new buffer id
	// $tab_inc := @rand_range_int_compiled(100, 200) 
	$nim_min_key := @min_key($map_nim)
	$nim_max_key := @max_key($map_nim)
	$interval := $nim_max_key - $nim_min_key	

	$tableSize := $num_frames*2 // for SC server wavetable interpolation num_frames*2 

	print sc_buffer_size $tableSize

	$proc_when_envs := {
		whenever ($buff_alloc == $buff_alloc)
		{
			$Servers($server_name).b_alloc($buff_id, $tableSize, 1) // $buffer_id variable globale de incrementation de buffers
			$Servers($server_name).sync($sync_inc) // wait for sc server sync
			// print alloc buff $buffer_id
			// whenever when bidirectional OSC
			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc $server_sync = $server_name sync_index
			{
				$t_nim := [ $map_nim($nim_min_key + $interval * ($x / ($num_frames - 1))) | $x in ($num_frames) ] // convert nim to tab	

				forall $val in ($t_nim.size()-1) // construction tab pour wavetable synthesis
				{	
					@local $next
					$next := $t_nim[$val+1]
					$waveTable.push_back(2*$t_nim[$val] - $next)
					$waveTable.push_back($next-$t_nim[$val])
				}
				
				$waveTable.push_back(2*$t_nim[$t_nim.size()-1] - $t_nim[0])	// add 2 more elements for wavetable interpolation	
				$waveTable.push_back($t_nim[0] - $t_nim[$t_nim.size()-1])

				// print waveTable (""+$waveTable)

				$osc_tab_size := $waveTable.size()	
				// print waveTable_size $osc_tab_size
				$slice_size := $osc_tab_size/$max_osc_size // $max_osc_size == 1628 max elements in antescofo OSC 
				$slice_size := @floor($slice_size) // convert to int segments
				$map_list_buff := [$x*$max_osc_size | $x in $slice_size+1]		
				$map_list_buff.push_back($osc_tab_size-($slice_size*$max_osc_size)+$map_list_buff.last())

				loop 0 // send list of splited list to fill buffers (à cause de la limite de 1628 elements par OSC de antescofo)
				{
					@local $tab_cut

					$tab_cut := @slice($waveTable, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1])
					$Servers($server_name).b_setn([$buff_id, $map_list_buff[$counter_map], $tab_cut.size(), $tab_cut].flatten()) // 0.01 del for wait to alloc
					$counter_map += 1

				}until ($counter_map == $map_list_buff.size()-1)

				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
				
				abort $proc_when_envs // abort pour arreter les whenevers
			}
		}
	}
	$buff_alloc := 1 // trig first whenever
}

// $nim_test1 := NIM{ 0 0, 0.5 1 "exp", 0.5 0 "exp_out"}

// ::asWavetable("localhost", "waveshper1", $nim_test1, 1024)

// $nim_cons1 := NIM {0, 0 0 0 }

// $nim_cons1.push_back(0.1, 0.5, "exp")
// $nim_cons1.push_back(0.2, 0.2, "exp_out")
// $nim_cons1.push_back(0.5, 1.2, "exp_out")

// print (""+$nim_cons1)	
// ::plotnim($nim_cons1)
// ::plotnim($nim_test1)

$wavetables := map{}

@proc_def ::create_wavetables($server_name, $wave_map_name, $num_buffers, $num_frames) // For wavetable synthesis 
{ 
	@local $buff_id, $sync_server := 0

	$buff_id := $SC_Servers($server_name)("buffer_id") // start buf id
	print buff_id_init $buff_id

	$wavetable.add_pair($server_name, map{})

	$wavetable($server_name).add_pair($wave_map_name, [$buff_id, $num_buffers])
	$wavetables.add_pair($wave_map_name, map{})
	// ::asWavetable($server_name, $wave_map_name, $to_nim, $num_frames, sync_inc = $sync_server) // create wavetable from nim
	$Servers($server_name).sync(111)

	// whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 111)) // wait for server syc $server_sync = $server_name sync_index
	// {
		loop 0.05
		{
		// forall $x in $num_buffers // create num_buffers buffers
		// {	
			@local $numSegs, $curve_interpol, $val_list := [], $dur_list := [], $distrib, $list_segmente := [], $to_nim

			$numSegs := @linexp_compiled($sync_server,0,9,4,40).round() //random number of envelope segments
			$curve_interpol := [ @choose($interpol_types.range()) | ($numSegs) ] // chooses random curves types
			$distrib := @rnd_exponential(@linexp_compiled($sync_server,0,9,1,50))
			$val_list := [ @choose(@rand(1) * [1,-1]) | ($numSegs-1)] 
			$dur_list := [ $distrib() | ($numSegs) ]
			$list_segmente := @cons(0, @lace([$dur_list, $curve_interpol, $val_list], ($numSegs*3))) // add 0 and lace list

			// Create tab for nim
			$list_segmente.push_back($dur_list.last())
			$list_segmente.push_back(0)
			$list_segmente.push_back($curve_interpol.last())

			$to_nim := @build_nim_from_bpf($list_segmente) // convert tab2 nim [v0, t0, (type0), v1, t1, (type1), v2, t2, (type2)....]

			$wavetables($wave_map_name).add_pair($sync_server, $to_nim)
			// whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_server)) // wait for server syc $server_sync = $server_name sync_index
			// {
			// 	print synced 
			// }

			// 	print synced $server_sync
			::asWavetable($server_name, $wave_map_name, $to_nim, $num_frames, sync_inc = $sync_server) // create wavetable from nim

			$sync_server += 1
			// print lace_list (""+$list_segmente)
			// print to_nim (""+$to_nim)
			// ::plotnim($to_nim)
			// print val_list (""+$val_list)
			// print dur_list (""+$dur_list)
			// print $numSegs			
		}until($sync_server == $num_buffers)
}



// ::asWavetable("localhost", "toto", $wavetables("wavetables_1")(10), 1024) // create wavetable from nim


// $distrib := @rnd_exponential(@linexp_compiled(1,0,9,1,50))
// $list_dist := [ $distrib() | (10)]
// {exprand(1,1.linexp(0,9,1,50))}.dup(10)
// print (""+@choose($interpol_types.range()))
// print (@choose(@rand(1) * [1,-1]))
// print (@scramble([ @rand(1) | ($numSegs-1)] * [1,-1]))
// print ($distrib())
// print ($list_dist)
// print (@round(@linexp_compiled($x,0,9,1,40))
// print (@linexp_compiled(0,0,9,4,40).round())
@global $wavetableNoWrap @persistent
if (@is_undef($wavetableNoWrap)) { $wavetableNoWrap := map{} }


@proc_def ::asWavetableNoWrap($server_name, $wave_map_name, $map_nim, $num_frames, $sync_inc = 0) // For wave shaper 
{ 
	@local $tableSize, $nim_min_key, $nim_max_key, $interval, $proc_when_envs, $cur, $t_nim, $tab_key, $tab_inc := 0, $current_nim, $buff_alloc, $buff_id, $tab_index := 0, $waveTable := [], $max_osc_size := 1628, $osc_tab_size, $slice_size, $map_list_buff, $counter_map := 0

	print asWavetableNoWrap
	// $tab_key := $map_nim.domain()
	$buff_id := $SC_Servers($server_name)("buffer_id")
	$nim_min_key := @min_key($map_nim)
	$nim_max_key := @max_key($map_nim)
	$interval := $nim_max_key - $nim_min_key

	$tableSize := ($num_frames-1)*2 //($num_frames-1)*2 ex: 1025, 2049

	$proc_when_envs := {
		whenever ($buff_alloc == $buff_alloc)
		{
			print asWavetableNoWrap2
			// $current_nim := $map_nim($tab_key[$tab_inc])
			$current_nim := $map_nim

			$Servers($server_name).b_alloc($buff_id, $tableSize, 1) // $buffer_id variable globale de incrementation de buffers
			$Servers($server_name).sync($sync_inc)
			// print alloc buff $buffer_id
			// synclocalhost 1
			// whenever when bidirectional OSC
			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc $server_sync = $server_name sync_index
			{
				print syc $server_sync

				// $t_nim := [ $current_nim($x) | $x in 0 .. @max_key($current_nim) : @max_key($current_nim)/$num_frames ] // convert nim to tab
				$t_nim := [ $map_nim($nim_min_key + $interval * ($x / ($num_frames - 1))) | $x in ($num_frames) ] // convert nim to tab	


				// $cur := $t_nim[0]

				// print t_nim (""+$t_nim)
				forall $val in ($t_nim.size()-1) // construction wavetable NoWrap pour wave shaper synthesis
				{	
					@local $next
					$next := $t_nim[$val+1]
					// $next := $t_nim[$tab_index+1]
					$waveTable.push_back(2*$t_nim[$val] - $next)
					$waveTable.push_back($next-$t_nim[$val])
				}
				// print waveTable (""+$waveTable)
				$osc_tab_size := $waveTable.size()	
				// print waveTable_size $osc_tab_size
				$slice_size := $osc_tab_size/$max_osc_size // $max_osc_size == 1628 max elements in antescofo OSC 
				$slice_size := @floor($slice_size) // convert to int segments
				$map_list_buff := [$x*$max_osc_size | $x in $slice_size+1]		
				$map_list_buff.push_back($osc_tab_size-($slice_size*$max_osc_size)+$map_list_buff.last())
				// print map_list_buff $map_list_buff

				loop 0
				{
					@local $tab_cut

					$tab_cut := @slice($waveTable, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1])
					$Servers($server_name).b_setn([$buff_id, $map_list_buff[$counter_map], $tab_cut.size(), $tab_cut].flatten()) // 0.01 del for wait to alloc
					$counter_map += 1

					// @local $tab_cut
					// $tab_cut := @slice($waveTable, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1])
					// print send_of ($map_list_buff[$counter_map]) ($map_list_buff[$counter_map+1])
					// print toto @slice($test_tab, $x*1024, $x*1024+1024)
					// $test_tab_map.push_back(@slice($test_tab, $x*20, $x*20+20))
					// print ($map_list_buff[$counter_map]) ($map_list_buff[$counter_map+1]) $map_list_buff[(@slice($out_pos_final, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1]))
					// print of_concat3D ($map_list_buff[$counter_map]) ($tab_cut.size()) (""+@slice($tab_cut))

					// @set_osc_handling_tab(0)
					// $Servers($server_name).b_setn($buff_id, [$map_list_buff[$counter_map], $tab_cut.size(), $tab_cut]) // 0.01 del for wait to alloc
					// $Servers($server_name).b_setn([$buff_id, $map_list_buff[$counter_map], $tab_cut.size(), $tab_cut].flatten()) // 0.01 del for wait to alloc
					// print b_setn (""+[$buff_id, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1], $waveTable, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1]]) // 0.01 del for wait to alloc
					// $wavetableNoWrap($server_name).add_pair($tab_key[$tab_inc], $buff_id) // associe l'index/env_key
					// $counter_map += 1
				}until ($counter_map == $map_list_buff.size()-1)

				print buff_id $buff_id

			// of_concat_list_num $slice_size // send to of num segments
			// of_concat_list_num $osc_tab_size $max_osc_size // send to of tab_size + num segments

				// $Servers($server_name).b_setn($buff_id, [0, $num_frames, $t_nim]) // 0.01 del for wait to alloc
				// $envs($server_name).add_pair($tab_key[$tab_inc], $buff_id) // associe l'index/env_key

				// // $SC_Buffers_index += 1
				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
				abort $proc_when_envs // abort pour arreter les whenevers

			}
		}
	}
	$buff_alloc := 1 // trig first whenever
}

@global $WavetableNoWrapTab @persistent
if (@is_undef($WavetableNoWrapTab)) { $WavetableNoWrapTab := map{} }


@proc_def ::asWavetableNoWrapTab($server_name, $wavetable_name, $tab_table, $sync_inc = 0) // For wave shaper 
{ 
	@local $tableSize, $nim_min_key, $nim_max_key, $interval, $proc_when_envs, $cur, $t_nim, $tab_key, $tab_inc := 0, $current_nim, $buff_alloc, $buff_id, $tab_index := 0, $waveTable := [], $max_osc_size := 1628, $osc_tab_size, $slice_size, $map_list_buff, $counter_map := 0

	print asWavetableNoWrap_from_tab
	// $tab_key := $map_nim.domain()
	$buff_id := $SC_Servers($server_name)("buffer_id")
	$WavetableNoWrapTab.add_pair($wavetable_name, $buff_id) // store buffer ID in dictionary
	// $wavetable_name := $buff_id

	$tableSize := ($tab_table.size()-1)*2 //($num_frames-1)*2 ex: 1025, 2049

	$proc_when_envs := {
		whenever ($buff_alloc == $buff_alloc)
		{
			print asWavetableNoWrap2
			// $current_nim := $map_nim($tab_key[$tab_inc])
			// $current_nim := $map_nim

			$Servers($server_name).b_alloc($buff_id, $tableSize, 1) // $buffer_id variable globale de incrementation de buffers
			$Servers($server_name).sync($sync_inc)
			// print alloc buff $buffer_id
			// synclocalhost 1
			// whenever when bidirectional OSC
			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc $server_sync = $server_name sync_index
			{
				print syc $server_sync
				// $t_nim := [ $map_nim($nim_min_key + $interval * ($x / ($num_frames - 1))) | $x in ($num_frames) ] // convert nim to tab	
				forall $val in ($tab_table.size()-1) // construction wavetable NoWrap pour wave shaper synthesis
				{	
					@local $next
					$next := $tab_table[$val+1]
					// $next := $tab_table[$tab_index+1]
					$waveTable.push_back(2*$tab_table[$val] - $next)
					$waveTable.push_back($next-$tab_table[$val])
				}
				// print waveTable (""+$waveTable)
				$osc_tab_size := $waveTable.size()	
				print waveTableNoWrap_size $osc_tab_size
				$slice_size := $osc_tab_size/$max_osc_size // $max_osc_size == 1628 max elements in antescofo OSC 
				$slice_size := @floor($slice_size) // convert to int segments
				$map_list_buff := [$x*$max_osc_size | $x in $slice_size+1]		
				$map_list_buff.push_back($osc_tab_size-($slice_size*$max_osc_size)+$map_list_buff.last())
				// print map_list_buff $map_list_buff

				loop 0
				{
					@local $tab_cut

					$tab_cut := @slice($waveTable, $map_list_buff[$counter_map], $map_list_buff[$counter_map+1])
					$Servers($server_name).b_setn([$buff_id, $map_list_buff[$counter_map], $tab_cut.size(), $tab_cut].flatten()) // 0.01 del for wait to alloc
					$counter_map += 1
				}until ($counter_map == $map_list_buff.size()-1)

				print buff_id $buff_id
				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
				abort $proc_when_envs // abort pour arreter les whenevers

			}
		}
	}
	$buff_alloc := 1 // trig first whenever
}

@global $WaveGen_buf @persistent
if (@is_undef($WaveGen_buf)) { $WaveGen_buf := map{} }


// ::wave_gen("localhost", "cheby", "wt_cheby1", [0.5]) 

@proc_def ::wave_gen($server_name, $sig_generator, $wavetable_name, $amps, $tableSize = 1024)
{
	@local $buff_id

	$buff_id := $SC_Servers($server_name)("buffer_id")
	print wave_gen_buff_num $buff_id
	$WaveGen_buf.add_pair($wavetable_name, $buff_id) // store buffer ID in dictionary
	$Servers($server_name).b_alloc($buff_id, $tableSize, 1) // alloc buffer size
	@set_osc_handling_tab(true) 
	$Servers($server_name).b_gen($buff_id, $sig_generator, 7, $amps) // 7 Wave fill command see "Server Command Reference"
	@set_osc_handling_tab(1) 
	$buff_id += 1
	$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le node_id dans le dico des serveurs
}





// print (""+$Servers("localhost"))

// $nim_test2 := NIM{ 0 0, 0.5 1 "exp", 0.5 0 "exp_out"}

// ::plotnim($nim_test1)

// ::asWavetableNoWrap("localhost", "waveshper1", $nim_test2, 1025) 	

// print toto

// print SF_dir (""+$SF_dir.range())

@global $SF_folder @persistent
@global $SF_map @persistent
@global $SF_path @persistent
if (@is_undef($SF_folder)) { $SF_folder := map{} }
if (@is_undef($SF_map)) { $SF_map := map{} }
if (@is_undef($SF_path)) { $SF_path := map{} }

/// All sound data base
// SF and Folders dictionaries

// @proc_def ::load_samples($server_name)
// {
// 	@local $path_local


// 	// $SF_map.add_pair($server_name, map{}) // create a new map for store each sf in a server
// 	// $SF_path.add_pair($server_name, map{}) // create a new map for store each sf in a server

// 	forall $k, $v in $SF_dir
// 	{
// 		// print key $k
// 		if($v != ".DS_Store") // enleve ".DS_Store"
// 		{
// 			// print (""+$v)
// 			forall $ke, $sf in $v
// 			{	
// 				if($sf != ".DS_Store") // enleve ".DS_Store"
// 				{
// 					$path_local := ($path+$k+"/"+$sf)
// 					// print folder $k soundFile ($path+$k+"/"+$sf)
// 					// print $server_name $buff_id ($path+$k+"/"+$sf)
// 					// scServer "/b_allocRead" $SC_Buffers_index ($path+$k+"/"+$sf)
// 					// $Servers($server_name).b_allocRead($buff_id, $path_local) // load buffer in sc_server
// 					// b_allocReadserver2 $buff_id ($path+$k+"/"+$sf) // pour server2
// 					// $SF_map($server_name).add_pair($sf, $buff_id)	// sf, sc_server_buffer_index
// 					$SF_path.add_pair($sf, $path_local) // sf, path
// 					// $SC_Buffers_index := $SC_Buffers_index + 1
// 					// $buff_id += 1
// 					// $SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le buff_id dans le dico des serveurs
// 				}
// 			}
// 		}
// 	}
// 	$SF_tab := $SF_path.domain()
// }

@proc_def ::load_samples($server_name)
{
	@local $buff_id, $path_local

	$buff_id := $SC_Servers($server_name)("buffer_id")
	$SF_map.add_pair($server_name, map{}) // create a new map for store each sf in a server
	// $SF_path.add_pair($server_name, map{}) // create a new map for store each sf in a server

	forall $k, $v in $SF_dir
	{

		if($v != ".DS_Store") // enleve ".DS_Store"
		{
			// print (""+$v)
			// print key (""+$k)
			// print val (""+$v)
			if($v.is_map()) // folder of folders of SF
			{
				forall $ke, $sf in $v
				{	
					if($sf != ".DS_Store") // enleve ".DS_Store"
					{
						$path_local := ($path+$k+"/"+$sf)
						// print folder $k soundFile ($path+$k+"/"+$sf)
						// print $server_name $buff_id ($path+$k+"/"+$sf)
						// scServer "/b_allocRead" $SC_Buffers_index ($path+$k+"/"+$sf)
						$Servers($server_name).b_allocRead($buff_id, $path_local) // load buffer in sc_server
						// b_allocReadserver2 $buff_id ($path+$k+"/"+$sf) // pour server2
						$SF_map($server_name).add_pair($sf, $buff_id)	// sf, sc_server_buffer_index
						$SF_path.add_pair($sf, $path_local) // sf, path
						// $SC_Buffers_index := $SC_Buffers_index + 1
						$buff_id += 1
						$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le buff_id dans le dico des serveurs
					}
				}
			}
			else // all sf in the same folder
			{
				$path_local := ($path+$v)
				// print folder $k soundFile ($path+$k+"/"+$sf)
				// print $server_name $buff_id ($path+$k+"/"+$sf)
				// scServer "/b_allocRead" $SC_Buffers_index ($path+$k+"/"+$sf)
				$Servers($server_name).b_allocRead($buff_id, $path_local) // load buffer in sc_server
				// b_allocReadserver2 $buff_id ($path+$k+"/"+$sf) // pour server2
				$SF_map($server_name).add_pair($v, $buff_id)	// sf, sc_server_buffer_index
				$SF_path.add_pair($v, $path_local) // sf, path
				// $SC_Buffers_index := $SC_Buffers_index + 1
				$buff_id += 1
				$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le buff_id dans le dico des serveurs					
			}
	
		}
	}
}

@proc_def ::refresh_samples($server_name)
{
	@local $buff_id, $path_local

	$SF_dir := @directory_read($path, 2, ["aif", "aiff", "WAVE"]) // read sf_dir again

	$buff_id := $SC_Servers($server_name)("buffer_id")
	// $SF_map.add_pair($server_name, map{}) // create a new map for store each sf in a server
	print "refresh_samples..."
	forall $k, $v in $SF_dir
	{

		if($v != ".DS_Store") // enleve ".DS_Store"
		{

			if($v.is_map()) // folder of folders of SF
			{
				forall $ke, $sf in $v
				{	
					if($sf != ".DS_Store") // enleve ".DS_Store"
					{
						// if($SF_path($sf).is_undef())
						// print soundfiles (""+$sf)
						// print (""+$SF_map($server_name)($sf).is_undef())
						if($SF_map($server_name)($sf).is_undef())
						{
							$path_local := ($path+$k+"/"+$sf)
							print load $sf in server $server_name
							// print folder $k soundFile ($path+$k+"/"+$sf)
							// print $server_name $buff_id ($path+$k+"/"+$sf)
							// scServer "/b_allocRead" $SC_Buffers_index ($path+$k+"/"+$sf)
							$Servers($server_name).b_allocRead($buff_id, $path_local) // load buffer in sc_server
							// b_allocReadserver2 $buff_id ($path+$k+"/"+$sf) // pour server2
							$SF_map($server_name).add_pair($sf, $buff_id)	// sf, sc_server_buffer_index
							$SF_path.add_pair($sf, $path_local) // sf, path
							// $SC_Buffers_index := $SC_Buffers_index + 1
							$buff_id += 1
							$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le buff_id dans le dico des serveurs
						}
					}
				}
			}
			else // all sf in the same folder
			{
				if($SF_map($server_name)($sf).is_undef())
				{
					$path_local := ($path+$v)
					print load $sf in server $server_name
					// print folder $k soundFile ($path+$k+"/"+$sf)
					// print $server_name $buff_id ($path+$k+"/"+$sf)
					// scServer "/b_allocRead" $SC_Buffers_index ($path+$k+"/"+$sf)
					$Servers($server_name).b_allocRead($buff_id, $path_local) // load buffer in sc_server
					// b_allocReadserver2 $buff_id ($path+$k+"/"+$sf) // pour server2
					$SF_map($server_name).add_pair($v, $buff_id)	// sf, sc_server_buffer_index
					$SF_path.add_pair($v, $path_local) // sf, path
					// $SC_Buffers_index := $SC_Buffers_index + 1
					$buff_id += 1
					$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le buff_id dans le dico des serveurs					
				}
			}
		}
	}
}


@proc_def ::load_samples2($server_name)
{
	@local $buff_id, $tab_inc := 0, $load_trig1 := true, $path_local, $sf
	
	$SF_map.add_pair($server_name, map{}) // create a new map for store each sf in a server
	

	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $tab_inc) && $load_trig1) // wait for server syc
	{
		if($tab_inc < $SF_tab.size())
		{
			$sf := $SF_tab[$tab_inc]
			$path_local := $SF_path($sf)
			$Servers($server_name).b_allocRead($buff_id, $path_local) // load buffer in sc_server
			$SF_map($server_name).add_pair($sf, $buff_id)
			print $sf
			$buff_id += 1
			$SC_Servers($server_name).add_pair("buffer_id", $buff_id) // incremente le buff_id dans le dico des serveurs
			$tab_inc += 1
			$Servers($server_name).sync($tab_inc) // send sync to server		
		}

	}
	$Servers($server_name).sync($tab_inc) // trigger whenever
}

$SF_folder.add_pair("SF_folder", []) // when only one folder

@proc_def ::load_samples_folder()
{
	print "loading folder content ..."
	forall $k, $v in $SF_dir
	{
		// print key $k
		if($v != ".DS_Store") // enleve ".DS_Store"
		{			
			if($v.is_map()) // folder of folders of SF
			{
				// print (""+$v)
				$SF_folder.add_pair($k, [])
				
				forall $ke, $sf in $v
				{	
					if($sf != ".DS_Store") // enleve ".DS_Store"
					{
						$SF_folder($k).push_back($sf)
					}
				}
			}
			else
			{				
				// print (""+@strip_path($path))
				// print (""+@strip_path($path)[1])
				// print (""+$SF_folder(@strip_path($SF_dir)))
				$SF_folder("SF_folder").push_back($v)
				// print (""+$v)
			}
		}
	}
}
// print (""+$SF_folder)

// @obj_def VBPVoc($pvoc_buf_name, $server_name, $dur, $fftsize = 2048) 
// {
// 	@local $overlap := 4, $hopsize, $fftframes, $outframes

// 	$hopsize := $fftsize/$overlap

// }

// @proc_def calcPVRecSize($num, $frameSize, $hop)
// {
// 	@local $rawsize
// 	$rawsize := ((($num * $sampling_rate) / ($frameSize)).ceil() * $frameSize)
// 	return $rawsize * $hop.inv() + 3

// }

// print toto
// print $calcPVRecSize(1, 1024, 0.5)

// a = ((1*48000)/1024).ceil *1024;
//  a*0.5.reciprocal + 3;

//  	calcPVRecSize {arg frameSize, hop, sampleRate;
// 		var rawsize, tmp;
// 		sampleRate = sampleRate ?? {Server.default.sampleRate};
// 		rawsize = (((this * sampleRate) / (frameSize)).ceil * frameSize);
// 		^rawsize * hop.reciprocal + 3;

// 		var overlap = 4;
// 		var hopsize = fftsize.div(overlap);
// 		var fftframes = ((inputbuffer.numFrames - fftsize) / hopsize + 2).roundUp;
// 		var outframes = fftsize.div(2) * fftframes;

// print SF_map (""+$SF_map("localhost"))
///////////
// ::envs_nim_map2buffer($envs_map) // convert $envs_map to buffers

// forall $k, $v in $envs_map
// {
// 	::nim2buffer($v)
// 	$envs.add_pair($k, $SC_Buffers_index)
// 	$SC_Buffers_index := $SC_Buffers_index + 1
// }

// group
// {
// 	2 b_querylocalhost 0

// }


// // ::plot($envs_map("pointe"))
// print envs (""+$envs)

// // envs MAP{ ("carre", 0), ("carre2", 1), ("carre3", 2), ("inv", 3), ("m", 4), ("m2", 5), ("perc", 6), ("perc_rond", 7), ("pointe", 8), ("rond", 9) }

// // Sound files



// print SF_map (""+$SF_map)
// print SF_folder_map (""+$SF_folder)

// forall $sf in $SF_dir_CP_hang
// {
// 	b_allocReadlocalhost $i ($path+"CP-hang/"+$sf)
// 	$map_sf.add_pair($sf, $i)
// 	$i := $i + 1
// }


$status_report := 0
$map_server_cpu := map {}
$localhost_meter := 0
$FluidBufOnsetSlice := 0


@obj_def sc_server($server_name, $port, $inputs = 24, $outputs = 24, $sc_server = "scsynth", $audio_bus = 81920, $sr = 48000, $device = "Built-in Microph", $block_size = 64, $hardware_buffer_size = 256, $num_buffers = 16384, $max_num_synth_defs = 8192, $max_nodes = 16384, $memSize = 1048576, $numWireBufs = 256, $max_logins = 64) // obj::sc_server("server1", 57111) $memSize = 65536 ---- 262144 4194304 2097152 --- 1048576 16777216 $max_num_synth_defs = 131072
{
	@local $server_boot, $server, $cpu, $rec_map := map{}, $device_in, $device_out

    @init 
    {
	osc_client server_osc localhost:$port * $server // @persistent // commande osc bidirectionel


	// if($SC_Servers.is_defined($server_name)) // si le serveur est déjà instancié
	// {
	// 	print server $server_name already instantiated
	// 	server_osc "/version" 1
	// 	$THISOBJ.g_new(1, 0, 0) // Create default group into the server
	// 	$Servers.insert($server_name, $THISOBJ) // objet dans une map pour l'appeler depuis d'autres objets 

	// 	$synths_map.insert($server_name, map{})
	// 	$track_proc.insert($server_name, map{})
	// 	$vst_plugins.insert($server_name, map{})
	// 	$space_group.insert($server_name, map{})
	// 	$group_proc.insert($server_name, map{})
	// 	$wavetable.insert($server_name, map{})

	// }
	// else
	// {
		@local $when := 0, $loop_server_boot := 0, $when_server_boot := 0, $serve_exist := true

		if ($device.is_tab())
		{
			$device_in := $device[0]
			$device_out := $device[1]
		}
		else
		{
			$device_in := $device
			$device_out := $device
		}

		print port $port
		print device_in $device_in
		print device_out $device_out
		print inputs $inputs
		print outputs $outputs

		print notify "server ...."

		server_osc "/version" 1

			$when := {
				whenever ($server) //[0] == "/fail") // server already boot and stop in antescofo
				{	
					$serve_exist := false
					print this server is already boot new object $server_name created
					$Servers.insert($server_name, $THISOBJ) // objet dans une map pour l'appeler depuis d'autres objets 
					$THISOBJ.init_server(1)

					abort $when // kill whenever
				} during [1#]
			}

		0.2 if($serve_exist) // no server boot with delay, waiting for  
		{	
			abort $when // kill whenever test 

			// lance un SC server depuis antescofo avec la commande system
			// @system("osascript -e 'tell app \"Terminal\" to do script \"/Applications/SuperCollider.app/Contents/Resources/scsynth -u "+$port+" -B 127.0.0.1 -a "+$audio_bus+" -i "+$inputs+" -o "+$outputs+" -b "+$num_buffers+" -z "+$block_size+" -d "+$max_num_synth_defs+" -n "+$max_nodes+" -m "+$memSize+" -w "+$numWireBufs+" -S "+$sr+" -R 0 -l "+$max_logins+" -H \\\""+$device_in+"\\\" \\\""+$device_out+"\\\" \"' -e 'tell app \"Terminal\" to set custom title of front window to "+$port+"'") //"+($server_name+"_"+$port)+" \"$server_name\"
			switch($sc_server)
			{
				case "scsynth": 
			  	@system("osascript -e 'tell app \"Terminal\" to do script \"/Applications/SuperCollider.app/Contents/Resources/scsynth -u "+$port+" -B 127.0.0.1 -a "+$audio_bus+" -i "+$inputs+" -o "+$outputs+" -b "+$num_buffers+" -z "+$block_size+" -Z "+$hardware_buffer_size+" -d "+$max_num_synth_defs+" -n "+$max_nodes+" -m "+$memSize+" -w "+$numWireBufs+" -S "+$sr+" -R 0 -l "+$max_logins+" -H \\\""+$device_in+"\\\" \\\""+$device_out+"\\\" \"' -e 'tell app \"Terminal\" to set custom title of front window to "+$port+"'") //"+($server_name+"_"+$port)+" \"$server_name\"
				// @system("osascript -e 'tell app \"Terminal\" to do script \"/Applications/SuperCollider.app/Contents/Resources/scsynth -u "+$port+" -B 127.0.0.1 -a "+$audio_bus+" -i "+$inputs+" -o "+$outputs+" -b "+$num_buffers+" -z "+$block_size+" -d "+$max_num_synth_defs+" -n "+$max_nodes+" -m "+$memSize+" -w "+$numWireBufs+" -S "+$sr+" -R 0 -l "+$max_logins+" ' -e 'tell app \"Terminal\" to set custom title of front window to "+$port+"'") //"+($server_name+"_"+$port)+" \"$server_name\"
			  	// @system("/Applications/SuperCollider.app/Contents/Resources/scsynth -u "+$port+" -B 127.0.0.1 -a "+$audio_bus+" -i "+$inputs+" -o "+$outputs+" -b "+$num_buffers+" -z "+$block_size+" -d "+$max_num_synth_defs+" -n "+$max_nodes+" -m "+$memSize+" -w "+$numWireBufs+" -S "+$sr+" -R 0 -l "+$max_logins+" -H \""+$device_in+"\" &") // -H "+$device_in+"  //\\\""+$device_in+"\\\" \\\""+$device_out+"\\\" ")
			  	case "supernova": 
			  	@system("osascript -e 'tell app \"Terminal\" to do script \"/Applications/SuperCollider.app/Contents/Resources/supernova -u "+$port+" -B 127.0.0.1 -a "+$audio_bus+" -i "+$inputs+" -o "+$outputs+" -b "+$num_buffers+" -z "+$block_size+" -Z "+$hardware_buffer_size+" -d "+$max_num_synth_defs+" -n "+$max_nodes+" -m "+$memSize+" -w "+$numWireBufs+" -S "+$sr+" -R 0 -l "+$max_logins+" -H \\\""+$device_in+"\\\" \\\""+$device_out+"\\\" \"' -e 'tell app \"Terminal\" to set custom title of front window to "+$port+"'") //"+($server_name+"_"+$port)+" \"$server_name\"
				case @true: // ninguno de los anteriores
				print you must use scsynth or supernova audio server 
			}

				$Servers.insert($server_name, $THISOBJ) // objet dans une map pour l'appeler depuis d'autres objets 

				$when_server_boot := {
					whenever ($server) // when receive info from server initialize server commands and kill whenevers
					{
						$THISOBJ.init_server(0)
						print $server_name "at port" $port "ready!" 
						abort $loop_server_boot // kill loop
						abort $when_server_boot // kill whenever
					} during [1#]
				}

				$loop_server_boot := {
					loop 1 // interroge le server pour savoir s'il a booté
					{
						print "loading..." $server_name
						server_osc "/notify" 1 1
					}
				}
		}
		// }
	}

//////  CASE for servers responses

    @whenever ($server)
    {	
	@local $tab_levs

	// print server $server

	switch($server[0])
	{
		case "/status.reply":
			status $server_name $server
			$status_report := $server_name.cons($server)
			// $cpu := $server[7]
			// $map_server_cpu($server_name) := $server[7]
			// $map_server_cpu.add_pair($server_name, $server[7])

			// print server_name_server_name $server_name
		case "/synced":
			// print server_sync $server_name ($server[1])
			$server_sync := [$server_name, $server[1]]
			// print server_sync ($server[1])
			
		case "/meter":
			sc_meter $server_name $server
			// meter localhost /meter 101 100 0.296139 0.139845
			$localhost_meter := ($server[3])
			// print ($server[3])
			// print meter $server_name $server
		case "/master_meter_out":
			// master_meter_out ($server.drop(3))
			$tab_levs := $server.drop(3)      		
			$tab_levs := [ $tab_levs[$i] | $i in @size($tab_levs) : 2] // delace
			// master_meter_out_max @a2dB($tab_levs)
			master_meter_out_max $server_name $tab_levs
			master_meter_out $tab_levs
			// print (""+$tab_levs)
		case "/done":
		switch($server[1])
		{
			case "/b_alloc":
				$buff_alloc_from_server := 1 // pour le whenever dans @proc_def ::envs_nim_map2buffer
				// print alloc buff ($server[2])
				// print alloc buff $server_name ($server[2])
			case "/b_read":
				$buff_read_HOA_index := 1 // pour le whenever dans @proc_def ::read_buffer_HOA
				print b_read buffer ($server[2]) in server $server_name
			case "/b_allocRead":
				print b_allocRead buffer ($server[2]) in server $server_name
			case "/b_allocReadChannel":
				// print b_allocReadChannel buffer ($server[2]) in server $server_name
			// Flucoma 
			case "FluidBufOnsetSlice/process":
			// print  "FluidBufOnsetSlice/process" done
			$FluidBufOnsetSliceDone := $server.push_front($server_name)
			// print FluidBufOnsetSliceDone $FluidBufOnsetSliceDone
			case "FluidBufStats/processNew":
			// print  "FluidBufStats/processNew" done
			$FluidBufStatsDone := $server.push_front($server_name)
			// print FluidBufStatsDone $FluidBufStatsDone
			case "FluidBufCompose/processNew":
			// print  "FluidBufCompose/processNew" done
			$FluidBufComposeDone := $server.push_front($server_name)
			// print FluidBufComposeDone $FluidBufComposeDone
			case "FluidBufTrSlice/processNew":
			// print  "FluidBufTrSlice/processNew" done
			$FluidBufTrSliceDone := $server.push_front($server_name)
			// print FluidBufTrSliceDone $FluidBufTrSliceDone	
			case "FluidBufAmpSlice/processNew":
			// print  "FluidBufAmpSlice/processNew" done
			$FluidBufAmpSliceDone := $server.push_front($server_name)
			// print FluidBufAmpSliceDone $FluidBufAmpSliceDone	
			case "FluidBufNoveltySlice/processNew":
			// print  "FluidBufNoveltySlice/processNew" done
			$FluidBufNoveltySliceDone := $server.push_front($server_name)
			// print FluidBufNoveltySliceDone $FluidBufNoveltySliceDone
			case "FluidBufAmpGate/processNew":
			// print  "FluidBufAmpGate/processNew" done
			$FluidBufAmpGateDone := $server.push_front($server_name)
			// print FluidBufAmpGateDone $FluidBufAmpGateDone	
			case "FluidBufSpectralShape/processNew":
			// print  "FluidBufSpectralShape/processNew" done
			$FluidBufSpectralShapeDone := $server.push_front($server_name)
			// print FluidBufSpectralShapeDone $FluidBufSpectralShapeDone	
			case "FluidBufLoudness/processNew":
			// print  "FluidBufLoudness/processNew" done
			$FluidBufLoudnessDone := $server.push_front($server_name)
			// print FluidBufLoudnessDone $FluidBufLoudnessDone	
			case "FluidBufMFCC/processNew":
			// print  "FluidBufMFCC/processNew" done
			$FluidBufMFCCDone := $server.push_front($server_name)
			// print FluidBufMFCCDone $FluidBufMFCCDone
			case "FluidBufPitch/processNew":
			// print  "FluidBufPitch/processNew" done
			$FluidBufPitchDone := $server.push_front($server_name)
			// print FluidBufPitchDone $FluidBufPitchDone
			case @true: // ninguno de los anteriores
			print $server 

		}
		case "/n_set":
		$node_set := $server	
		print n_set $node_set
		case "/b_info":
		$buf_info := $server.push_front($server_name)
		print buf_info $buf_info
		case "/b_set":
		$buf_set := $server
		print buf_set_replay $server
		case "/b_setn": 
		$buf_setn := $server
		print buf_setn_replay $server
		case "/n_go":
		// do somthing when destroy a synth
		case "/n_end":
		// do somthing when create a synth   
		case "/meterAuxIn":
			// meter aux leve

			//// DSECRIPTORS ///
			case "/amplitude":
			print amplitude $server
			$descriptors_receives := [$server_name, $server]
			case "/loudness":
			// print loudness $server
			$descriptors_receives := [$server_name, $server]
			case "/onset":
			// print onset $server
			$descriptors_receives := [$server_name, $server]
			// print onset (""+$descriptors_receives)
			case "/onsetdetect":
			// print onset $server
			$descriptors_receives := [$server_name, $server]
			// print onset (""+$descriptors_receives)	
			case "/ampgatedetect":
			// print ampgatedetect $server
			$descriptors_receives := [$server_name, $server]
			// print onset (""+$descriptors_receives)						
			case "/centroid":
			$descriptors_receives := [$server_name, $server.drop(-1).concat([@scale($server.drop(3)[0], 20, 15000, 0., 1., 0.5)])]
			// print (""+$descriptors_receives)
			 // $descriptors_receives := [$server_name, $server]
			case "/flatness":
			// print onset $server
			$descriptors_receives := [$server_name, $server]
			case "/pcile":
			// print onset $server
			$descriptors_receives := [$server_name, $server]
			case "/sensorydissonance":
			// print onset $server
			$descriptors_receives := [$server_name, $server]
			case "/topnfreq":
			print topnfreq $server
			$descriptors_receives := [$server_name, $server]	
			// Fluid
			case "/fluid_pitch":
			$descriptors_receives := [$server_name, $server]
			case "/fluid_loudness":
			$descriptors_receives := [$server_name, $server]
			case "/fluid_melbands":
			$descriptors_receives := [$server_name, $server]
			case "/fluid_mfcc":
			$descriptors_receives := [$server_name, $server]
			case "/fluid_spectralshape":
			$descriptors_receives := [$server_name, $server]
			case "/fluid_chroma":
			$descriptors_receives := [$server_name, $server]
			case "/fluid_melbands":
			$descriptors_receives := [$server_name, $server]			
															
			// print fluid_chroma $server
			case "/vst_param":
			// receive vst params from VSTPlugIns UGEN
			case "/seg_end": 
			$seg_end := [$server_name, $server]
		case @true: // si no es ninguno de los anteriores
		print reponse $server_name $server
	}
	}

    @proc_def init_server($etat)
    {
    	if($etat) // si le serveur est déjà instancié
		{
			print server $server_name already instantiated
			server_osc "/version" 1
			$THISOBJ.g_new(1, 0, 0) // Create default group into the server
			$Servers.insert($server_name, $THISOBJ) // objet dans une map pour l'appeler depuis d'autres objets 
			if($SC_Servers($server_name).is_undef())
			{
				$SC_Servers.insert($server_name, map{("node_id", 100),("bus_index", 300), ("buffer_id", 0)}) //
				$sc_struct.add_pair($server_name, map{(1, map{ ("default_group", [] )}) }) // root tree 0 -> default group 1

			}
			/// doivent être persistantes à faire !
			$synths_map.insert($server_name, map{})
			$track_proc.insert($server_name, map{})
			$vst_plugins.insert($server_name, map{})
			$space_group.insert($server_name, map{})
			$group_proc.insert($server_name, map{})
			$wavetable.insert($server_name, map{})

		}
		else
		{
			$SC_Servers.insert($server_name, map{("node_id", 100),("bus_index", 300), ("buffer_id", 0)}) // dico des serveurs avec valeurs init des nodes et bus
			$synths_map.insert($server_name, map{})
			$track_proc.insert($server_name, map{})
			$vst_plugins.insert($server_name, map{})
			$space_group.insert($server_name, map{})
			$group_proc.insert($server_name, map{})
			$wavetable.insert($server_name, map{})
			// $sc_struct.add_pair($server_name, map{(0, [1]), (1, [])} ) // root tree 0 -> default group 1

			$sc_struct.add_pair($server_name, map{(1, map{ ("default_group", [] )}) }) // root tree 0 -> default group 1

			$THISOBJ.g_new(1, 0, 0) // Create default group into the server

			servers_max ($SC_Servers.domain()) // add server name to Max interface

			// $map_server_cpu.add_pair($server_name, $cpu)

			// loop status 0.1s
			// {
			// 	$THISOBJ.status(1) // CPU usage, server call each 0.1 second
			// }


			// crea synth para control volume general server

			// $THISOBJ.s_new(["audioOut24", 2, 1, 0, "in", 0, "out", 0]) // control general node 2


			// @command($server_name) "/g_queryTree" 0
			// // scServer "/g_queryTree" 0

			// @command($server_name) "/dumpOSC" 0
			// // scServer "/dumpOSC" 0

			// @command($server_name) "/notify" 1
			// // scServer "/notify" 1

			// // @command("g_new"+$server_name) 1 0 0 // create default group 1 on serverX
			// @command($server_name) "/g_new" 0 0
		}

	}

	@proc_def volume($amp)
    {
	$THISOBJ.n_set(2, ["amp", $amp])  // control amp server
	print server $server_name amp $amp
    }

	@proc_def master_out($num_channels) // for master 24 channels audio output in openFrameworks
    {
	$THISOBJ.s_new(["audioOut"+$num_channels, 2, 1, 0, "in", 0, "out", 0]) // control general node 2
    }

	@fun_def record($name, $num_ch = 24, $headerFormat = "aiff", $sampleFormat = "int24", $num_frames = 65536, $fade_in = 0.1, $start_frame = 0, $leave_file_open = 1)
	{
		@local $buff_id, $rec_node

		$buff_id := $SC_Servers($server_name)("buffer_id")
		$rec_node := $SC_Servers($server_name)("node_id") // last id
		$rec_map.add_pair($name, [$buff_id, $rec_node]) // store buf_id and node_id
		print rec_mix_group_start $rec_node
		
		$Servers($server_name).b_alloc($buff_id, $num_frames, $num_ch) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, 0, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open


		$Servers($server_name).s_new(["Diskout_"+$num_ch, $rec_node, 1, 0, "in", 0, "bufnum", $buff_id, "in_ramp", $fade_in]) // "in", 0 start from bus 0 (output)
		

		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
		$SC_Servers($server_name).add_pair("node_id", $rec_node + 1)

	}


	@proc_def stop_record($name, $fade_out = 0.1)
	{
		@local $buff_id, $rec_node			
		// print rec_node_stop

		$buff_id := $rec_map($name)[0]
		$rec_node := $rec_map($name)[1]
		print rec_node_stop $rec_node

		$Servers($server_name).n_set($rec_node, ["out_ramp", @dur2sec($fade_out), "free", 0]) // stop recording

		$fade_out $Servers($server_name).b_free($buff_id) // close the file.

	}	
	// Server Commands

	// Server
    @fun_def quit()
    {
	server_osc "/quit" 1
    }
    @fun_def notify($val)
    {
	server_osc "/notify" $val
    }
    @fun_def status($val)
    {
	server_osc "/status" $val
    }
    @fun_def cmd($val)
    {
	server_osc "/cmd" $val
    }
    @fun_def dumpOSC($val)
    {
	server_osc "/dumpOSC" $val
    }
    @fun_def sync($id)
    {
	server_osc "/sync" $id
    }
    @fun_def clearSched()
    {
	server_osc "/clearSched"
    }
    @fun_def error($val)
    {
	server_osc "/error" $val
    }
    @fun_def version()
    {
	server_osc "/version" 1
    }
    // Synth definition NOT YET!

    // Node
    @fun_def n_free($node_id)
    {
	server_osc "/n_free" $node_id
    }
    @fun_def n_run($node_id, $run)
    {
	server_osc "/n_run" $node_id $run
    }
    @fun_def n_set($node, $params)
    {
    	// print node (""+$node)
    	// print params (""+$params)
	server_osc "/n_set" $node $params
    }
    @fun_def n_setn($node, $params)
    {
	server_osc "/n_setn" $node $params
    }
    @fun_def n_fill($node, $params)
    {
	server_osc "/n_fill" $node $params
    }
    @fun_def n_map($node, $params)
    {
	server_osc "/n_map" $node $params
    }
    @fun_def n_mapn($node, $params)
    {
	server_osc "/n_mapn" $node $params
    }
    @fun_def n_mapa($node, $params)
    {
	server_osc "/n_mapa" $node $params
    }
    @fun_def n_mapan($node, $params)
    {
	server_osc "/n_mapan" $node $params
    }
    @fun_def n_before($node1, $node2)
    {
	server_osc "/n_before" $node1 $node2
    }
    @fun_def n_after($node1, $node2)
    {
	server_osc "/n_after" $node1 $node2
    }
    @fun_def n_query($node_id)
    {
	server_osc "/n_query" $node_id
    }
    @fun_def n_trace($node_id)
    {
	server_osc "/n_trace" $node_id
    }
    @fun_def n_order($action, $target, $node_list)
    {
	server_osc "/n_order" $action $target $node_list
    }

    // Synth

    @fun_def s_new($params)
    {
	server_osc "/s_new" $params
	// print params (""+$params)
    }
    @fun_def s_get($params)
    {
	server_osc "/s_get" $params
    }
    @fun_def s_getn($params)
    {
	server_osc "/s_getn" $params
    }
    @fun_def s_noid($node_id)
    {
	server_osc "/s_noid" $node_id
    }

    // Group

    @fun_def g_new($group_id, $add_action, $target) // creer un group
    {
	// print $server_name "/g_new" $group_id $add_action $target
	server_osc "/g_new" $group_id $add_action $target //1 0 0
    }    
    @fun_def p_new($group_id, $add_action, $target) // creer un group
    {
	// print $server_name "/g_new" $group_id $add_action $target
	server_osc "/p_new" $group_id $add_action $target //1 0 0
    }   
    @fun_def g_head($group_id, $node_id) // creer un group
    {
	// print $server_name "/g_new" $group_id $add_action $target
	server_osc "/g_head" $group_id $node_id //1 0 0
    }   
    @fun_def g_tail($group_id, $node_id) // creer un group
    {
	server_osc "/g_tail" $group_id $node_id 
    } 
    @fun_def g_freeAll($group_id) // creer un group
    {
	server_osc "/g_freeAll" $group_id
    }
    @fun_def g_deepFree($group_id) // creer un group
    {
	server_osc "/g_deepFree" $group_id
    }          
    // @fun_def g_new_default() // lacer quand le serveur boots
    // {
    // 	server_osc "/g_new_default" 1 0 0
    // }
    @fun_def g_dumpTree($val, $flag = 0) // lacer quand le serveur boots
    {
	server_osc "/g_dumpTree" $val $flag
    }
    @fun_def g_queryTree($group_id, $flag = 0) // lacer quand le serveur boots
    {
	server_osc "/g_queryTree" $group_id $flag
    }
    @fun_def u_cmd($val) 
    {
	server_osc "/u_cmd" $val
    }

    // buffers

    @fun_def b_alloc($buf_id, $num_frames, $num_chnls)
    {
	server_osc "/b_alloc" $buf_id $num_frames $num_chnls
    }
    @fun_def b_allocRead($buf_id, $path)
    {
	server_osc "/b_allocRead" $buf_id $path
    }
    @fun_def b_allocReadChannel($buf_id, $path, $startFrame, $numFrames, $channelIndex)
    {
	server_osc "/b_allocReadChannel" $buf_id $path $startFrame $numFrames $channelIndex
    }
    @fun_def b_read($buf_id, $path)
    {
	server_osc "/b_read" $buf_id $path
    }
    @fun_def b_readChannel($buf_id, $path)
    {
	server_osc "/b_readChannel" $buf_id $path
    }
    @fun_def b_write($buf_id, $path, $header_format = "aiff", $sample_format = "int32", $num_frames = -1, $start_frame = 0, $leave_file_open = 0)
    {
	server_osc "/b_write" $buf_id $path $header_format $sample_format $num_frames $start_frame $leave_file_open
    }
    @fun_def b_free($buf_id)
    {
	server_osc "/b_free" $buf_id
    }
    @fun_def b_zero($buf_id)
    {
	server_osc "/b_zero" $buf_id 
    }
    @fun_def b_set($buf_id, $args)
    {
	server_osc "/b_set" $buf_id $args
    }
    @fun_def b_setn($buf_id) //, $args
    {
	server_osc "/b_setn" $buf_id // $args
    }
    @fun_def b_fill($buf_id, $args)
    {
	server_osc "/b_fill" $buf_id $args
    }
    @fun_def b_gen($buf_id, $arg1, $arg2, $arg3)
    {
	server_osc "/b_gen" $buf_id $arg1 $arg2 $arg3
    }
    @fun_def b_close($buf_id)
    {
	server_osc "/b_close" $buf_id
    }
    @fun_def b_query($buf_id)
    {
	server_osc "/b_query" $buf_id
    }
    @fun_def b_get($buf_id, $buf_index)
    {
	server_osc "/b_get" $buf_id $buf_index
    }
    @fun_def b_getn($buf_id, $start, $num)
    {
	server_osc "/b_getn" $buf_id $start $num
    }
    @fun_def command_number($num)
    {
	server_osc "[005, 2, 1001]" 21 
    }
    @fun_def test_method()
    {
	print "test method"
    }    

}

	
@obj_def mix_group($group_name, $server_name, $num_channels = 8, $out_offset = 0, $pan = false, $destination = <undef>, $pan_init = -1, $out = true)
{
	@local $group_id, $bus, $node_id_out, $addmod_index := 0, $group_pan0, $rec_map := map{}
	@init 
    {

	if($SC_Servers($server_name).is_undef())
	{	
		print error server $server_name "does not exist"
	}
	else
	{
		if($SC_Groups($group_name).is_undef())
		{
			$group_id := $SC_Servers($server_name)("node_id") // current node id for this server
			$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server

				$SC_Groups.insert($group_name, map{("server_name", $server_name)}) // creation du dico $group_name dans $SC_Groups

				$Servers($server_name).g_new($group_id, 0, 1)
				print server_llamado ($Servers($server_name)+"")
			// scServer "/g_new" $group_id 0 1 // add group to default group 1 of the $server_name



			$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs

			$node_id_out := $SC_Servers($server_name)("node_id") // id for audioOut8 Synth

			// @command("s_new"+$server_name) audioOut8 $node_id_out 1 $group_id in $bus out 0 index $bus in_ramp 0.001 amp 0
			// scServer "/s_new" audioOut8 $node_id_out 1 $group_id in $bus out 0 index $bus in_ramp 0.001 amp 0

			if(! $pan) // pannig between groups ex HOA -> Stereo
			{
				$Servers($server_name).s_new(["audioOut"+$num_channels, $node_id_out, 1, $group_id, "in", $bus, "out", $out_offset, "index", $bus, "in_ramp", 0.001, "amp", 0])
			}
			else
			{

				$group_pan0 := $tracks($destination).$bus
				// $group_pan1 := $SC_Groups($destination1)("main_bus")
				
				if($group_pan0.is_undef())
				{
					print "you have to define an existant dstination "
				}
				else
				{
					print group_pan0 $group_pan0
					// print group_pan1 $group_pan1
					$Servers($server_name).s_new(["Pan_to_"+$num_channels, $node_id_out, 1, $group_id, "in", $bus, "out", $out_offset, "out2", $group_pan0, "index", $bus, "in_ramp", 0.001, "amp", 0, "pan2_pos", $pan_init])
				}
			}

			// $node_id := $node_id + 1 // incremente le node_id
			$SC_Servers($server_name).add_pair("node_id", $node_id_out + 1)
			$SC_Servers($server_name).insert("bus_index", $bus+$num_channels) // inc bus de server  

			// update dictionaires
			$groups.add_pair($group_name, $THISOBJ) // put this group object in dico $group
			$SC_Groups($group_name).insert("main_group_id", $group_id)
			$SC_Groups($group_name).insert("main_bus", $bus)
			$SC_Groups($group_name).insert("num_channels", $num_channels)
			$SC_Groups($group_name).insert("sub_group", map{}) // for store the sub group (crea_track8) object 

			// creation des dictionaires de synth et proc dans un mix group
			$synths_map($server_name).insert($group_name, map{("group", $group_id)})
			$track_proc($server_name).insert($group_name, map{})
			$group_proc($server_name).add_pair($group_name, map{})

			// creation des dictionaires structure generale des nodes
			// $sc_struct($server_name)(1).push_back($group_id) // default group 1 -> [group_id]
			$sc_struct($server_name)(1)("default_group").push_back($group_id) // default group 1 -> [group_id]

			$sc_struct($server_name).add_pair($group_id, map{($group_name , [$node_id_out])}) // crea nueva key group + audioOut
				$sc_struct($server_name).add_pair($node_id_out, map{("_synth", "audioOut"+$num_channels), ("in", $bus), ("out", 0), ("index", $bus), ("in_ramp", 0.001), ("amp", 0)}) // crea MAP para nombre_synth + parametros

				print sc_struct_mix_group
			print new "group" $group_name created in server $server_name

			groups_max $group_id $group_name $server_name

			// oscsend quit "localhost" :57110 "/quit" // quit server application

			// view meters
			whenever ($server[0]=="/meter" && $node_id_out==$server[1]) // reponse server
				{
					// print reponse scServer $server
					print volume group ($server[1]) ($server[3])
					// print toto
				}

		}
		else // add group to specific server g_new
		{
				print "this group exist"
		}
	}
    }
	 
   @fun_def mod_add($module, $action = "before_out", $target_mod = <undef>, $fade_in = 0.01)
   {
	@local $addmod_index := 0, $params, $node_id_mod, $mod_after_id, $mod_before_id, $target_id

	// $fade_in := 0.01 // deberia ser un argumento opcional!!
	// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
	// print modulos $module
    // print groupo $group_id
    // print node_id $node_id
    $node_id_mod := $SC_Servers($server_name)("node_id") // recupère dernier node_id
    
    if($target_mod.is_undef())
    {
	 $target_mod := $node_id_out
    }

    $target_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $target_id
    print size ($module.dim())
    // print params $params
    if ($module.dim() > 1){ // si c'est tab multi
    print MULTI_

	forall $chain in $module // s'il y a plus des modules
	{
		$params := $chain.cdr()
		print chain $chain

			switch ($action)
		{
			case "before_out":
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
				case "after":
				// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
				case "before":
				// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
				case "top":
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
			}

			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			if(($synths_map($server_name)($group_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				$synths_map($server_name)($group_name).insert($chain[0], [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
			}else 
			{
				$synths_map($server_name)($group_name)($chain[0]).push_back($node_id_mod) // si existe rajouter a la TAB
			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1) // incremente node_id
		$node_id_mod := $SC_Servers($server_name)("node_id")

		}
	}else{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			$params := $module.cdr()

			// $Servers($server_name).s_new([($module[0]), $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut

		switch ($action)
			{
			case "before_out":
				$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
				case "after":
				// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module[0], $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
				case "before":
				// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
				case "top":
				$Servers($server_name).s_new([$module[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
			}	

			// $synths_map($server_name)($mix_group)($track_label).insert($module[0], $node_id_mod)
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($group_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module[0]) is not member at $node_id_mod
				$synths_map($server_name)($group_name).insert($module[0], [$node_id_mod])
			}else 
			{
				// print ($module[0]) is member at $node_id_mod
				$synths_map($server_name)($group_name)($module[0]).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			// print este
			// $node_id_mod := $SC_Servers($server_name)("node_id") // recupère node_id

			// @command("s_new"+$server_name) ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in //$params   //target 2 justo despues del nodo 180 audioOut
			// scServer "/s_new" ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in //$params   //target 2 justo despues del nodo 180 audioOut
			// $Servers($server_name).s_new([$module, $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
		// print este $module $node_id_mod $target_mod "in" $bus "out" $bus "matrix_ramp" $fade_in
		

		switch ($action)
		{
			case "before_out":
				$Servers($server_name).s_new([$module, $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
				case "after":
				// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module, $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
				case "before":
				// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module, $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])		   		
				case "top":
				$Servers($server_name).s_new([$module, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
			}

			// $synths_map($server_name)($mix_group)($track_label).insert($module, $node_id_mod)
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus
				
			if(($synths_map($server_name)($group_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module) is not member at $node_id_mod
				// ($synths_map($server_name)($group_name).insert($module, [$node_id_mod])).post()
				$synths_map($server_name)($group_name).insert($module, [$node_id_mod])
			}else 
			{
				// print ($module) is member at $node_id_mod
				$synths_map($server_name)($group_name)($module).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
	}

	}


	@proc_def mod_remove($module, $time_off = 0.1)
	{
		forall $node in ($synths_map($server_name)($group_name)($module))
		{			
			// @command("n_set"+$server_name) $node matrix_ramp $time_off free 0
			// scServer "/n_set" $node matrix_ramp $time_off free 0
			$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])
			$sc_struct($server_name).remove($node)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
			if($track_proc($server_name)($group_name)($node).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($group_name)($node) // parcours le dico de proc
				{
					abort $proc 
				}
			}
			// ($time_off+0.01) $track_proc($server_name)($group_name).remove($node)
		}
		$synths_map($server_name)($group_name).remove($module)
	}

	@proc_def mod_remove_id($nodes, $time_off = 0.1)
	{
		if($nodes.is_tab())
		{
			forall $x in $nodes
			{
				// @command("n_set"+$server_name) $x matrix_ramp $time_off free 0
				// scServer "/n_set" $x matrix_ramp $time_off free 0
				$Servers($server_name).n_set($x, ["matrix_ramp", $time_off, "free", 0])
				$synths_map($server_name)($group_name).remove($sc_struct($server_name)($group_id)($x)("_synth"))
				$sc_struct($server_name)($server_name).remove($x)
				_ := $sc_struct($server_name)($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($x))
				if($track_proc($server_name)($group_name)($x).size() != 0) // abort proc des modules
				{	
					$time_off forall $k, $proc in $track_proc($server_name)($group_name)($x) // parcours le dico de proc
					{
						abort $proc 
					}
				}	
			}
		}
		else
		{
			// @command("n_set"+$server_name) $nodes matrix_ramp $time_off free 0
			// scServer "/n_set" $nodes matrix_ramp $time_off free 0
			$Servers($server_name).n_set($nodes, ["matrix_ramp", $time_off, "free", 0])

			$synths_map($server_name)($group_name).remove($sc_struct($server_name)($group_id)($nodes)("_synth"))
			$sc_struct($server_name).remove($nodes)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($nodes))
			if($track_proc($server_name)($group_name)($nodes).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($group_name)($nodes) // parcours le dico de proc
				{
					abort $proc 
				}
			}
		}	
	}

	@proc_def mod_remove_single($module, $num, $time_off = 0.1) // quand il y a plusieurs instances d'un même module, sinon utiliser la methode mod_remove
	{
		@local $node
		$node := $synths_map($server_name)($group_name)($module)[$num]
		// scServer "n_set" $node matrix_ramp $time_off free 0
		$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])

		$sc_struct($server_name).remove($node)
		$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		_ := $synths_map($server_name)($group_name)($module).remove($synths_map($server_name)($group_name)($module).occurs($node))
		
		$time_off forall $k, $proc in $track_proc($server_name)($group_name)($node) // parcours le dico de proc
		{
			abort $proc 
		}
	$synths_map($server_name)($group_name).remove($node)	
	}

	@proc_def mod_move_before($module, $mod_mov_before)
	{
		// n_before ($synths_map($server_name)($group_name)($module)) ($synths_map($server_name)($group_name)($mod_mov_before)[0])
		
		$Servers($server_name).n_before([$synths_map($server_name)($group_name)($module), $synths_map($server_name)($group_name)($mod_mov_before)[0]])

		print n_before ($synths_map($server_name)($group_name)($module)) ($synths_map($server_name)($group_name)($mod_mov_before)[0])

		// forall $node in ($synths_map($server_name)($group_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($group_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($group_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($group_name).remove($node)
		// }
		// $synths_map($server_name)($group_name).remove($module)
	}

	@proc_def mod_move_before_id($module_id, $mod_mov_before_id)
	{
		// n_before $module_id $mod_mov_before_id

		$Servers($server_name).n_before([$module_id, $mod_mov_before_id])

		print n_before $module_id $mod_mov_before_id

		// forall $node in ($synths_map($server_name)($group_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($group_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($group_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($group_name).remove($node)
		// }
		// $synths_map($server_name)($group_name).remove($module)
	}

	@proc_def mod_move_after($module, $mod_mov_after)
	{
		// n_after ($synths_map($server_name)($group_name)($module)) ($synths_map($server_name)($group_name)($mod_mov_after)[0])
		$Servers($server_name).n_after([$synths_map($server_name)($group_name)($module), $synths_map($server_name)($group_name)($mod_mov_after)[0]])
		print n_after ($synths_map($server_name)($group_name)($module)) ($synths_map($server_name)($group_name)($mod_mov_after)[0])

		// forall $node in ($synths_map($server_name)($group_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($group_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($group_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($group_name).remove($node)
		// }
		// $synths_map($server_name)($group_name).remove($module)
	}

	@proc_def mod_move_after_id($module_id, $mod_mov_after_id)
	{
		// n_after $module_id $mod_mov_after_id
		$Servers($server_name).n_after([$module_id, $mod_mov_after_id])

		print n_after $module_id $mod_mov_after_id

		// forall $node in ($synths_map($server_name)($group_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($group_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($group_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($group_name).remove($node)
		// }
		// $synths_map($server_name)($group_name).remove($module)
	}

    // @proc_def free($t)
    // {
    // 	forall $k, $track in $SC_Groups($group_name)("sub_group") // stop all track (sub_group tab) and proc inside this group 
    // 	{
    // 		$track.free($t) // remove all proc from this track
    // 	}
    // 	// ($t+0.001) scServer "n_set" $group_id "out_ramp" 0.01 "gatee" 0 // stop all modules inside this group in $t time
    // 	($t+0.001) $Servers($server_name).n_set($group_id, ["out_ramp", 0.01, "gatee", 0])

    // 	$SC_Groups.remove($group_name) // remove this group form map SC_Groups
    // 	$synths_map($server_name).remove($group_name)
    // }

	@proc_def free($t)
    {
	forall $k, $track in $SC_Groups($group_name)("sub_group") // stop all track (sub_group tab) and proc inside this group 
	{
		$track.free($t) // remove all proc from this track
	}
	// ($t+0.001) scServer "n_set" $group_id "out_ramp" 0.01 "gatee" 0 // stop all modules inside this group in $t time

	($t+0.001) forall $k, $v in $track_proc($server_name)($group_name)
	{
		if($v.is_map()) // si map abort proc modules
			{
			forall $proc_name, $proc in $v // parcours liste de proc en route
				{
					// ("abort proc_name " + $proc_name).post()
					// ("abort proc " + $proc).post()
					// abort $proc
					forall $proc_name_map, $proc_map in $proc
					{
						abort $proc_map
					}

				}
			}
			else // si proc solo proc de HOA (orbit, ...)
			{
				abort $v
			}
	}

	$Servers($server_name).n_set($group_id, ["out_ramp", 0.01, "gatee", 0])

	$sc_struct($server_name).remove($group_id) // enleve group key de la MAP $sc_struct 
	$SC_Groups.remove($group_name) // remove this group form map SC_Groups
	$synths_map($server_name).remove($group_name)
	$track_proc($server_name).remove($group_name) // delete track_proc from map

    }

    // @fun_def amp($amp)
    // {
    // 	// scServer "n_set" $node_id_out "amp" $amp // 
    // 	$Servers($server_name).n_set($node_id_out, ["amp", $amp])
    // 	print $node_id_out "amp" $amp
    // }


	@proc_def amp($amp)
	{
		@local $nim, $lamp, $last_bpf_amp_curve

		if($group_proc($server_name)($group_name).is_defined("amp"))
		{
			abort $group_proc($server_name)($group_name)("amp") // to avoid interferences
		}		
		// abort $last_bpf_amp_curve // to avoid interferences

		if($amp.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($amp)
			// .CheckParam($module, $param, $MYSELF)
			$lamp := $amp[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["amp", $lamp])	
				} 
				{ $lamp : $nim }
			}
		$group_proc($server_name)($group_name).add_pair("amp", $last_bpf_amp_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["amp", $amp])
		}
	}

	@fun_def set_out($params) // set out for panning
	{
			$Servers($server_name).n_set($node_id_out, $params)
	}


	@proc_def pan($pan)
	{
		@local $nim, $lpan, $last_bpf_pan_curve

		if($group_proc($server_name)($group_name).is_defined("pan"))
		{
			abort $group_proc($server_name)($group_name)("pan") // to avoid interferences
		}		
		// abort $last_bpf_pan_curve // to avoid interferences

		if($pan.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($pan)
			// .CheckParam($module, $param, $MYSELF)
			$lpan := $pan[0]
			$last_bpf_pan_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["pan2_pos", $lpan])	
				} 
				{ $lpan : $nim }
			}
		$group_proc($server_name)($group_name).add_pair("pan", $last_bpf_pan_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["pan2_pos", $pan])
		}
	}


	@fun_def mix_group_rand_lfo_global_send_amp($rand_lfo_instance, $amp_min, $amp_max) // $modules_params -> module, params, min, max
	{
		@local $proc_name := "global_amp"

		// $node_params := $synths_map($server_name)($mix_group) // reconstruit liste avec nodes_id
		// print node_params $node_params

		if($track_proc($server_name)($group_name).is_defined($proc_name) ) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($group_name)($proc_name) 
	}
		$track_proc($server_name)($group_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, [$group_id, "amp", $amp_min, $amp_max]))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}


	@broadcast mix_group_rand_lfo_global_send_all_amp($rand_lfo_instance, $amp_min, $amp_max) // $modules_params -> module, params, min, max
	{
		@local $proc_name := "global_amp"

		// $node_params := $synths_map($server_name)($mix_group) // reconstruit liste avec nodes_id
		// print node_params $node_params

		if($track_proc($server_name)($group_name).is_defined($proc_name) ) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($group_name)($proc_name) 
	}
		$track_proc($server_name)($group_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, [$group_id, "amp", $amp_min, $amp_max]))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

    @proc_def pause() // no time for the moment
	{
		// scServer "n_set" $node_id_out amp -120
		$Servers($server_name).n_set($node_id_out, ["amp", -120])
		0.01s $Servers($server_name).n_run($group_id, 0)
		// scServer "n_run" $group_id 0 // stop running the entire group after 0.01s to avoid clicks
		 // matrix_ramp @dur2sec($time) gate 0
		// @dur2sec($time) n_set $group_id gate 0
	}

	@proc_def resume() // no time for the moment
	{	
		// scServer "n_run" $group_id 1 // start running the entire group
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($node_id_out, ["amp", 0])
	}

	@fun_def record($name, $headerFormat = "aiff", $sampleFormat = "int24", $num_frames = 65536, $fade_in = 0.1, $start_frame = 0, $leave_file_open = 1)
	{
		@local $buff_id, $rec_node

		$buff_id := $SC_Servers($server_name)("buffer_id")
		$rec_node := $SC_Servers($server_name)("node_id") // last id
		$rec_map.add_pair($name, [$buff_id, $rec_node]) // store buf_id and node_id
		print rec_mix_group_start $rec_node
		
		$Servers($server_name).b_alloc($buff_id, $num_frames, $num_channels) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, 0, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open


		$Servers($server_name).s_new(["Diskout_"+$num_channels, $rec_node, 3, $node_id_out, "in", 0, "bufnum", $buff_id, "in_ramp", $fade_in]) // "in", 0 start from bus 0 (output)
		

		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
		$SC_Servers($server_name).add_pair("node_id", $rec_node + 1)

	}	

	@proc_def stop_record($name, $fade_out = 0.1)
	{
		@local $buff_id, $rec_node			
		// print rec_node_stop

		$buff_id := $rec_map($name)[0]
		$rec_node := $rec_map($name)[1]
		print rec_node_stop $rec_node

		$Servers($server_name).n_set($rec_node, ["out_ramp", @dur2sec($fade_out), "free", 0]) // stop recording

		$fade_out $Servers($server_name).b_free($buff_id) // close the file.

	}		
	@fun_def set($module, $params)
	{
		// print scServer "n_set" $module $params
		// print scServer "n_set" ($synths_map($server_name)($mix_group)($track_label)($module)) $params		
		// scServer "n_set" $x $params
		forall $x in ($synths_map($server_name)($group_name)($module))
		{
			// scServer "n_set" $x $params
			$Servers($server_name).n_set($x, $params)
		}
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_label)($module)) 
		// $sc_struct($server_name)($synths_map($server_name)($mix_group)($track_label)($module))("modfreq") := 100
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_label)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_label)($module)))
	}

	// @fun_def set_multi($module, $params)
	// {
	// 	forall $x in $params
	// 	{
	// 		print (""+$params)
	// 	}
	// 	// forall $x in ($synths_map($server_name)($mix_group)($track_label)($module)).size()
	// 	// {
	// 	// 	scServer "n_set" ($synths_map($server_name)($mix_group)($track_label)($module))[$x]
	// 	// }
	// }

	@fun_def set_single ($module, $num, $params)
	{
		// scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $params
		$Servers($server_name).n_set($synths_map($server_name)($group_name)($module)[$num], $params)
	}



	@fun_def mod_kill($module, $fade_out = 1) // kill module
	{
		// scServer "n_set" ($synths_map($server_name)($group_name)($module)) matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($synths_map($server_name)($group_name)($module), ["matrix_ramp", $fade_out, "free", 0])
		//remove synth
		//$sc_struct($server_name)
		// print (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module)))
	}

	@fun_def mod_kill_id($module, $id, $fade_out = 1) // kill module
	{
		// scServer "n_set" ($synths_map($server_name)($group_name)($module)) matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($id, ["matrix_ramp", $fade_out, "free", 0])
		//remove synth
		//$sc_struct($server_name)
		// print (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module)))
	}

	@fun_def mod_size($module)
	{
		return (($synths_map($server_name)($group_name)($module)).size())
	}

///// hacer

	@proc_def amp_bpf($bpf)  // [-6, 7.5, "circ", 3, 4.5, -118]
    {
		@local $nim, $lamp
		// abort $last_bpf_amp_curve //evita interferencias
		$nim := @build_nim_from_bpf($bpf)
		// print $nim
		$lamp := $bpf[0]
		$last_bpf_amp_curve := { curve @grain := 0.01, @action {
			// scServer "n_set" $node_id_out amp $lamp
			$Servers($server_name).n_set($node_id_out, ["amp", $lamp])
		} 
			{ $lamp : $nim }
	    }
	}

    @proc_def line_amp($lmin1, $lmax1, $dur1, $type) 
    {
	   @local $lamp
	// .CheckParam($module, $param, $MYSELF)
	   Curve
	   @grain := 0.01,
	   @action {
			
		// scServer "n_set" $node_id_out "amp" $lamp // 
		$Servers($server_name).n_set($node_id_out, ["amp", $lamp])
	} 
	   { $lamp {            
				    {$lmin1} @type := $type
			 $dur1   {$lmax1}} 
	   }
    }

    @proc_def line_param($module, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				forall $node in ($synths_map($server_name)($group_name)($module))
				{
					// scServer "n_set" $node $param $lparam1
					$Servers($server_name).n_set($node, [$param, $lparam1])
				}
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}} 
		  }

    }

    @proc_def line_param_single($module, $num, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				// scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $param $lparam1
				$Servers($server_name).n_set($synths_map($server_name)($group_name)($module)[$num], [$param, $lparam1])
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}}
		  }
    }

    @proc_def bpf_param($module, $param, $bpf) 
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			forall $node in ($synths_map($server_name)($group_name)($module))
			{
				// scServer "n_set" $node $param $lpar 
				$Servers($server_name).n_set($node, [$param, $lpar])
			}
		} 
		{ $lpar : $nim }
    }

    @proc_def bpf_param_single($module, $num, $param, $bpf) // seulement quand une un track a plusieurs instances du même module
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			$Servers($server_name).n_set($synths_map($server_name)($group_name)($module)[$num], [$param, $lpar])
			// scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $param $lpar
		} 
		{ $lpar : $nim }
    }

///// lfp

	@fun_def sin_lfo($module, $param, $r_low, $r_hi, $t) 
    {
	forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_sin
			abort $track_proc($server_name)($group_name)($x)($module+$param) 
		} 
		   $track_proc($server_name)($group_name)($x).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t))                	
	   }
	}

	@fun_def sin_lfo_single($module, $num, $param, $r_low, $r_hi, $t) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

	if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	} 
	   $track_proc($server_name)($group_name)($node_num).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $node_num, $param, $r_low, $r_hi, $t))                	
	}


//($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo)
	@fun_def brown_lfo($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_brown
			abort $track_proc($server_name)($group_name)($x)($module+$param) 
		} 
		   $track_proc($server_name)($group_name)($x).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $x, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	   }
	}

	@fun_def brown_lfo_single($module, $num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

	if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($group_name)($module+$param) 
	} 
	   $track_proc($server_name)($group_name)($node_num).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $node_num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	}


	@fun_def rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo) 
	{ 
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)($x)($module+$param) 
		}
			$track_proc($server_name)($group_name)($x).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $tpo, $gui)) // instantie un le processus dans le dico

		}
	}


	@fun_def rand_lfo_single($module, $num, $param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($group_name)($module))
		if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($group_name)($node_num).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $node_num, $param, $min, $max, $init_val, $type, $tpo))		
	}


	@fun_def tri_lfo($module, $param, $r_low, $r_hi, $t, $type1, $type2) 
	{ 
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_lfo_tri
			abort $track_proc($server_name)($group_name)($x)($module+$param) 
		}
			$track_proc($server_name)($group_name)($x).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2)) // instantie un le processus dans le dico

		}
	}


	@fun_def tri_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $type1, $type2) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($group_name)($module))
		if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($group_name)($node_num).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2))		
	}



	@fun_def saw_lfo($module, $param, $r_low, $r_hi, $t, $dir, $type) 
	{ 
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_lfo_tri
			abort $track_proc($server_name)($group_name)($x)($module+$param) 
		}
			$track_proc($server_name)($group_name)($x).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type)) // instantie un le processus dans le dico

		}
	}


	@fun_def saw_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $dir, $type) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($group_name)($module))
		if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($group_name)($node_num).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type))		
	}

	@fun_def lfo_abort($module, $param)
	{
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			abort $track_proc($server_name)($group_name)($x)($module+$param) 
		}
	}

	@fun_def lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}

/////

	@fun_def gui()
	{
		@local $addsynth := [], $tab_ids
		$tab_ids := $sc_struct($server_name)($group_id).drop(-1)
		$gui := true
		// TTracks8.new(track_name.asString, nil, group, bus, outsynth);
		print $tab_ids
		print gui $tab_ids
		forall $x in $tab_ids
		{
			// print (""+($sc_struct($server_name)($group_id)($x)))
			// print (""+($sc_struct($server_name)($x)))
			$addsynth.push_back($x)
			$addsynth.push_back($sc_struct($server_name)($x)("_synth"))
			// $addsynth.push_back($sc_struct($server_name)($group_id)($x))
		}
		gui_antes $server_name $track_label $group_id $bus $node_id_out $addsynth
		print gui $server_name $track_label $group_id $bus $node_id_out $addsynth
		// forall $k, $v in $track_proc($server_name)($group_name) // active envoie OSC vers GUI
		// {
		// 	if($v.size() > 0) // si la valeur contiens deja un proc avant creation GUI
		// 	{
		// 		$v.$gui := true // alors activer l'envoie par l'argument $gui (variable locale) 
		// 	}
		// }
	}

	@abort
	{
	    $THISOBJ.free(0.1) // 
	 //    forall $k, $v in $track_proc($server_name)($track_label) // abort processus
		// {
		// 	abort $v
		// }
	}	
}


@obj_def mix_group_ambi($group_name, $server_name)
{
	@local $group_id, $bus, $rev_bus, $ambi_bus, $node_id_out, $addmod_index := 0
	@init 
    {

	if($SC_Servers($server_name).is_undef())
	{	
		print error server $server_name "does not exist"
	}
	else
	{
		if($SC_Groups($group_name).is_undef())
		{
			$group_id := $SC_Servers($server_name)("node_id") // current node id for this server
			$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
			$rev_bus := $bus+8
			$ambi_bus := $rev_bus+4

				$SC_Groups.insert($group_name, map{("server_name", $server_name)}) // creation du dico $group_name dans $SC_Groups

			@command("g_new"+$server_name) $group_id 0 1 // add group to default group 1 of the $server_name

			$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs

			$node_id_out := $SC_Servers($server_name)("node_id") // id for audioOut8 synth

			// @command("s_new"+$server_name) audioOut8 $node_id_out 1 $group_id in $bus out 0 index $bus in_ramp 0.001 amp 0

			@command("s_new"+$server_name) ATKGlobalFOA_Trans_Rev $node_id_out 1 $group_id in $ambi_bus in_rev $rev_bus out 0 in_ramp 0.001 amp 0
			// print ATKGlobalFOA_Trans_Rev $node_id_out 1 $group_id in $ambi_bus in_rev $rev_bus out 0 in_ramp 0.001 amp 0

			// $node_id := $node_id + 1 // incremente le node_id
			$SC_Servers($server_name).add_pair("node_id", $node_id_out + 1)
			$SC_Servers($server_name).insert("bus_index", $bus+8+8) // inc bus de server + ambi_bus (4) + $rev_bus (4) 

			// update dictionaires
			$SC_Groups($group_name).insert("main_group_id", $group_id)
			$SC_Groups($group_name).insert("main_bus", $bus)
			$SC_Groups($group_name).insert("ambi_bus", $ambi_bus)
			$SC_Groups($group_name).insert("rev_bus", $rev_bus)
			$SC_Groups($group_name).insert("sub_group", map{}) // for store the sub group (crea_track8) object 

			// creation des dictionaires de synth et proc dans un mix group
			$synths_map($server_name).insert($group_name, map{})
			$track_proc($server_name).insert($group_name, map{})

			// creation des dictionaires structure generale des nodes
			$sc_struct($server_name)(1).push_back($group_id) // default group 1 -> [group_id]
			$sc_struct($server_name).add_pair($group_id, [$node_id_out]) // crea nueva key group + audioOut
				$sc_struct($server_name).add_pair($node_id_out, map{("_synth", "ATKGlobalFOA_Trans_Rev"), ("in", $bus), ("in_rev", $rev_bus), ("out", 0), ("index", $bus), ("in_ramp", 0.001), ("amp", 0)}) // crea MAP para nombre_synth + parametros

			print new "group" created in server $server_name
		}
		else // add group to specific server g_new
		{
				print "this group exist"
		}
	}
    }
	 
   @fun_def mod_add($module)
   {
	@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod

	$fade_in_mod := 0.01 // deberia ser un argumento opcional!!
	// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
	// print modulos $module
    // print groupo $group_id
    // print node_id $node_id
    print size ($module.dim())
    // print params $params
    if ($module.dim() > 1){ // si c'est tab multi
    print MULTI_
	forall $chain in $module // s'il y a plus des modules
	{
		$node_id_mod := $SC_Servers($server_name)("node_id") // recupère node_id
		print $chain
		$params := $chain.cdr()
			@command("s_new"+$server_name) ($chain[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($track_label)($mix_group)($chain[0]))

			if(($synths_map($server_name)($group_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($chain[0]) is not member at $node_id_mod
				$synths_map($server_name)($group_name).insert($chain[0], [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
			}else 
			{
				// print ($chain[0]) is member at $node_id_mod
				$synths_map($server_name)($group_name)($chain[0]).push_back($node_id_mod) // si existe rajouter a la TAB

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1) // incremente node_id


		}
	}else{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // recupère node_id
			$params := $module.cdr()
			@command("s_new"+$server_name) ($module[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			// $synths_map($server_name)($mix_group)($track_label).insert($module[0], $node_id_mod)
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($group_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module[0]) is not member at $node_id_mod
				$synths_map($server_name)($group_name).insert($module[0], [$node_id_mod])
			}else 
			{
				// print ($module[0]) is member at $node_id_mod
				$synths_map($server_name)($group_name)($module[0]).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			print este
			$node_id_mod := $SC_Servers($server_name)("node_id") // recupère node_id

			@command("s_new"+$server_name) ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			// $synths_map($server_name)($mix_group)($track_label).insert($module, $node_id_mod)
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus
				
			if(($synths_map($server_name)($group_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module) is not member at $node_id_mod
				// ($synths_map($server_name)($group_name).insert($module, [$node_id_mod])).post()
				$synths_map($server_name)($group_name).insert($module, [$node_id_mod])
			}else 
			{
				// print ($module) is member at $node_id_mod
				$synths_map($server_name)($group_name)($module).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
	}

	}
    @proc_def off_group($t)
    {
	forall $k, $track in $SC_Groups($group_name)("sub_group") // stop all track (sub_group tab) and proc inside this group 
	{
		$track.off_track($t) // remove all proc from this track
	}
	($t+0.001) scServer "n_set" $group_id "out_ramp" 0.01 "gatee" 0 // stop all modules inside this group in $t time

	$SC_Groups.remove($group_name) // remove this group form map SC_Groups
    }

    @fun_def amp($amp)
    {
	scServer "n_set" $node_id_out "amp" $amp // 
	print $node_id_out "amp" $amp
    }

    @proc_def pause() // no time for the moment
	{
		scServer "n_set" $node_id_out amp -120
		0.01s scServer "n_run" $group_id 0 // stop running the entire group after 0.01s to avoid clicks
		 // matrix_ramp @dur2sec($time) gate 0
		// @dur2sec($time) n_set $group_id gate 0
	}

	@proc_def resume() // no time for the moment
	{	
		scServer "n_run" $group_id 1 // start running the entire group
		scServer "n_set" $node_id_out amp 0
	}
	@fun_def set($module, $params)
	{
		// print scServer "n_set" $module $params
		// print scServer "n_set" ($synths_map($server_name)($mix_group)($track_label)($module)) $params		
		// scServer "n_set" $x $params
		forall $x in ($synths_map($server_name)($group_name)($module))
		{
			scServer "n_set" $x $params
		}
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_label)($module)) 
		// $sc_struct($server_name)($synths_map($server_name)($mix_group)($track_label)($module))("modfreq") := 100
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_label)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_label)($module)))
	}

	// @fun_def set_multi($module, $params)
	// {
	// 	forall $x in $params
	// 	{
	// 		print (""+$params)
	// 	}
	// 	// forall $x in ($synths_map($server_name)($mix_group)($track_label)($module)).size()
	// 	// {
	// 	// 	scServer "n_set" ($synths_map($server_name)($mix_group)($track_label)($module))[$x]
	// 	// }
	// }

	@fun_def set_single ($module, $num, $params)
	{
		scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $params
	}



	@fun_def mod_kill($module, $fade_out) // kill module
	{
		scServer "n_set" ($synths_map($server_name)($group_name)($module)) matrix_ramp $fade_out free 0
		//remove synth
		//$sc_struct($server_name)
		// print (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module)))
	}



	@fun_def mod_size($module)
	{
		return (($synths_map($server_name)($group_name)($module)).size())
	}

///// hacer

	@proc_def track_amp_bpf($bpf)  // [-6, 7.5, "circ", 3, 4.5, -118]
    {
		@local $nim, $lamp
		// abort $last_bpf_amp_curve //evita interferencias
		$nim := @build_nim_from_bpf($bpf)
		// print $nim
		$lamp := $bpf[0]
		$last_bpf_amp_curve := { curve @grain := 0.01, @action {
			scServer "n_set" $node_id_out amp $lamp
		} 
			{ $lamp : $nim }
	    }
	}

    @proc_def line_amp($lmin1, $lmax1, $dur1, $type) 
    {
	   @local $lamp
	// .CheckParam($module, $param, $MYSELF)
	   Curve
	   @grain := 0.01,
	   @action {
			forall $x in ($synths_map($server_name)($group_name)($module))
		{
			scServer "n_set" $x $params
		}
	   // print scServer "n_set" $node_id_out amp $lamp
	} 
	   { $lamp {            
				    {$lmin1} @type := $type
			 $dur1   {$lmax1}} 
	   }
    }

    @proc_def line_param($module, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				forall $node in ($synths_map($server_name)($group_name)($module))
				{
					scServer "n_set" $node $param $lparam1
				}
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}} 
		  }

    }

    @proc_def line_param_single($module, $num, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $param $lparam1
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}}
		  }
    }

    @proc_def bpf_param($module, $param, $bpf) 
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			forall $node in ($synths_map($server_name)($group_name)($module))
			{
				scServer "n_set" $node $param $lpar 
			}
		} 
		{ $lpar : $nim }
    }

    @proc_def bpf_param_single($module, $num, $param, $bpf) // seulement quand une un track a plusieurs instances du même module
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $param $lpar
		} 
		{ $lpar : $nim }
    }

	@fun_def sin_lfo($module, $param, $r_low, $r_hi, $t) 
    {
	forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($group_name)($x).is_defined($module+"_sin")) // si ça existe abort et refait
		{
			print abort_sin
			abort $track_proc($server_name)($group_name)($x)($module+"_sin") 
		} 
		   $track_proc($server_name)($group_name)($x).insert(($module+"_sin"), ::sin_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t))                	
	   }
	}

	@fun_def sin_lfo_single($module, $num, $param, $r_low, $r_hi, $t) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

	if($track_proc($server_name)($group_name)($node_num).is_defined($module+"_sin")) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($group_name)($node_num)($module+"_sin") 
	} 
	   $track_proc($server_name)($group_name)($node_num).insert(($module+"_sin"), ::sin_lfo_proc_s($server_name, $group_id, $node_num, $param, $r_low, $r_hi, $t))                	
	}

	@fun_def sin_lfo_abort($module, $param)
	{
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			abort $track_proc($server_name)($group_name)($x)($module+"_sin")
		}
	}

	@fun_def sin_lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

		abort $track_proc($server_name)($group_name)($node_num)($module+"_sin")
	}


///// 

//($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo)
	@fun_def brown_lfo($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($group_name)($x).is_defined($module+"_brown")) // si ça existe abort et refait
		{
			print abort_sin
			abort $track_proc($server_name)($group_name)($x)($module+"_brown") 
		} 
		   $track_proc($server_name)($group_name)($x).insert(($module+"_brown"), ::brown_lfo_proc_s($server_name, $group_id, $x, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	   }
	}

	@fun_def brown_lfo_single($module, $num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

	if($track_proc($server_name)($group_name)($node_num).is_defined($module+"_brown")) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($group_name)($module+"_brown") 
	} 
	   $track_proc($server_name)($group_name)($node_num).insert(($module+"_brown"), ::brown_lfo_proc_s($server_name, $group_id, $node_num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	}

	@fun_def brown_lfo_abort($module, $param)
	{
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			abort $track_proc($server_name)($group_name)($x)($param+"_brown")
		}
	}

	@fun_def brown_lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

		abort $track_proc($server_name)($group_name)($node_num)($param+"_brown")
	}

	@fun_def rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo) 
	{ 
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($group_name)($x).is_defined($param+"_rand_lfo")) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)($x)($param+"_rand_lfo") 
		}
			$track_proc($server_name)($group_name)($x).add_pair(($param+"_rand_lfo"), ::rand_lfo_basic_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $tpo, $gui)) // instantie un le processus dans le dico

		}
	}


	@fun_def rand_lfo_single($module, $num, $param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($group_name)($module))
		if($track_proc($server_name)($group_name)($node_num).is_defined($param+"_rand_lfo")) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($group_name)($node_num)($param+"_rand_lfo") 
	}
		$track_proc($server_name)($group_name)($node_num).add_pair(($param+"_rand_lfo"), ::rand_lfo_basic_s($server_name, $group_id, $node_num, $param, $min, $max, $init_val, $type, $tpo))		
	}

	@fun_def rand_lfo_abort($module, $param)
	{
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
		{
			abort $track_proc($server_name)($group_name)($x)($param+"_rand_lfo") 
		}
	}

	@fun_def rand_lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

		abort $track_proc($server_name)($group_name)($node_num)($param+"_rand_lfo") 
	}

	@fun_def gui()
	{
		@local $addsynth := [], $tab_ids
		$tab_ids := $sc_struct($server_name)($group_id).drop(-1)
		$gui := true
		// TTracks8.new(track_name.asString, nil, group, bus, outsynth);
		print $tab_ids

		forall $x in $tab_ids
		{
			// print (""+($sc_struct($server_name)($group_id)($x)))
			// print (""+($sc_struct($server_name)($x)))
			$addsynth.push_back($x)
			$addsynth.push_back($sc_struct($server_name)($x)("_synth"))
			// $addsynth.push_back($sc_struct($server_name)($group_id)($x))
		}
		gui_antes $server_name $track_label $group_id $bus $node_id_out $addsynth

		// forall $k, $v in $track_proc($server_name)($group_name) // active envoie OSC vers GUI
		// {
		// 	if($v.size() > 0) // si la valeur contiens deja un proc avant creation GUI
		// 	{
		// 		$v.$gui := true // alors activer l'envoie par l'argument $gui (variable locale) 
		// 	}
		// }
	}
}

@obj_def mix_group_HOA($group_name, $server_name, $decoder, $order, $hoa_decoder = "sc-hoa", $ext_id = false, $offset = 0, $lev_name = "hrir_christophe_lebedev50")
{			
	@local $group_id, $bus, $hoa_rev_bus, $hoa_bus, $node_id_out, $addmod_index := 0, $HOABeamDirac2Hoa_id, $HOABeamHCard2Hoa_id, $hoa_num_ch, $num_ch := 2, $rec_map := map{}, $decoder_name, $struct_group_id, $struct_main_group_id
	@init 
    {

	if($SC_Servers($server_name).is_undef())
	{	
		print error server $server_name "does not exist"
	}
	else
	{
		if($SC_Groups($group_name).is_undef())
		{
			if($ext_id.is_numeric()) // externally defined node_id 
			{
				$group_id := $ext_id
			}
			else
			{
				$group_id := $SC_Servers($server_name)("node_id") // current node id for this server
			}

			if ($sc_struct($server_name).is_defined($group_id)) // if group_id exist on the program
			{
				print group_id (""+$sc_struct($server_name)($group_id))
				print node_id_out (""+$sc_struct($server_name)($group_id+1))
				$hoa_bus := $sc_struct($server_name)($group_id+1)("in")
			}
			else
			{
				$hoa_bus := $SC_Servers($server_name)("bus_index")
			}

			$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
			$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server + hoa_bus (4) + $hoa_rev_bus (4) 

			// $hoa_rev_bus := $bus+8
			
			$hoa_num_ch := ($order+1).pow(2) // HOA number of channels

			// print hoa_bus $hoa_bus
			// print group_id $group_id
			// print SERVER_server_name (""+$Servers($server_name))
			// print server_name $server_name

			$SC_Groups.insert($group_name, map{("server_name", $server_name)}) // creation du dico $group_name dans $SC_Groups

			$Servers($server_name).g_new($group_id, 0, 1)

			// scServer "g_new" $group_id 0 1 // add group to default group 1 of the $server_name

			//SuperNova
			// scServer "p_new" $group_id 0 1 // add group to default group 1 of the $server_name

			$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs

			$node_id_out := $SC_Servers($server_name)("node_id") // id for decoder synth

			// scServer "s_new" audioOut8 $node_id_out 1 $group_id in $bus out 0 index $bus in_ramp 0.001 amp 0
				
				// $sc_hoa_group1 := obj::mix_group_HOA("group_hoa1", "localhost", "HOA_Global_Lev_Dec", 3)
			switch ($decoder)
			{
				case "no_decoder":					
					// scServer "s_new" ("HOA_Hexa_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus
					switch($order)
					{
						case 5:
						$decoder_name := "audioOut36"
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0])
						$num_ch := 36
						case 6:
						$decoder_name := "audioOut49"
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0])
						$num_ch := 49							
						case 7:
						$decoder_name := "audioOut64"
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0])
						$num_ch := 64
					}

					case "binaural":
					// scServer "s_new" ("HOA_Global_Lev_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus
					$decoder_name := "HOA_Global_Lev_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0])
					print mix_group binaural ("s_new"+$server_name) $decoder_name $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 // in_rev $hoa_rev_bus
					$num_ch := 2

					case "Lebedev26":
					$decoder_name := "HOA_Global_Lev26_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "buf_num", $hrir_start_buffer])
					$num_ch := 2

					case "Lebedev50":
					print load hrir (""+$hrir_init_buf_map($server_name)($lev_name))	
					$num_ch := 2											 
					// print load hrir (""+$hrir_init_buf_map($server_name)($lev_name))	

					if(($hrir_init_buf_map($server_name)($lev_name)).is_undef())
					{
						print "load hrir buffers first"
					}
					else
					{
						$decoder_name := "HOA_Global_Lev50_Dec"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "hoa_buf_init", $hrir_init_buf_map($server_name)($lev_name)])
						// print ("HOA_Global_Lev50_Dec"+$order) $node_id_out 1 $group_id "in" $hoa_bus "out" 0 "in_ramp" 0.001 "amp" 0 "hoa_buf_init" (""+$hrir_init_buf_map($server_name)($lev_name))
						$num_ch := 2

					}

					case "hexa":					
					// scServer "s_new" ("HOA_Hexa_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus
					$decoder_name := "HOA_Hexa_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0])
					$num_ch := 6

					case "octo":
					// scServer "s_new" ("HOA_Octo_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 // in_rev $hoa_rev_bus
					$decoder_name := "HOA_Octo_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0])
					$num_ch := 8

					case "studio1":
					if($hoa_decoder == "sc-hoa")
					{
						// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
						$decoder_name := "HOA_Studio1_Dec"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
						$num_ch := 24	
					}
					case "dode":
					if($hoa_decoder == "sc-hoa")
					{
						// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
						$decoder_name := "HOA_Dode_Dec"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
						$num_ch := 12	
					}	
					case "vigie":
					if($hoa_decoder == "sc-hoa")
					{
						// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
						$decoder_name := "HOA_Vigie_Dec"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
						$num_ch := 26
					}	
					case "Espro":
					if($hoa_decoder == "sc-hoa")
					{
						// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
						$decoder_name := "HOA_Dec_ESPRO"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
						$num_ch := 75
					}						
					case "Pierre":
					if($hoa_decoder == "sc-hoa")
					{
						// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
						$decoder_name := "HOA_Dec_Pierre"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
						$num_ch := 22
					}
					case "SamplingDecoder":
					if($hoa_decoder == "sc-hoa")
					{
						// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
						$decoder_name := "HOA_Dec_AmbiDec"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
						$num_ch := 24
					}
					else
					{
						if($hoa_decoder == "ambitools")
						{
							// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
							$decoder_name := "HOAmbitools_Studio1_Dec"+$order
							$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
							$num_ch := 24	
						}
						else
						{
							if($hoa_decoder == "ambitools_noNFC")
							{
								$decoder_name := "HOAmbitools_Studio1_Dec"+$order+"_noNFC"
								$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
								$num_ch := 24	
							}
							else
							{
								if($hoa_decoder == "iem")
								{
									$decoder_name := "IEM_Dec"+$order
									$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
									$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "AllRADecoder", 1]) // 4 = UGen id inside Synthdef
									$num_ch := 24	
								}
							}
						}						
					}

					case "studio2":
					if($hoa_decoder == "sc-hoa")
					{
						// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
						$decoder_name := "HOA_Studio2_Dec"+$order
						$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
						$num_ch := 24	
					}
					else
					{
						print hacer!!!
					}
					case "CGP":
					// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
					$decoder_name := "HOA_CGP_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
					$num_ch := 27

					case "sat":
					// scServer "s_new" ("HOA_Studio1_Dec"+$order) $node_id_out 1 $group_id in $hoa_bus out 0 in_ramp 0.001 amp 0 //in_rev $hoa_rev_bus	
					$decoder_name := "HOA_SAT_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])
					$num_ch := 31

					case "iem":
					$decoder_name := "IEM_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "SimpleDecoder", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 24

					case "iem_AllRA":
					$decoder_name := "IEM_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "AllRADecoder", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 24

					case "iem_binaural":
					$decoder_name := "Binaural_VST_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", $offset, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "BinauralDecoder", 1, 0, 0]) // 4 = UGen id inside Synthdef
				
					$num_ch := 2

					case "iem_adaptivebinaural":
					$decoder_name := "Binaural_VST_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "AdaptiveBinauralDecoder", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 2	

					case "harpex":
					$decoder_name := "Binaural_VST_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "Harpex-X", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 2

					case "sparta_ambibin":
					$decoder_name := "Binaural_VST_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "sparta_ambiBIN", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 2

					case "compass_binaural":
					$decoder_name := "Binaural_VST_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "compass_binaural", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 2
					
					case "sparta_ambidec":
					$decoder_name := "IEM_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "sparta_ambiDEC", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 24					

					case "a7monitor":
					$decoder_name := "Binaural_VST_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "a7Monitor.vst3", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 2

					case "Ambi Head HD":
					$decoder_name := "Binaural_VST_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "Ambi Head HD", 1]) // 4 = UGen id inside Synthdef
					$num_ch := 2

					case "no_decoder":
					$decoder_name := "IEM_Dec"+$order
					$Servers($server_name).s_new([$decoder_name, $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					$Servers($server_name).u_cmd([$node_id_out, 4, "/open", "sparta_ambiDEC", 1]) // 4 = UGen id inside Synthdef
					
				    $Servers($server_name).s_new(["HOA_Out_"+$order, $node_id_out, 1, $group_id, "in", $hoa_bus, "globTBus", 0, "in_ramp", $fade_in, "amp", $amp])	// "globTBus" = 0 send HOA stream directly to audio card			   				    	
				    $num_ch := $hoa_num_ch 
					// case $vst_all_map.is_defined($decoder):
					// $Servers($server_name).s_new([("Binaural_VST_Dec"+$order), $node_id_out, 1, $group_id, "in", $hoa_bus, "out", 0, "in_ramp", 0.001, "amp", 0, "index", $group_id])  //target 2 justo despues del nodo 180 audioOut
					// if($vst_all_map($decoder)("sdkversion")[4] == "3") // pour VST3
					// {
				 //    	$decoder := $decoder+".vst3"
				 //    	print vst_module $decoder
				 //    }
				 //    else
				 //    {
				 //    	$decoder := $decoder
				 //    	print vst_module $decoder
				 //    }
					// $Servers($server_name).u_cmd([$node_id_out, 4, "/open", $decoder, 1]) // 4 = UGen id inside Synthdef
					// $num_ch := 2											

			   }

			   print group_id $group_id

			// print ATKGlobalFOA_Trans_Rev $node_id_out 1 $group_id in $hoa_bus in_rev $hoa_rev_bus out 0 in_ramp 0.001 amp 0

			// $node_id := $node_id + 1 // incremente le node_id
			$SC_Servers($server_name).add_pair("node_id", $node_id_out + 1)
			$SC_Servers($server_name).insert("bus_index", $hoa_bus + ($order+1).pow(2)) // inc bus de server + hoa_bus (4) + $hoa_rev_bus (4) 

			// $SC_Servers($server_name).insert("bus_index", $bus+8+$hoa_bus) // inc bus de server + hoa_bus (4) + $hoa_rev_bus (4) 

			// update dictionaires
			$groups.add_pair($group_name, $THISOBJ) // put this group object in dico $group
			$SC_Groups($group_name).insert("name", $group_name)
			$SC_Groups($group_name).insert("main_group_id", $group_id)
			$SC_Groups($group_name).insert("main_bus", $bus)
			$SC_Groups($group_name).insert("hoa_bus", $hoa_bus)
			// $SC_Groups($group_name).insert("hoa_rev_bus", $hoa_rev_bus)
			$SC_Groups($group_name).insert("order", $order)
			$SC_Groups($group_name).insert("decoder_id", $node_id_out)
			$SC_Groups($group_name).insert("sub_group", map{}) // for store the sub group object 
			$SC_Groups($group_name).insert("aux_sub_group", map{}) // for store the sub aux group object 

			// creation des dictionaires de synth et proc dans un mix group
			$synths_map($server_name).insert($group_name, map{})
			$track_proc($server_name).insert($group_name, map{})
			$vst_plugins($server_name).insert($group_name, map{})
			$space_group($server_name).add_pair($group_name, map{})
			$space_group($server_name)($group_name).add_pair("val", map{})
			$space_group($server_name)($group_name).add_pair("xyz_offset", [0, 0, 0]) //oF visualisation
			$group_proc($server_name).add_pair($group_name, map{})


			// creation des dictionaires structure generale des nodes
			$struct_main_group_id := $sc_struct($server_name)(1)("default_group")
			if ($sc_struct($server_name)($group_id).is_undef()) // if group_id exist on the program
			{
				$struct_main_group_id.push_back($group_id) // default group 1 -> [group_id]
				$sc_struct($server_name).add_pair($group_id, [[$node_id_out], $group_name]) // crea nueva key group + decoder
				$struct_group_id := $sc_struct($server_name)($group_id)[0]
				$sc_struct($server_name).add_pair($node_id_out, map{("decoder", $decoder), ("order", $order), ("in", $hoa_bus), ("out", 0), ("index", $group_id), ("in_ramp", 0.001), ("amp", 0)}) // , ("in_rev", $hoa_rev_bus) crea MAP para nombre_synth + parametros
			}
			print new "group" $group_name created in server $server_name

			groups_max $group_id $group_name $server_name
		}
		else // add group to specific server g_new
		{
				print "group" $group_name already exists
		}
	}
    }
	 
   @fun_def mod_add($module, $action = "before_out", $target_mod = <undef>, $fade_in = 0.01)
   {
	@local $addmod_index := 0, $params, $node_id_mod, $target_id, $mod_name, $json_file, $json_map, $vst_module

	// $fade_in_mod := 0.01 // deberia ser un argumento opcional!!
	// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
	// print modulos $module
    // print groupo $group_id
    // print node_id $node_id
    $node_id_mod := $SC_Servers($server_name)("node_id") // recupère dernier node_id
    
    if($target_mod.is_undef())
    {
	 $target_mod := $node_id_out
    }

    $target_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $target_id
    print target_id target_id target_id $target_id

    // print (""+$synths_map("localhost")("group_hoa1"))						
				  // $synths_map($server_name)($group_name).insert($mod_name, [$node_id_mod])
    // print size ($module.dim())
    // print params $params
    if ($module.dim() > 1 && $module.car().is_tab()){ // si c'est tab multi
    print MULTI_VST
	forall $chain in $module // s'il y a plus des modules
	{
		// $node_id_mod := $SC_Servers($server_name)("node_id") // recupère node_id
		// print $chain
		$mod_name := $chain.car()
			if($vst_all_map.is_defined($mod_name)) // Si module = VST, chager VST PlugIns
		{
		// if($chain[0] == "VST")
		// {
			print load VSTPlugIns $mod_name
			// $vst_module := $chain[1] // VST module name
			// $mod_name := ($chain[0]+"_"+$vst_module)
			// $mod_name := $vst_module
			// if($vst_all_map.is_defined($vst_module))
			// {

			if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
			    {
				$vst_module := $mod_name+".vst3"
				print vst_module $vst_module
			    }
			    else
			    {
				$vst_module := $mod_name
				print vst_module $vst_module
			    }	
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_mod, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 3, $target_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])
						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])		   		
						case "top":
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 0, $group_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])
					}
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
				$vst_plugins($server_name)($group_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins
			// }
			// else
			// {
			// 	print vst $vst_module does not exist
			// }
		}
		else
		{
			
			$params := $chain.cdr()
				// scServer "s_new" ($chain[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in].concat($params))
					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in].concat($params))		   		
					case "top":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in].concat($params))
				}
			}

			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $hoa_bus), ("out", $hoa_bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($track_label)($mix_group)($mod_name))

			if(($synths_map($server_name)($group_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($mod_name) is not member at $node_id_mod
				$synths_map($server_name)($group_name).insert($mod_name, [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
			}else 
			{
				// print ($mod_name) is member at $node_id_mod
				$synths_map($server_name)($group_name)($mod_name).push_back($node_id_mod) // si existe rajouter a la TAB

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1) // incremente node_id
		$node_id_mod := $SC_Servers($server_name)("node_id")


		}
		}
		else
		{
			if($module.is_tab()) // si c'est tab 1 dim
			{
				 print solo_TAB_VST
				$mod_name := $module.car()
				// if($mod_name == "VST") // if VST plugins
			// {
				if($vst_all_map.is_defined($mod_name)) // Si module = VST, chager VST PlugIns
				{		    		
				// $vst_module := $module[1] // VST module name
				// $mod_name := $vst_module
				print node_id_mod $node_id_mod
		   //  		if($vst_all_map.is_defined($vst_module))
					// {
					if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
				    {
					$vst_module := $mod_name+".vst3"
					print vst_module $vst_module
				    }
				    else
				    {
					$vst_module := $mod_name
					print vst_module $vst_module
				    }
					switch ($action)
					{
						case "before_out":
							$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_mod, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
							case "after":
							// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
							$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 3, $target_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])
							case "before":
							// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
							$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])		   		
							case "top":
							$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 0, $group_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])
						}
					$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
					$vst_plugins($server_name)($group_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins
					// }
					// else
					// {
					// 	print vst $vst_module does not exist
					// }
			}	   		
			else
			{		    		
					// $node_id_mod := $SC_Servers($server_name)("node_id") // recupère node_id
					$params := $module.cdr()
					$mod_name := $module[0]
					// print $params
					if($params.car() == "preset"){
						@local $params_preset, $par_init, $inc := 0

						$json_file := $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"

						$json_file := @json_read($json_file)
						// print JSON (""+$json_file($mod_name)($params[1]))

						$params_preset := $json_file($mod_name)($params[1]) // recupere la map du preset
						if($params_preset.is_undef())
						{
							print "this preset does not exist"
						}
						else
						{
							$par_init := $params.drop(2)

							loop 
							{
								$params_preset.add_pair($par_init[$inc], $par_init[$inc+1]) // replace parameters after 
								$inc += 2
							} until ($inc==$par_init.size())

							$params := $params_preset.map2tab() // convert map to tab
						}
					}
									
					// scServer "s_new" ($module[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
					// $synths_map($server_name)($mix_group)($track_label).insert($module[0], $node_id_mod)
				switch ($action)
					{
					case "before_out":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in].concat($params))
						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in].concat($params))		   		
						case "top":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in].concat($params))
					}		
				}   	
				$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $hoa_bus), ("globTBus", $hoa_bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($group_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($mod_name) is not member at $node_id_mod
					$synths_map($server_name)($group_name).insert($mod_name, [$node_id_mod])
				}else 
				{
					// print ($mod_name) is member at $node_id_mod
					$synths_map($server_name)($group_name)($mod_name).push_back($node_id_mod)

				}
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))
				
				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
			else // modulo sin parametro
			{
				print modulo sin parametro
				// $node_id_mod := $SC_Servers($server_name)("node_id") // recupère node_id

				// scServer "s_new" ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				// $synths_map($server_name)($mix_group)($track_label).insert($module, $node_id_mod)
			// $mod_name := $module
			if($vst_all_map.is_defined($module))
				{	    		
				
					// $vst_module := $mod_name // VST module name	    		

				// $mod_name := $vst_module

		   //  		if($vst_all_map.is_defined($vst_module))
					// {
					if($vst_all_map($module)("sdkversion")[4] == "3") // pour VST3
				    {
					$vst_module := $module+".vst3"
					print vst_module $vst_module
				    }
				    else
				    {
					$vst_module := $module
					print vst_module $vst_module
				    }
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_mod, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 3, $target_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])
						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])		   		
						case "top":
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 0, $group_id, "in", $hoa_bus, "globTBus", $hoa_bus, "matrix_ramp", $fade_in])
					}
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
				$vst_plugins($server_name)($group_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins
					// }
					// else
					// {
					// 	print vst $vst_module does not exist
					// }
			}	
			else
			{
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])
						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])		   		
						case "top":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $hoa_bus, "out", $hoa_bus, "matrix_ramp", $fade_in])
					}			
				}	

				$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $hoa_bus), ("out", $hoa_bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($group_name).insert($node_id_mod, map{}) // dictionaire pour les processus
					
				if(($synths_map($server_name)($group_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($mod_name) is not member at $node_id_mod
					// ($synths_map($server_name)($group_name).insert($mod_name, [$node_id_mod])).post()
					$synths_map($server_name)($group_name).insert($mod_name, [$node_id_mod])
				}else 
				{
					// print ($mod_name) is member at $node_id_mod
					$synths_map($server_name)($group_name)($mod_name).push_back($node_id_mod)

				}

				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}

   @fun_def mod_replace($module_old, $module_new, $cross_fade = 1)
   {
		$THISOBJ.mod_remove($module_old, $cross_fade)
		$THISOBJ.mod_add($module_new, fade_in = $cross_fade)
   }

	@proc_def connect_aux($track_out, $aux_in, $amp = 0, $fade_in = 1)
	{
		@local $id, $target_id, $track_bus_out, $bus_aux_in
		$id := $SC_Servers($server_name)("node_id")
		$target_id := $SC_Groups($group_name)("sub_group")($track_out).$node_id_out
		$track_bus_out := $SC_Groups($group_name)("sub_group")($track_out).$bus
		$bus_aux_in := $SC_Groups($group_name)("sub_group")($aux_in).$bus

		$Servers($server_name).s_new(["AudioAuxIn", $id, 2, $target_id, "in", $track_bus_out, "out", $bus_aux_in, "in_ramp", $fade_in, "amp", $amp])
		$SC_Servers($server_name).add_pair("node_id", $id + 1)
	}

	/// HOA Convolution Reverb
	@fun_def HOA_ConvRev($bufname, $ampli)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_add(["HOA_Global_ConvRev_Dec"+$order, "bufnum", $ir_buf($server_name)($bufname), "amp", $ampli])
		print ir_buf ($ir_buf($server_name)($bufname))
	}

	@fun_def HOA_ConvRev_amp($ampli)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.set("HOA_Global_ConvRev_Dec"+$order, ["amp", $ampli])
		// print ir_buf ($ir_buf($server_name)($bufname))
	}	

	@fun_def HOA_ConvRev_replace($bufname, $ampli = 0, $cross_fade = 1)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_replace("HOA_Global_ConvRev_Dec"+$order, ["HOA_Global_ConvRev_Dec"+$order, "bufnum", $ir_buf($server_name)($bufname), "amp", $ampli], $cross_fade)
		
	}

	@fun_def HOA_ConvRev_free($fade_out)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_remove("HOA_Global_ConvRev_Dec"+$order, $fade_out)
		
	}

	/// HOA TRANSFORM

	@fun_def HOA_mirror()
	{
		// @local $mirror_node
		$mirror_node := $SC_Servers($server_name)("node_id") // last id

		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$Servers($server_name).s_new(["HOA_Global_Mirror_ord"+$order, $mirror_node, 2, $node_id_out, "in", $hoa_bus, "out", $hoa_bus])
		
		$SC_Servers($server_name).add_pair("node_id", $mirror_node + 1) // increment node_i

	}  	

	@fun_def HOA_mirror_front_back($front_back)
	{
		$Servers($server_name).n_set($mirror_node, ["front_back", $front_back])
	}

	@fun_def HOA_mirror_left_right($left_right)
	{
		$Servers($server_name).n_set($mirror_node, ["left_right", $left_right])
	}

	@fun_def HOA_mirror_up_down($up_down)
	{
		$Servers($server_name).n_set($mirror_node, ["up_down", $up_down])
	}

	@fun_def HOA_mirror_free($fade_out)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_remove($mirror_node, $fade_out)		
	}


	@fun_def HOA_az_rotator()
	{
		// @local $az_rotator
		$az_rotator := $SC_Servers($server_name)("node_id") // last id

		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$Servers($server_name).s_new(["HOA_Global_Rot_azi_ord"+$order, $az_rotator, 2, $node_id_out, "in", $hoa_bus, "out", $hoa_bus])
		
		$SC_Servers($server_name).add_pair("node_id", $az_rotator + 1) // increment node_i
	}

	@fun_def HOA_az_rotator_AZ($az)
	{
		$Servers($server_name).n_set($az_rotator, ["az", @ang2rad($az)])
	}

	@fun_def HOA_az_rotator_AZ_free($fade_out)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_remove($az_rotator, $fade_out)		
	}

	@fun_def HOA_xyz_rotator()
	{
		// @local $xyz_rotator
		$xyz_rotator := $SC_Servers($server_name)("node_id") // last id

		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$Servers($server_name).s_new(["HOA_Global_Rot_xyz_ord"+$order, $xyz_rotator, 2, $node_id_out, "in", $hoa_bus, "out", $hoa_bus])

		$SC_Servers($server_name).add_pair("node_id", $xyz_rotator + 1) // increment node_i
	}

	@fun_def HOA_xyz_rotator_pitch($pitch)
	{
		$Servers($server_name).n_set($xyz_rotator, ["pitch", @ang2rad($pitch)])
	}

	@fun_def HOA_xyz_rotator_roll($roll)
	{
		$Servers($server_name).n_set($xyz_rotator, ["roll", @ang2rad($roll)])
	}

	@fun_def HOA_xyz_rotator_yaw($yaw)
	{
		$Servers($server_name).n_set($xyz_rotator, ["yaw", @ang2rad($yaw)])
	}

	@fun_def HOA_xyz_rotator_pitchrollyaw($pitch, $roll, $yaw)
	{
		$Servers($server_name).n_set($xyz_rotator, ["pitch", @ang2rad($pitch), "roll", @ang2rad($roll), "yaw", @ang2rad($yaw)])
	}	

	@fun_def HOA_xyz_rotator_free($fade_out)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_remove($xyz_rotator, $fade_out)		
	}

	/// HOA FILTERS

	/////// HOABeamDirac2Hoa
	@fun_def HOABeamDirac2Hoa() // add BeamDirac2Hoa HOA FILTER
	{
		// @local $node_id_mod

		$HOABeamDirac2Hoa_id := $SC_Servers($server_name)("node_id") // last id

		// scServer "s_new" ("HOA_Filter_HOABeamDirac2Hoa"+$order) $HOABeamDirac2Hoa_id 2 $node_id_out in $hoa_bus out $hoa_bus
		$Servers($server_name).s_new(["HOA_Filter_HOABeamDirac2Hoa"+$order, $HOABeamDirac2Hoa_id, 2, $node_id_out, "in", $hoa_bus, "out", $hoa_bus])

		$SC_Servers($server_name).add_pair("node_id", $HOABeamDirac2Hoa_id + 1) // increment node_i
	}

	@fun_def HOABeamDirac2Hoa_off($fade_out) // kill module
	{
		// scServer "n_set" $HOABeamDirac2Hoa_id matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($HOABeamDirac2Hoa_id, ["matrix_ramp", $fade_out, "free", 0])
	}
	
	@fun_def HOABeamDirac_az($az)
	{
		// scServer "n_set" $HOABeamDirac2Hoa_id az ($az.ang2rad())
		$Servers($server_name).n_set($HOABeamDirac2Hoa_id, ["az", $az.ang2rad()])
	}

	@fun_def HOABeamDirac_ele($ele)
	{
		// scServer "n_set" $HOABeamDirac2Hoa_id ele ($ele.ang2rad())
		$Servers($server_name).n_set($HOABeamDirac2Hoa_id, ["ele", $ele.ang2rad()])
	}
 

	////// HOABeamHCard2Hoa

	@fun_def HOABeamHCard2Hoa() // add BeamDirac2Hoa HOA FILTER
	{
		// @local $node_id_mod
		if($order>=4)
		{
			print "this order is not implemented"
		}else{

			$HOABeamHCard2Hoa_id := $SC_Servers($server_name)("node_id") // last id

			// scServer "s_new" ("HOA_Filter_HOABeamHCard2Hoa"+$order) $HOABeamHCard2Hoa_id 2 $node_id_out in $hoa_bus out $hoa_bus
			$Servers($server_name).s_new(["HOA_Filter_HOABeamHCard2Hoa"+$order, $HOABeamHCard2Hoa_id, 2, $node_id_out, "in", $hoa_bus, "out", $hoa_bus])

			$SC_Servers($server_name).add_pair("node_id", $HOABeamHCard2Hoa_id + 1) // increment node_i
		}
	}

	@fun_def HOABeamHCard2Hoa_off($fade_out) // kill module
	{
		// scServer "n_set" $HOABeamHCard2Hoa_id matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($HOABeamHCard2Hoa_id, ["matrix_ramp", $fade_out, "free", 0])
	}
	
	@fun_def HOABeamHCard2Hoa_az($az)
	{
		// scServer "n_set" $HOABeamHCard2Hoa_id az ($az.ang2rad())
		$Servers($server_name).n_set($HOABeamHCard2Hoa_id, ["az", $az.ang2rad()])
	}

	@fun_def HOABeamHCard2Hoa_ele($ele)
	{
		// scServer "n_set" $HOABeamHCard2Hoa_id ele ($ele.ang2rad())
		$Servers($server_name).n_set($HOABeamHCard2Hoa_id, ["ele", $ele.ang2rad()])
	}

	@fun_def HOABeamHCard2Hoa_cardOrder($cardOrder)
	{
		// scServer "n_set" $HOABeamHCard2Hoa_id cardOrder $cardOrder
		$Servers($server_name).n_set($HOABeamHCard2Hoa_id, ["cardOrder", $cardOrder])
	}



	@proc_def group_ambi_translation($pos_xyz) // control all instances of HOA_Encode in the group
    {
		$Servers($server_name).n_set($group_id, ["xoffset", $pos_xyz[0], "yoffset", $pos_xyz[1], "zoffset", $pos_xyz[2]]) // send directly to SCServer
		$space_group($server_name)($group_name).add_pair("xyz_offset", $pos_xyz) // store xyz position in map for oFx visualization
		print group_name $group_name
		video ($pos_xyz) 
    }


	@proc_def group_ambi_translation_x($pos_x)
	{
		@local $nim, $lpos, $last_bpf_pos_x_curve

		if($group_proc($server_name)($group_name).is_defined("x_trans"))
		{
			abort $group_proc($server_name)($group_name)("x_trans") // to avoid interferences
		}

		if($space_group($server_name)($group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$THISOBJ.group_ambi_translation([0, 0, 0]) // create dico
		}
		// abort $last_bpf_pos_x_curve // to avoid interferences
		if($pos_x.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($pos_x)
			// .CheckParam($module, $param, $MYSELF)
			$lpos := $pos_x[0]
			$last_bpf_pos_x_curve := { curve @grain := 0.01, 
				@action 
				{
						$Servers($server_name).n_set($group_id, ["xoffset", $lpos]) // send directly to SCServer group
						let $space_group($server_name)($group_name)("xyz_offset")[0] := $lpos // store xyz position in map for oFx visualization
				} 
				{ $lpos : $nim }
			}
			$group_proc($server_name)($group_name).add_pair("x_trans", $last_bpf_pos_x_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($group_id, ["xoffset", $pos_x]) // send directly to SCServer
			let $space_group($server_name)($group_name)("xyz_offset")[0] := $pos_x // store xyz position in map for oFx visualization
		}
	}


	@proc_def group_ambi_translation_y($pos_y)
	{
		@local $nim, $lpos, $last_bpf_pos_y_curve
		// abort $last_bpf_pos_y_curve // to avoid interferences
		if($group_proc($server_name)($group_name).is_defined("y_trans"))
		{
			abort $group_proc($server_name)($group_name)("y_trans") // to avoid interferences
		}

		if($space_group($server_name)($group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$THISOBJ.group_ambi_translation([0, 0, 0]) // create dico
		}
		if($pos_y.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($pos_y)
			// .CheckParam($module, $param, $MYSELF)
			$lpos := $pos_y[0]
			$last_bpf_pos_y_curve := { curve @grain := 0.01, 
				@action 
				{
						$Servers($server_name).n_set($group_id, ["yoffset", $lpos]) // send directly to SCServer group
						let $space_group($server_name)($group_name)("xyz_offset")[1] := $lpos // store xyz position in map for oFx visualization

				} 
				{ $lpos : $nim }
			}
			$group_proc($server_name)($group_name).add_pair("y_trans", $last_bpf_pos_y_curve) // store curve in map to avoid interference between different groups

		}
		else
		{
			$Servers($server_name).n_set($group_id, ["yoffset", $pos_y]) // send directly to SCServer
			let $space_group($server_name)($group_name)("xyz_offset")[1] := $pos_y // store xyz position in map for oFx visualization
		}
	}


	@proc_def group_ambi_translation_z($pos_z)
	{
		@local $nim, $lpos, $last_bpf_pos_z_curve
		// abort $last_bpf_pos_z_curve // to avoid interferences
		if($group_proc($server_name)($group_name).is_defined("z_trans"))
		{
			abort $group_proc($server_name)($group_name)("z_trans") // to avoid interferences
		}
		if($space_group($server_name)($group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$THISOBJ.group_ambi_translation([0, 0, 0]) // create dico
		}
		if($pos_z.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($pos_z)
			// .CheckParam($module, $param, $MYSELF)
			$lpos := $pos_z[0]
			$last_bpf_pos_z_curve := { curve @grain := 0.01, 
				@action 
				{
						$Servers($server_name).n_set($group_id, ["zoffset", $lpos]) // send directly to SCServer group
						let $space_group($server_name)($group_name)("xyz_offset")[2] := $lpos // store xyz position in map for oFx visualization

				} 
				{ $lpos : $nim }
			}
			$group_proc($server_name)($group_name).add_pair("z_trans", $last_bpf_pos_z_curve) // store curve in map to avoid interference between different groups

		}
		else
		{
			$Servers($server_name).n_set($group_id, ["zoffset", $pos_z]) // send directly to SCServer
			let $space_group($server_name)($group_name)("xyz_offset")[2] := $pos_z // store xyz position in map for oFx visualization
		}
	}

	@fun_def group_ambi_translation_x_rand_lfo($min, $max, $init_val, $tpo, $type = "linear") 
	{ 
		
		if($group_proc($server_name)($group_name).is_defined("x_trans"))
		{
			abort $group_proc($server_name)($group_name)("x_trans") // to avoid interferences
		}
		if($space_group($server_name)($group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$THISOBJ.group_ambi_translation([0, 0, 0]) // create dico
		}
		$group_proc($server_name)($group_name).add_pair("x_trans", ::rand_lfo_basic_pos_x($server_name, $group_id, $group_name, $min, $max, $init_val, $tpo, $type)) // instantie un le processus dans le dico
	}


	@fun_def group_ambi_translation_y_rand_lfo($min, $max, $init_val, $tpo, $type = "linear") 
	{ 
		
		if($group_proc($server_name)($group_name).is_defined("y_trans"))
		{
			abort $group_proc($server_name)($group_name)("y_trans") // to avoid interferences
		}
		if($space_group($server_name)($group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$THISOBJ.group_ambi_translation([0, 0, 0]) // create dico
		}
		$group_proc($server_name)($group_name).add_pair("y_trans", ::rand_lfo_basic_pos_y($server_name, $group_id, $group_name, $min, $max, $init_val, $tpo, $type)) // instantie un le processus dans le dico
	}


	@fun_def group_ambi_translation_z_rand_lfo($min, $max, $init_val, $tpo, $type = "linear") 
	{ 
		
		if($group_proc($server_name)($group_name).is_defined("z_trans"))
		{
			abort $group_proc($server_name)($group_name)("z_trans") // to avoid interferences
		}
		if($space_group($server_name)($group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$THISOBJ.group_ambi_translation([0, 0, 0]) // create dico
		}
		$group_proc($server_name)($group_name).add_pair("z_trans", ::rand_lfo_basic_pos_z($server_name, $group_id, $group_name, $min, $max, $init_val, $tpo, $type)) // instantie un le processus dans le dico
	}

	@fun_def group_ambi_translation_x_rand_lfo_abort()
	{
		abort $group_proc($server_name)($group_name)("x_trans")
		print "abort" group_ambi_translation_x_rand_lfo
	}

	@fun_def group_ambi_translation_y_rand_lfo_abort()
	{
		abort $group_proc($server_name)($group_name)("y_trans")
		print "abort" group_ambi_translation_y_rand_lfo
	}

	@fun_def group_ambi_translation_z_rand_lfo_abort()
	{
		abort $group_proc($server_name)($group_name)("z_trans")
		print "abort" group_ambi_translation_z_rand_lfo
	}


	@proc_def group_ambi_rand_lfo_sphere_radio_fac($fac) // control all instances of HOA_Encode in the group
    {
		// $Servers($server_name).n_set($group_id, ["zoffset", $pos_z]) // send directly to SCServer
		// $space_group($server_name)($group_name).add_pair("xyz_offset", $pos_xyz) // store xyz position in map for oFx visualization
		forall $k, $v in $track_proc($server_name)($group_name)
		{
			print "k"  $k
			print "v"  (""+$v)
			print proc (""+$v("ambi_rand_lfo_sphere"))
			// let $v("ambi_rand_lfo_sphere").$radio := ($v("ambi_rand_lfo_sphere").$radio*$fac)
			let $v("ambi_rand_lfo_sphere").$radio_fac := $fac

			// forall $id, $proc in $v
			// {
			// 	print "proc"  (""+$proc)
			// }
			
		}

		// ("ambi_rand_lfo_sphere") 
		// print group_name_z $group_name
		// video ($pos_xyz) 
    }

	@proc_def group_ambi_rand_lfo_sphere_temp_fac($fac) // control all instances of HOA_Encode in the group
    {
		// $Servers($server_name).n_set($group_id, ["zoffset", $pos_z]) // send directly to SCServer
		// $space_group($server_name)($group_name).add_pair("xyz_offset", $pos_xyz) // store xyz position in map for oFx visualization
		forall $k, $v in $track_proc($server_name)($group_name)
		{
			let $v("ambi_rand_lfo_sphere").$tempo_fac := $fac
		}
    }

	@proc_def group_ambi_doppler($dop) // control SC group control (all instances that match doppler)
    {

		$Servers($server_name).n_set($group_id, ["dopon", $dop]) // send to main group 	
    }

    // @fun_def amp($amp)
    // {
    // 	$Servers($server_name).n_set($node_id_out, ["amp", $amp])

    // 	print $node_id_out "amp" $amp
    // }

	@proc_def amp($amp)
	{
		@local $nim, $lamp, $last_bpf_amp_curve

		if($group_proc($server_name)($group_name).is_defined("amp"))
		{
			abort $group_proc($server_name)($group_name)("amp") // to avoid interferences
		}		
		// abort $last_bpf_amp_curve // to avoid interferences

		if($amp.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($amp)
			// .CheckParam($module, $param, $MYSELF)
			$lamp := $amp[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["amp", $lamp])	
				} 
				{ $lamp : $nim }
			}
		$group_proc($server_name)($group_name).add_pair("amp", $last_bpf_amp_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["amp", $amp])
		}
	}


    @proc_def pause() // no time for the moment
	{
		// scServer "n_set" $node_id_out amp -120
		$Servers($server_name).n_set($node_id_out, ["amp", -120])

		0.01s $Servers($server_name).n_run($group_id, 0)
		// scServer "n_run" $group_id 0 // stop running the entire group after 0.01s to avoid clicks
		 // matrix_ramp @dur2sec($time) gate 0
		// @dur2sec($time) n_set $group_id gate 0
	}

	@proc_def resume() // no time for the moment
	{	
		// scServer "n_run" $group_id 1 // start running the entire group
		$Servers($server_name).n_run($group_id, 1)
		$Servers($server_name).n_set($node_id_out, ["amp", 0])

		// scServer "n_set" $node_id_out amp 0
	}

	@fun_def record($name, $headerFormat = "aiff", $sampleFormat = "int24", $num_frames = 65536, $fade_in = 0.1, $start_frame = 0, $leave_file_open = 1)
	{
		@local $buff_id, $rec_node

		$buff_id := $SC_Servers($server_name)("buffer_id")
		$rec_node := $SC_Servers($server_name)("node_id") // last id
		$rec_map.add_pair($name, [$buff_id, $rec_node]) // store buf_id and node_id
		print rec_mix_group_start $rec_node
		
		$Servers($server_name).b_alloc($buff_id, $num_frames, $num_ch) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, 0, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open


		$Servers($server_name).s_new(["Diskout_"+$num_ch, $rec_node, 3, $node_id_out, "in", 0, "bufnum", $buff_id, "in_ramp", $fade_in]) // "in", 0 start from bus 0 (output)
		

		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
		$SC_Servers($server_name).add_pair("node_id", $rec_node + 1)

	}

	@fun_def record_hoa($name, $headerFormat = "aiff", $sampleFormat = "int24", $num_frames = 65536, $fade_in = 0.1, $start_frame = 0, $leave_file_open = 1)
	{
		@local $buff_id, $rec_node

		$buff_id := $SC_Servers($server_name)("buffer_id")
		$rec_node := $SC_Servers($server_name)("node_id") // last id
		$rec_map.add_pair($name, [$buff_id, $rec_node]) // store buf_id and node_id
		print rec_mix_group_start $rec_node
		
		$Servers($server_name).b_alloc($buff_id, $num_frames, $hoa_num_ch) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, 0, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open


		$Servers($server_name).s_new(["Diskout_hoa_"+$order, $rec_node, 2, $node_id_out, "in", $hoa_bus, "bufnum", $buff_id, "in_ramp", $fade_in])
		

		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
		$SC_Servers($server_name).add_pair("node_id", $rec_node + 1)

	}

	@proc_def stop_record($name, $fade_out = 0.1)
	{
		@local $buff_id, $rec_node			
		// print rec_node_stop

		$buff_id := $rec_map($name)[0]
		$rec_node := $rec_map($name)[1]
		print rec_node_stop $rec_node

		$Servers($server_name).n_set($rec_node, ["out_ramp", @dur2sec($fade_out), "free", 0]) // stop recording

		$fade_out $Servers($server_name).b_free($buff_id) // close the file.

	}	

	@proc_def add_descriptors($name, $descriptors, $host = "localhost", $port = 8765)
	{
		@local $descp_node_id

		oscsend osc_send_descriptors @global $host : $port ("/"+$name)
		
		$descp_node_id := $SC_Servers($server_name)("node_id") // last id

		if($decriptors_map.is_defined($name))
		{
			print is defined 

			forall $desc in $descriptors
			{
				@local $local_id, $params := [], $desc_id

				if($desc.size()>1)
				{
					$params := $desc.cdr()
				}

				if($decriptors_map($name).is_defined($desc[0])) // if exist look for parameters
				{
					$local_id := $decriptors_map($name)($desc[0])

					print is defined $local_id

					$Servers($server_name).n_set($local_id, $params) // change descriptors parameters
				}
				else // if doesn't exist create new descriptor
				{
					$desc_id := $descp_node_id
					whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
					{			
						// print receive_descript (""+$descriptors_receives)
						osc_send_descriptors ([$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor values
					}
					
					if($desc.size()>1)
					{
						$params := $desc.cdr()
					}
					$Servers($server_name).s_new([$desc[0]+"_Replay", $descp_node_id, 3, $node_id_out, "in", $bus, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
					$decriptors_map($name).add_pair($desc[0], $descp_node_id)
					$descp_node_id += 1
					$SC_Servers($server_name).add_pair("node_id", $descp_node_id)
				}
			}
		}
		else
		{
			print not defined
			$decriptors_map.add_pair($name, map{}) // dico for descriptors

			
			// oscsend recbufaux "localhost" :7002 "/recbufaux"
			forall $desc in $descriptors
			{
				@local $desc_id, $params := []
				$desc_id := $descp_node_id
				print descriptors_start $descp_node_id
				print (""+$desc)

				whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
				{			
					// print receive_descript (""+$descriptors_receives)
					osc_send_descriptors ([$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor values
				}
				
				if($desc.size()>1)
				{
					$params := $desc.cdr()
				}
				$Servers($server_name).s_new([$desc[0]+"_Replay", $descp_node_id, 3, $node_id_out, "in", $bus, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
				$decriptors_map($name).add_pair($desc[0], $descp_node_id)
				$descp_node_id += 1
				$SC_Servers($server_name).add_pair("node_id", $descp_node_id)
			}
		}	

	}


	@fun_def remove_descriptors($name, $descriptors = [])
	{
		// @local $descp_node_id
		print (""+$decriptors_map($name))
		if($descriptors.size()>0) // remove only $descriptors
		{
			forall $desc in $descriptors
			{
				$Servers($server_name).n_set($decriptors_map($name)($desc), ["free", 0]) // free node
				$decriptors_map($name).remove($desc)
			}

		}
		else // remove all descriptors
		{
			forall $k,$desc_id in $decriptors_map($name)
			{
				print descriptors_stop $desc_id
				$Servers($server_name).n_set($desc_id, ["free", 0]) // free node
			}

			$decriptors_map.remove($name)
		}
	}

	@fun_def set($module, $params)
	{
		@local $vst_nodeID, $vst_param_index, $loop_index := 0, $vst_params_tab := []
		// print scServer "n_set" $module $params
		// print scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)) $params
		// if($module.is_tab())
		// {
		// 	if($module[0] == "VST") // ["VST", "my_plugins"]
		// 	{
		if($vst_all_map.is_defined($module)) // VST existe?
		{
			$vst_nodeID := $vst_plugins($server_name)($group_name)($module) // retrieve id des vst_plugins
			// $vst_param_index := $vst_all_map($vst_name)("parameters")($param)
			
			
			loop
			{
				// print ($a[$idx])
				if($vst_all_map($module)("parameters").is_defined($params[$loop_index]))
				{
					$vst_params_tab.push_back($vst_all_map($module)("parameters")($params[$loop_index])) // parameter to vst index
					$vst_params_tab.push_back(@to_char($params[$loop_index+1])) // value non normalized
				}
				else
				{
					if($params[$loop_index] == "bypass") // parameter of SynthDef, not VST
					{
						$Servers($server_name).n_set($vst_nodeID, ["bypass", $params[$loop_index+1]])
					}
					else
					{
						print parameter ($params[$loop_index]) does not exist
					}
				}

				$loop_index += 2
			} until ($loop_index == @size($params))

			$Servers($server_name).u_cmd([$vst_nodeID, 6, "/set"].concat($vst_params_tab)) // 6 = UGen id inside Synthdef
		}
		else
		{
			forall $x in ($synths_map($server_name)($group_name)($module))
			{
				// scServer "n_set" $x $params
				$Servers($server_name).n_set($x, $params)
			}
		}
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)) 
		// $sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq") := 100
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module)))
	}

	@fun_def set_group($params) // set parameters of all nodes in group
	{
			$Servers($server_name).n_set($group_id, $params)
	}	

	// @fun_def set_multi($module, $params)
	// {
	// 	forall $x in $params
	// 	{
	// 		print (""+$params)
	// 	}
	// 	// forall $x in ($synths_map($server_name)($mix_group)($track_label)($module)).size()
	// 	// {
	// 	// 	scServer "n_set" ($synths_map($server_name)($mix_group)($track_label)($module))[$x]
	// 	// }
	// }

	@fun_def set_single ($module, $num, $params)
	{
		// scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $params
		$Servers($server_name).n_set($synths_map($server_name)($group_name)($module)[$num], $params)

	}



	@fun_def mod_kill($module, $fade_out) // kill module
	{
		// scServer "n_set" ($synths_map($server_name)($group_name)($module)) matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($synths_map($server_name)($group_name)($module), ["matrix_ramp", $fade_out, "free", 0])

	// $Servers($server_name).n_set($group_id, ["out_ramp", 0.01, "gatee", 0])

	// $sc_struct($server_name).remove($group_id) // enleve group key de la MAP $sc_struct 
	$synths_map($server_name)($group_name).remove($module)
	$track_proc($server_name)($group_name).remove($module) // delete track_proc from map

		//remove synth
		//$sc_struct($server_name)
		// print (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($group_name)($module)))
	}

	@proc_def mod_remove($module, $time_off = 0.1)
	{
		// poner condicion is_defined()
		forall $node in ($synths_map($server_name)($group_name)($module))
		{			
			// scServer "n_set" $node matrix_ramp $time_off free 0
			$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])
			$sc_struct($server_name).remove($node)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
			if($track_proc($server_name)($group_name)($node).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($group_name)($node) // parcours le dico de proc
				{
					abort $proc 
				}
			}
			// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		}
		$synths_map($server_name)($group_name).remove($module)
	}


	@fun_def mod_size($module)
	{
		return (($synths_map($server_name)($group_name)($module)).size())
	}

///// hacer

	@proc_def amp_bpf($bpf)  // [-6, 7.5, "circ", 3, 4.5, -118]
    {
		@local $nim, $lamp
		// abort $last_bpf_amp_curve //evita interferencias
		$nim := @build_nim_from_bpf($bpf)
		// print $nim
		$lamp := $bpf[0]
		$last_bpf_amp_curve := { curve @grain := 0.01, @action {
			// scServer "n_set" $node_id_out amp $lamp
		$Servers($server_name).n_set($node_id_out, ["amp", $lamp])

		} 
			{ $lamp : $nim }
	    }
	}

    @proc_def line_amp($lmin1, $lmax1, $dur1, $type) 
    {
	   @local $lamp
	// .CheckParam($module, $param, $MYSELF)
	   Curve
	   @grain := 0.01,
	   @action {
    //     		forall $x in ($synths_map($server_name)($group_name)($module))
				// {
				// 	scServer "n_set" $x $params
				// }
	   // print scServer "n_set" $node_id_out amp $lamp
		  $Servers($server_name).n_set($node_id_out, ["amp", $lamp])
				} 
	   { $lamp {            
				    {$lmin1} @type := $type
			 $dur1   {$lmax1}} 
	   }
    }

    @proc_def line_param($module, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				forall $node in ($synths_map($server_name)($group_name)($module))
				{
					// scServer "n_set" $node $param $lparam1
					$Servers($server_name).n_set($node, [$param, $lparam1])

				}
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}} 
		  }

    }

    @proc_def line_param_single($module, $num, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				// scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $param $lparam1
				$Servers($server_name).n_set($synths_map($server_name)($group_name)($module)[$num], [$param, $lparam1])

			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}}
		  }
    }

    @proc_def bpf_param($module, $param, $bpf) 
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			forall $node in ($synths_map($server_name)($group_name)($module))
			{
				// scServer "n_set" $node $param $lpar 
			$Servers($server_name).n_set($node, [$param, $lpar])

			}
		} 
		{ $lpar : $nim }
    }
    @proc_def bpf_param_single($module, $num, $param, $bpf) // seulement quand une un track a plusieurs instances du même module
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			// scServer "n_set" ($synths_map($server_name)($group_name)($module)[$num]) $param $lpar
			$Servers($server_name).n_set($synths_map($server_name)($group_name)($module)[$num], [$param, $lpar])

		} 
		{ $lpar : $nim }
    }

    @proc_def nim_param($module, $param, $nim) 
    {
		@local $lpar
		// $nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		// $lpar := $bpf[0]
		curve @grain := 0.01, 
		@tempo := $RT_TEMPO,
		@action 
		{
			forall $node in ($synths_map($server_name)($group_name)($module))
			{
				// scServer "n_set" $node $param $lpar 
			$Servers($server_name).n_set($node, [$param, $lpar])

			}
		} 
		{ $lpar : $nim }
    }
  
	@proc_def nim_multi_param($module, $v_nim) 
    {
		@local $lpar, $nim_play, $vzer_nim, $vzer_crv_size, $nims_agre := [], $nodes

		$vzer_nim := $vezer_curves($v_nim)
		$vzer_crv_size := $vezer_curves($v_nim).size()
		// print vzer_nim (""+$vzer_nim)

		forall $n in $vzer_crv_size
		{
			$nims_agre.push_back($vzer_nim($n)[1])
		}
		// print nims_agre (""+$nims_agre)
		$nim_play := @aggregate($nims_agre) // aggregate nims for multidim
		// print nim_play (""+$nim_play)

		$nodes := $synths_map($server_name)($group_name)($module)

		curve 
		@tempo := $RT_TEMPO,
		@grain := 0.01, 
		@action 
		{
			forall $crv in $vzer_crv_size
			{
				forall $node in $nodes
				{
					// print  (""+[$vzer_nim($crv)[0], $lpar[$crv]])
					$Servers($server_name).n_set($node, [$vzer_nim($crv)[0], $lpar[$crv]])
				}
			}
		} 
		{ $lpar : $nim_play }
		
    }     
///// lfp

	@fun_def sin_lfo($module, $param, $r_low, $r_hi, $t) 
    {
	@local $vst_nodeID, $vst_name

		// if($module.is_tab()) // for VST
		// {
		// 	if($module[0] == "VST") // ["VST", "my_plugins"]
		// 	{
		if($vst_all_map.is_defined($module)) // VST existe?
		{			
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($group_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($group_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($group_name).add_pair(("vst"+$vst_nodeID+$param), ::sin_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t))  // instantie un le processus dans le dico

		}		
		else
		{
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
			{
			if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_sin
				abort $track_proc($server_name)($group_name)($x)($module+$param) 
			} 
			   $track_proc($server_name)($group_name)($x).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t))                	
		   }
	    }
	}

	@fun_def sin_lfo_single($module, $num, $param, $r_low, $r_hi, $t) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

	if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	} 
	   $track_proc($server_name)($group_name)($node_num).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $node_num, $param, $r_low, $r_hi, $t))                	
	}


//($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo)
	@fun_def brown_lfo($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	@local $vst_nodeID, $vst_name

		// if($module.is_tab()) // for VST
		// {
		// 	if($module[0] == "VST") // ["VST", "my_plugins"]
		// 	{
		if($vst_all_map.is_defined($module)) // VST existe?
		{			
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($group_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($group_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($group_name).add_pair(("vst"+$vst_nodeID+$param), ::brown_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))  // instantie un le processus dans le dico

		}
		else
		{    	
		forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
			{
			if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_brown
				abort $track_proc($server_name)($group_name)($x)($module+$param) 
			} 
			   $track_proc($server_name)($group_name)($x).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $x, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
		   }
	    }
	}

	@fun_def brown_lfo_single($module, $num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

	if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($group_name)($module+$param) 
	} 
	   $track_proc($server_name)($group_name)($node_num).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $node_num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	}


	@fun_def rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo) 
	{ 
		@local $vst_nodeID, $vst_name

		// if($module.is_tab()) // for VST
		// {
		// 	if($module[0] == "VST") // ["VST", "my_plugins"]
		// 	{
		if($vst_all_map.is_defined($module)) // VST existe?
		{			
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($group_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($group_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($group_name).add_pair(("vst"+$vst_nodeID+$param), ::rand_lfo_vst($server_name, $vst_name, $vst_nodeID, $param, $min, $max, $init_val, $type, $tpo))  // instantie un le processus dans le dico
		}
		else
		{
			forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
			{
				if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_rand
				abort $track_proc($server_name)($group_name)($x)($module+$param) 
			}
				$track_proc($server_name)($group_name)($x).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $tpo, $gui)) // instantie un le processus dans le dico
			}	
		}
	}


	@fun_def rand_lfo_single($module, $num, $param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($group_name)($module))
		if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($group_name)($node_num).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $node_num, $param, $min, $max, $init_val, $type, $tpo))		
	}


	@fun_def tri_lfo($module, $param, $r_low, $r_hi, $t, $type1, $type2) 
	{ 
	@local $vst_nodeID, $vst_name

		// if($module.is_tab()) // for VST
		// {
		// 	if($module[0] == "VST") // ["VST", "my_plugins"]
		// 	{
		if($vst_all_map.is_defined($module)) // VST existe?
		{			
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($group_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($group_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($group_name).add_pair(("vst"+$vst_nodeID+$param), ::lfo_tri_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t, $type1, $type2))  // instantie un le processus dans le dico
		}
		else
		{   		
			forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
			{
				if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_lfo_tri
				abort $track_proc($server_name)($group_name)($x)($module+$param) 
			}
				$track_proc($server_name)($group_name)($x).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2)) // instantie un le processus dans le dico

			}
		}
	}


	@fun_def tri_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $type1, $type2) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($group_name)($module))
		if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($group_name)($node_num).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2))		
	}



	@fun_def saw_lfo($module, $param, $r_low, $r_hi, $t, $dir, $type) 
	{ 
	@local $vst_nodeID, $vst_name

		if($vst_all_map.is_defined($module)) // VST existe?
		{			
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($group_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($group_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($group_name).add_pair(("vst"+$vst_nodeID+$param), ::sin_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t, $dir, $type))  // instantie un le processus dans le dico

		}
		else
		{   		
			forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
			{
				if($track_proc($server_name)($group_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_lfo_tri
				abort $track_proc($server_name)($group_name)($x)($module+$param) 
			}
				$track_proc($server_name)($group_name)($x).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type)) // instantie un le processus dans le dico

			}
		}
	}


	@fun_def saw_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $dir, $type) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($group_name)($module))
		if($track_proc($server_name)($group_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($group_name)($node_num).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type))		
	}

	@fun_def lfo_abort($module, $param)
	{
	@local $vst_nodeID, $vst_name

		// if($module.is_tab()) // for VST
		// {
		// 	if($module[0] == "VST") // ["VST", "my_plugins"]
		// 	{
		if($vst_all_map.is_defined($module)) // VST existe?
		{			
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($group_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($group_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($group_name)("vst"+$vst_nodeID+$param) 
		}
		else
		{
			print lfo_abort $module $param does not existe
		}
		}
		else
		{ 		
			forall $x in ($synths_map($server_name)($group_name)($module)) // parcours la liste de node de la même synth
			{
				abort $track_proc($server_name)($group_name)($x)($module+$param) 
			}
		}
	}

	@fun_def lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($group_name)($module)[$num])

		abort $track_proc($server_name)($group_name)($node_num)($module+$param) 
	}

	// @fun_def gui()
	// {
	// 	@local $addsynth := [], $tab_ids
	// 	$tab_ids := $sc_struct($server_name)($group_id).drop(-1)
	// 	$gui := true
	// 	// TTracks8.new(track_name.asString, nil, group, bus, outsynth);
	// 	print $tab_ids

	// 	forall $x in $tab_ids
	// 	{
	// 		// print (""+($sc_struct($server_name)($group_id)($x)))
	// 		// print (""+($sc_struct($server_name)($x)))
	// 		$addsynth.push_back($x)
	// 		$addsynth.push_back($sc_struct($server_name)($x)("_synth"))
	// 		// $addsynth.push_back($sc_struct($server_name)($group_id)($x))
	// 	}
	// 	gui_antes $server_name $track_label $group_id $bus $node_id_out $addsynth

	// 	// forall $k, $v in $track_proc($server_name)($group_name) // active envoie OSC vers GUI
	// 	// {
	// 	// 	if($v.size() > 0) // si la valeur contiens deja un proc avant creation GUI
	// 	// 	{
	// 	// 		$v.$gui := true // alors activer l'envoie par l'argument $gui (variable locale) 
	// 	// 	}
	// 	// }
	// }
	@fun_def gui($module = <undef>, $view = 1)
	{
		@local $addsynth := [], $tab_ids, $vst_id
		if($module == <undef>)
		{		
		$tab_ids := $sc_struct($server_name)($group_id).drop(-1)
		$gui := true
		// TTracks8.new(track_name.asString, nil, group, bus, outsynth);
		print $tab_ids

		forall $x in $tab_ids
		{
			// print (""+($sc_struct($server_name)($group_id)($x)))
			// print (""+($sc_struct($server_name)($x)))
			$addsynth.push_back($x)
			$addsynth.push_back($sc_struct($server_name)($x)("_synth"))
			// $addsynth.push_back($sc_struct($server_name)($group_id)($x))
		}
		gui_antes $server_name $track_label $group_id $bus $node_id_out $addsynth

		// forall $k, $v in $track_proc($server_name)($mix_group)($track_name) // active envoie OSC vers GUI
		// {
		// 	if($v.size > 0) // si la valeur contiens deja un proc avant creation GUI
		// 	{
		// 		$v.$gui := true // alors activer l'envoie par l'argument $gui (variable locale) 
		// 	}
		// }
		}
		else
		{
			if($vst_all_map.is_defined($module)) // VST existe?
			{
			if($vst_all_map($module)("sdkversion")[4] == "3") // pour VST3
			    {
				$module := $module+".vst3"
			    }
				$vst_id := $vst_plugins($server_name)($group_name)($module) // retrieve vst node_id
				$Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
			}
			else
			{
				print "module not found"
			}
		}
	}
	@fun_def vst_decoder_gui($view)
	{	
		$Servers($server_name).u_cmd([$node_id_out, 4, "/vis", $view]) // 4 Synthdef UGEN id
	}

	@fun_def vst_gui($vst_module, $view) // vst_name, open = 1, close = 0
	{
		@local $vst_id
		if($vst_all_map.is_defined($vst_module)) // VST existe?
		{
		if($vst_all_map($vst_module)("sdkversion")[4] == "3") // pour VST3
		    {
			$vst_module := $vst_module+".vst3"
		    }
			$vst_id := $vst_plugins($server_name)($group_name)($vst_module) // retrieve vst node_id
			$Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
		}
		else
		{
			print "module not found"
		}		
		// $vst_id := $vst_plugins($server_name)($group_name)($vst_module) // retrieve vst node_id
		// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
		
	}

	@proc_def free($t = 1)
    {
		forall $k, $track in $SC_Groups($group_name)("sub_group") // stop all track (sub_group tab) and proc inside this group 
		{
			$track.free($t) // remove all proc from this track
		}

		forall $k, $aux in $SC_Groups($group_name)("aux_sub_group") // stop all aux (sub_group tab) and proc inside this group 
		{
			$aux.free($t) // remove all proc from this track
		}    	
		($t+0.001) forall $k, $v in $track_proc($server_name)($group_name)
		{
			if($v.is_map()) // si map abort proc modules
				{
				forall $proc_name, $proc in $v // parcours liste de proc en route
					{
						// ("abort proc_name " + $proc_name).post()
						// ("abort proc " + $proc).post()
						// abort $proc
						forall $proc_name_map, $proc_map in $proc
						{
							abort $proc_map
						}

					}
				}
				else // si proc solo proc de HOA (orbit, ...)
				{
					abort $v
				}
		}

		// $Servers($server_name).n_set($group_id, ["out_ramp", 0.01, "gatee", 0])
		// print struct_group_id $group_id $group_name (""+$struct_group_id)
		forall $re in $struct_group_id
		{
			$sc_struct($server_name).remove($re)
		}
		// print group_idgroup_id $group_name $group_id
		// print struct_main_group_id $group_name (""+$struct_main_group_id)
		$struct_main_group_id.remove($struct_main_group_id.occurs($group_id))
		// $sc_struct($server_name)("default_group")[0]
		$sc_struct($server_name).remove($group_id)
		// $sc_struct($server_name).remove($group_id) // enleve group key de la MAP $sc_struct 
		$synths_map($server_name).remove($group_name)
		$track_proc($server_name).remove($group_name) // delete track_proc from map
		$vst_plugins($server_name).remove($group_name)
		// $space_group($server_name)($group_name).remove("val")
		// $space_group($server_name)($group_name).remove("xyz_offset") //oF visualisation
		$space_group($server_name).remove($group_name)
		$group_proc($server_name).remove($group_name)

		$SC_Groups.remove($group_name) // remove this group from map SC_Groups
		$groups.remove($group_name)

		$Servers($server_name).n_set($node_id_out, ["out_ramp", $t, "gatee", 0])

		($t+1) abort $THISOBJ //$time
    }	

	@abort
	{
		print "abort" $group_name object
	    // $THISOBJ.free(0.1) // 
	 //    forall $k, $v in $track_proc($server_name)($track_label) // abort processus
		// {
		// 	abort $v
		// }
	}
}

////////////// Tracks

@obj_def crea_track($track_name, $mix_group, $synth_collection = [], $fade_in = 0.01, $amp = 0, $num_inputs = 1) // recuperar el nombre de la variable
{
	@local $group_id, $bus, $gbus, $node_id_out, $gui, $server_name, $group_name, $main_group_id, $rand_spat_pos := false, $t_trig := 0, $trig_ryth, $last_bpf_amp_curve, $num_channels, $amp_bpf_x_min, $amp_bpf_x_max
    @init 
    {

		// if($mix_group.is_tab()) 
		// {
		// 	$server_name := $SC_Groups($mix_group[1])
		// 	$server_group_id := $SC_Groups($mix_group[0])
		// }
		// else
		// {
		$last_bpf_amp_curve := 0 // to avoid interferences

		if($SC_Groups($mix_group).is_undef()) // si le groupe n'existe pas
		{
			print this "group" does not exist
		} 
		else
		{
			if($mix_group == "default")
			{
				print default
				// $server := $SC_Servers($mix_group[0])
				$main_group_id := 1
			}
			else
			{
				if($tracks($track_name).is_undef())
				{
					// print no_default
					$server_name := $SC_Groups($mix_group)("server_name")
					$main_group_id := $SC_Groups($mix_group)("main_group_id")
					$gbus := $SC_Groups($mix_group)("main_bus")
					$num_channels := $SC_Groups($mix_group)("num_channels")
					$group_name := $SC_Groups($mix_group)("name")

				    $group_id := $SC_Servers($server_name)("node_id")
				    $bus := $SC_Servers($server_name)("bus_index")			    

				    // print bus $bus
				    // print group_id $group_id
				    // print server_name $server_name
				    // print main_group_id $main_group_id

				    $gui := false

				    // $track_name := ("group_"+$group_id)

				    // print track_name $track_name
					// print $server_name
					// print synths_map (""+$synths_map)

				    $synths_map($server_name)($mix_group).insert($track_name, map{}) // map pour synth à reemplacer par sc_struct plus tard
				    $track_proc($server_name)($mix_group).insert($track_name, map{}) // map des processus pour chaque track
				    
				    // print synths_map (""+$synths_map)
				    // print track_proc (""+$track_proc)
				    // print toto

				    // @command("g_new"+$server_name) $group_id 0 $main_group_id // group_id, add group to the head [0], into group $main_group_id
				    // scServer "/g_new" $group_id 0 $main_group_id	

				    $Servers($server_name).g_new($group_id, 0, $main_group_id)	    

				    $SC_Servers($server_name).add_pair("node_id", $group_id + 1)
				    // $node_id := $node_id + 1
				    // print $node_id
				    $node_id_out := $SC_Servers($server_name)("node_id")
				    // $node_id_out := $node_id
				    // @command("s_new"+$server_name) audioOut8 $node_id_out 1 $group_id in $bus out ($gbus+$chnl) index $bus in_ramp $fade_in amp $amp

				    // scServer "s_new" audioOut8 $node_id_out 1 $group_id in $bus out ($gbus+$chnl) index $bus in_ramp $fade_in amp $amp

					$Servers($server_name).s_new(["audioOut"+$num_channels, $node_id_out, 1, $group_id, "in", $bus, "out", $gbus, "index", $bus, "in_ramp", $fade_in, "amp", $amp]) //$gbus+$chnl_offset

				    $synths_map($server_name)($mix_group)($track_name).insert("group", $group_id)
					$synths_map($server_name)($mix_group)($track_name).insert("audioOut"+$num_channels, $node_id_out)

					////// 
					$tracks.add_pair($track_name, $THISOBJ) // put this group object in dico $group

					$sc_struct($server_name)($main_group_id)($mix_group).push_front($group_id) // !!!!!! !!!!! root tree 0
				    $sc_struct($server_name).add_pair($group_id, map{($track_name, [$node_id_out])}) // crea nueva key group + audioOut
					$sc_struct($server_name).add_pair($node_id_out, map{("_synth", "audioOut8"), ("in", $bus), ("out", $gbus), ("index", $bus), ("in_ramp", $fade_in), ("amp", $amp)}) // crea MAP para nombre_synth + parametros
					
					$SC_Servers($server_name).insert("bus_index", $bus+$num_channels+$num_inputs) // incrementa bus de server

				    // $node_id := $node_id + 1 // incremente de 1 la variable $node_id pour le prochain node
					$SC_Servers($server_name).insert("node_id", $node_id_out + 1)
				    
				    $SC_Groups($mix_group)("sub_group").add_pair($track_name, $THISOBJ) // store thisobject in TAB of SC_Groups(mix_group)

					    if($synth_collection.size()>0)
					    {
						$THISOBJ.mod_add($synth_collection)
						}					
				    }
				    else
					{
						print this track exist
					}
				}
			}
   }

   @fun_def mod_add($module, $action = "before_out", $target_mod = <undef>, $fade_in = 0.01) // , $action = "before_out", $target_mod = $node_id_out, $fade_in = 0.01
   {
	@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod, $target_id, $mod_name, $json_file, $json_map

    $node_id_mod := $SC_Servers($server_name)("node_id") // last id

    // $target_mod := ($target_mod.is_undef() ? $target_mod : $node_id_out)

    if($target_mod.is_undef())
    {
	$target_mod := $node_id_out
    }

    // $mod_after_id := $synths_map($server_name)($mix_group)($track_name)($mod_after)[0] // recupera $mod_after id
    $target_id := $synths_map($server_name)($mix_group)($track_name)($target_mod)[0] // recupera $target_id

    // print $target_mod
    // print $action
    // print $target_id
    // print (""+$synths_map($server_name)($mix_group)($track_name))
    // print (""+$synths_map($server_name)($mix_group)($track_name)($target_mod))

    if ($module.dim() > 1 && $module.car().is_tab()){ // si c'est tab multi

    // print MULTI_0
	forall $chain in $module // s'il y a plus des modules
	{
		$params := $chain.cdr()
		// print params (""+$params)
			// $Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in])
			
			switch ($action)
		{
			case "before_out":
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
				case "after":
				// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
				case "before":
				// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
				case "top":
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
			}

			// $sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name)($group_id)($track_name).push_front($node_id_mod) // root tree 0

			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($track_name)($mix_group)($chain[0]))

			if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($chain[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
			}else 
			{
				// print ($chain[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod) // si existe rajouter a la TAB

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1) // incremente pour le prochain
		$node_id_mod := $SC_Servers($server_name)("node_id") // set prochain id au nouveau id ligne precedente

		}
	}else{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			// print DIM 1 PRESET
			// print MULTI_1
			// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
			$params := $module.cdr()
			$mod_name := $module.car()
			// print $params
			if($params.car() == "preset"){
				@local $params_preset, $par_init, $inc := 0
				// print preset $mod_name 
				// $json_file := "~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"
				// print print_preset0 (""+$params)
	   // 			$json_file := $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"

				// $json_file := @json_read($json_file)
				$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json")
				// print JSON (""+$json_file) 
				// print JSON (""+$json_file($mod_name)($params[1]))
				// print params1 (""+$params[1])
				$params_preset := $json_file($mod_name)($params[1]) //.map2tab()
				// print params_preset (""+$params_preset)

				if($params_preset.is_undef())
				{
					print "this preset does not exist"
				}
				else
				{
					$par_init := $params.drop(2)

					loop 
					{
						$params_preset.add_pair($par_init[$inc], $par_init[$inc+1]) // replace parameters after 
						$inc += 2
					} until ($inc==$par_init.size())

					$params := $params_preset.map2tab() // convert map to tab
				}

			}
			// @command("s_new"+$server_name) ($module[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			// scServer "s_new" ($module[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			// $Servers($server_name).s_new([$module[0], $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

			switch ($action)
		{
			case "before_out":
			 // @set_osc_handling_tab(1) ///SuperCollider a diferencia de antescofo/sclang
				$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
				// print titititi (""+[$module[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in, $params])
				// print params (""+$params)
				case "after":
				// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module[0], $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
				case "before":
				// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
				case "top":
				$Servers($server_name).s_new([$module[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
				// print top top 
			}
			// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
			// $sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name)($group_id)($track_name).push_front($node_id_mod) // root tree 0

			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
			}else 
			{
				// print ($module[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			print este
			// print MULTI_2 solo sin tab
			// print $module $node_id_mod  $target_mod $bus $params $fade_in
			// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// @command("s_new"+$server_name) ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			// scServer "s_new" ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			// $Servers($server_name).s_new([$module, $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
			switch ($action)
		{
			case "before_out":
				$Servers($server_name).s_new([$module, $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
				case "after":
				$Servers($server_name).s_new([$module, $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
				case "before":
				$Servers($server_name).s_new([$module, $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])		   		
				case "top":
				$Servers($server_name).s_new([$module, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
			}
			// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
			// $sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name)($group_id)($track_name).push_front($node_id_mod) // root tree 0

			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
				
			if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module) is not member at $node_id_mod
				// ($synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])).post()
				$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
			}else 
			{
				// print ($module) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
		
	}

	
	}

	@fun_def mod_add_top($module, $fade_in_mod = 0.1)
	{
		@local $addmod_index := 0, $params, $node_id_mod

		// $fade_in_mod := 0 // deberia ser un argumento opcional!!
		// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
		// print modulos $module
	    // print groupo $group_id
	    // print node_id $node_id
	    // print size ($module.dim())
	    // print params $params
	    if ($module.dim() > 1){ // si c'est tab multi
	    print MULTI_0
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
			// print params $params
				// @command("s_new"+$server_name) ($chain[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// scServer "s_new" ($chain[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
				// $synths_map($server_name)($mix_group)($track_name).insert($chain[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

				}

				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}else{ 
			if($module.is_tab()) // si c'est tab 1 dim
			{
				// print MULTI_1
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// print tab 
				// print params $params
				// scServer "s_new" ($module[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
				// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

				}
				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}else{
				// print MULTI_2
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// @command("s_new"+$server_name)($module) $node_id_mod 0 $group_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				// scServer "s_new"($module) $node_id_mod 0 $group_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

				}
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}

	@fun_def mod_add_botton($module, $fade_in_mod = 0.1)
	{
		@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod

	    if ($module.dim() > 1){ // si c'est tab multi
	    // print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
			// print params $params
				// scServer "s_new" ($chain[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))

				// $synths_map($server_name)($mix_group)($track_name).insert($chain[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

				}

				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}else{ 
			if($module.is_tab()) // si c'est tab 1 dim
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// print params $params
				// scServer "s_new" ($module[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))

				// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

				}
				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}else{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new"($module) $node_id_mod 0 $group_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

				}
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}

	@fun_def mod_after($module, $mod_after)
	{
		@local $addmod_index := 0, $params, $fade_in_mod, $mod_after_id, $node_id_mod

		$fade_in_mod := 1 // deberia ser un argumento opcional!!
		// $node_id_mod := $SC_Servers($server_name)("node_id") // last id

	    $mod_after_id := $synths_map($server_name)($mix_group)($track_name)($mod_after)[0] // recupera $mod_after id

	    "post".post()
		$node_id_mod.post()
		$mod_after_id.post()
		"post".post()

	    if ($module.dim() > 1){ // si c'est tab multi
	    print MULTI_0
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
				// @command("s_new"+$server_name) ($chain[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// scServer "s_new" ($chain[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				// print params ($synths_map($server_name)($mix_group)($track_name)($chain[0]))

				if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

				}
			   
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}
		else
		{
			if($module.is_tab()) // si c'est tab 1 dim
			{
				// print MULTI_1
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// @command("s_new"+$server_name) ($module[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// scServer "s_new" ($module[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
				// print ("s_new"+$server_name) ($module[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut

				// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

				}
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))
				
				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
			else
			{
				// print MULTI_2
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// @command("s_new"+$server_name) ($module) $node_id_mod 3 $mod_after_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				// scServer "s_new" ($module) $node_id_mod 3 $mod_after_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

				}

				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
				
		}
	}

	@fun_def mod_before($module, $mod_before)
	{
	@local $addmod_index := 0, $params, $fade_in_mod, $mod_before_id, $node_id_mod
	$fade_in_mod := 1 // deberia ser un argumento opcional!!
	// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
    $mod_before_id := $synths_map($server_name)($mix_group)($track_name)($mod_before)[0] // recupera $mod_after id
    // print (""+$synths_map($server_name)($mix_group)($track_name))
    // print size ($module.dim())
    // print params $params
    if ($module.dim() > 1){ // si c'est tab multi
    // print MULTI_
	forall $chain in $module // s'il y a plus des modules
	{
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		// print $chain
		$params := $chain.cdr()
			// @command("s_new"+$server_name) ($chain[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			// scServer "s_new" ($chain[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($server_name)($mix_group)($track_name)($chain[0]))

			if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($chain[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
			}else 
			{
				print ($chain[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
	}
	else
	{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			$params := $module.cdr()
			// @command("s_new"+$server_name) ($module[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			// scServer "s_new" ($module[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
			// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($module[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
			}else 
			{
				print ($module[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// @command("s_new"+$server_name)($module) $node_id_mod 2 $mod_before_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			// scServer ($module) $node_id_mod 2 $mod_before_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$module, $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
			// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($module) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod]) // tab dans le cas de plusieurs instances du même module
			}else 
			{
				print ($module) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
			
	}
	}


	@proc_def mod_remove($module, $time_off = 0.1)
	{
		forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		{			
			// @command("n_set"+$server_name) $node matrix_ramp $time_off free 0
			// scServer "n_set" $node matrix_ramp $time_off free 0
			$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])
			$sc_struct($server_name).remove($node)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
			if($track_proc($server_name)($mix_group)($track_name)($node).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
				{
					abort $proc 
				}
			}
			// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		}
		_ := $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_remove_id($nodes, $time_off = 0.1)
	{
		if($nodes.is_tab())
		{
			forall $x in $nodes
			{
				// @command("n_set"+$server_name) $x matrix_ramp $time_off free 0
				// scServer "n_set" $x matrix_ramp $time_off free 0
				$Servers($server_name).n_set($x, ["matrix_ramp", $time_off, "free", 0])
				_ := $synths_map($server_name)($mix_group)($track_name).remove($sc_struct($server_name)($group_id)($x)("_synth"))
				$sc_struct($server_name)($server_name).remove($x)
				_ := $sc_struct($server_name)($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($x))
				if($track_proc($server_name)($mix_group)($track_name)($x).size() != 0) // abort proc des modules
				{	
					$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($x) // parcours le dico de proc
					{
						abort $proc 
					}
				}	
			}
		}
		else
		{
			// @command("n_set"+$server_name) $nodes matrix_ramp $time_off free 0
			// scServer "n_set" $nodes matrix_ramp $time_off free 0
			$Servers($server_name).n_set($nodes, ["matrix_ramp", $time_off, "free", 0])
			_ := $synths_map($server_name)($mix_group)($track_name).remove($sc_struct($server_name)($group_id)($nodes)("_synth"))
			$sc_struct($server_name).remove($nodes)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($nodes))
			if($track_proc($server_name)($mix_group)($track_name)($nodes).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($nodes) // parcours le dico de proc
				{
					abort $proc 
				}
			}
		}	
	}

	@proc_def mod_remove_single($module, $num, $time_off = 0.1) // quand il y a plusieurs instances d'un même module, sinon utiliser la methode mod_remove
	{
		@local $node
		$node := $synths_map($server_name)($mix_group)($track_name)($module)[$num]
		// @command("n_set"+$server_name) $node matrix_ramp $time_off free 0
						  // scServer "n_set" $node matrix_ramp $time_off free 0
		$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])

		$sc_struct($server_name).remove($node)
		$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		_ := $synths_map($server_name)($mix_group)($track_name)($module).remove($synths_map($server_name)($mix_group)($track_name)($module).occurs($node))
		
		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		{
			abort $proc 
		}
	_ := $synths_map($server_name)($mix_group)($track_name).remove($node)	
	}

	@fun_def mod_replace($module_old, $module_new, $cross_fade = 1)
   {
		$THISOBJ.mod_remove($module_old, $cross_fade)
		$THISOBJ.mod_add($module_new, fade_in = $cross_fade)
   }


	@proc_def mod_move_before($module, $mod_mov_before)
	{
		// n_before ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])

		print n_before ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])

		// @command("n_before"+$server_name) ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])
		// scServer "n_before" ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])
		
		$Servers($server_name).n_before($synths_map($server_name)($mix_group)($track_name)($module), $synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])

		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_move_before_id($module_id, $mod_mov_before_id)
	{
		// n_before $module_id $mod_mov_before_id

		print n_before $module_id $mod_mov_before_id

		// @command("n_before"+$server_name) $module_id $mod_mov_before_id
		// scServer "n_before" $module_id $mod_mov_before_id
		$Servers($server_name).n_before($module_id, $mod_mov_before_id)

		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_move_after($module, $mod_mov_after)
	{
		// n_after ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0])

		print n_after ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0])

		// scServer "n_after" ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0])
		$Servers($server_name).n_after($synths_map($server_name)($mix_group)($track_name)($module), $synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0])

		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_move_after_id($module_id, $mod_mov_after_id)
	{
		// n_after $module_id $mod_mov_after_id

		print n_after $module_id $mod_mov_after_id

		// @command("n_after"+$server_name) $module_id $mod_mov_after_id
		// scServer "n_after" $module_id $mod_mov_after_id
		$Servers($server_name).n_after($module_id, $mod_mov_after_id)

		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	@command("n_set"+$server_name) $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size() != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_rand()
	{
		@local $group_key, $audioOut8_key, $track_node_list
		$group_val := $synths_map($server_name)($mix_group)($track_name)("group")
		// print toto (""+$synths_map($server_name)($mix_group)($track_name)("group"))
		$audioOut8_val := $synths_map($server_name)($mix_group)($track_name)("audioOut8")
		// print tata (""+$synths_map($server_name)($mix_group)($track_name)("audioOut8"))
		$track_node_list := $sc_struct($server_name)($group_val)($track_name)
		// print mix_group (""+$track_name)
		// print titi (""+$sc_struct($server_name)($group_val)($track_name))
		// $Servers($server_name).n_before($synths_map($server_name)($mix_group)($track_name)($module), $synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])
		
		$track_node_list := $track_node_list.rotate(1)
		// print tutu (""+$track_node_list.rotate(1))
		$track_node_list := $track_node_list.cdr()
		// print tete (""+$track_node_list.cdr())
		$track_node_list := $track_node_list.scramble()
		// print tretre (""+$track_node_list.scramble())
		$track_node_list := $track_node_list.push_back($audioOut8_val)
		// print tyu (""+$track_node_list.push_back($audioOut8_val))
		// print ("n_order"+$server_name) 0 $group_val (""+$track_node_list)
		// @command("n_order"+$server_name) 0 $group_val $track_node_list
		// scServer "n_order" 0 $group_val $track_node_list
		$Servers($server_name).n_order(0, $group_val, $track_node_list)
		// $track_node_list := @remove($sc_struct($server_name)($group_val), $audioOut8_val)
		// $track_node_list := $track_node_list.scramble
		// print audioOut8_val (""+$audioOut8_val)
		// print group_val (""+$group_val)
		// print track_node_list (""+$track_node_list)
		// print (""+$sc_struct($server_name))
		// print (""+$sc_struct($server_name)($group_val))

		// print (""+($synths_map($server_name)($mix_group)($track_name)("group")))
		// print (""+$sc_struct($server_name))

		// @command("n_after"+$server_name) $module_id $mod_mov_after_id
	}

	@proc_def migrate($group)
	{
		print synths_map (""+$synths_map)
		print sc_struct (""+$sc_struct)
		@savevalue($home + "/Documents/Doctorado/sc_struct_build2.asco.txt", $sc_struct)

				// $sc_struct($server_name).remove($node)

	}

	@fun_def set($module, $params)
	{
		// print @command("n_set"+$server_name) $module $params
		// print @command("n_set"+$server_name) ($synths_map($server_name)($mix_group)($track_name)($module)) $params

		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module))
		{
			// @command("n_set"+$server_name) $x $params
			// scServer "n_set" $x $params
			$Servers($server_name).n_set($x, $params)
		}
		// @command("n_set"+$server_name) ($synths_map($server_name)($mix_group)($track_name)($module)) 
		// $sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq") := 100
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module)))
	}

	@fun_def set_multi($module, $params)
	{
		forall $x in $params
		{
			print (""+$params)
		}
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)).size()
		// {
		// 	@command("n_set"+$server_name) ($synths_map($server_name)($mix_group)($track_name)($module))[$x]
		// }
	}

	@fun_def set_single ($module, $num, $params)
	{
		// @command("n_set"+$server_name) ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $params
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $params
		if($synths_map($server_name)($mix_group)($track_name)($module).is_tab())
		{
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($track_name)($module)[$num], $params) 
		// print totototo (""+[$synths_map($server_name)($mix_group)($track_name)($module)]) //($track_name)($module)[$num], $params])
		}
		else 
		{
			print (""+($synths_map($server_name)($mix_group)($track_name)($module)))
		}	
	}

	@fun_def preset($module, $preset)
	{
		@local $json_file, $node_id, $params_preset

		$node_id := ($synths_map($server_name)($mix_group)($track_name)($module))
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

		if($json_file.is_undef())
		{
			print "this preset does not exist"
		}
		else
		{
			$params_preset := $json_file($module)($preset).map2tab()

			forall $id in $node_id // pour toute les instances du Module
			{
				$Servers($server_name).n_set($id, $params_preset)
			}

		}
	}

	@fun_def preset_single($module, $num, $preset)
	{
		@local $json_file, $params
		print prestsss
		// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")


		$params := $json_file($module)($preset).map2tab() // recupere les donnees du present json
		print (""+$params)
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $params
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($track_name)($module)[$num], $params)

	}

	@proc_def preset_interpol($module, $preset1, $preset2, $dur, $type)
	{
		@local $json_file, $params, $params1, $params2, $nim, $val //, $id
		// print prestsss
		// $nim := @build_nim_from_bpf($bpf)
		// $id := ($synths_map($server_name)($mix_group)($track_name)($module))

		
		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")


		// $params1 := $json_file($module)($preset1).map2tab() // recupere les donnees du present json
		// $params2 := $json_file($module)($preset2).map2tab() // recupere les donnees du present json

		$params := $json_file($module)($preset2).domain() // recupere les keys des presets

		$preset1 := $json_file($module)($preset1).range() // recupere les donnees du present json
		$preset2 := $json_file($module)($preset2).range() // recupere les donnees du present json

		
	   Curve 	@Grain := 0.01,
			@Action {
					forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
					{
						// scServer "n_set" $node ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))
						// print $node (""+([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2)))
						$Servers($server_name).n_set($node, [$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))
					}
				} 
	   { $val 	{            
					{0} @type := $type
			 $dur  	{1}
			} 
	   }

	   // Curve   @Grain := 0.01,  
	   //         @Action {

	   //             scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2))
	   //         }            
	   //         { $val : $nim }

	}

	@proc_def preset_interpol_tab($module, $presets_durs_tab)
	{
		@local $dur, $json_file, $params, $preset1, $preset2, $nim, $inc := 0, $curve := 0, $type := "linear", $loop_curve := 0 //, $id
		// print prestsss
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

		$params := $json_file($module)($presets_durs_tab[0]).domain() // recupere les keys des presets

		// $preset1 := $presets_durs_tab[$inc]
		// $preset2 := $presets_durs_tab[$inc+2]
		$dur := $presets_durs_tab[$inc+1]

		$preset2 := $json_file($module)($presets_durs_tab[$inc]).range() // recupere les donnees du present json
		// $preset2 := $json_file($module)($preset2).range() // recupere les donnees du present json

		// print preset1_1 $preset2
		// // print preset2_1 $preset2
		// print params_1 $params
		// print inc_1 $inc
		print dur_1 $dur

		$inc := $inc + 1 // start from dur

		$loop_curve := { // pour avorter le loop en cours de route
			Loop $dur
			{	
				@local $val
				print durloop $dur
				$preset1 := $preset2 
				// if($inc <= @size($presets_durs_tab)-2)
				// {
					if ($presets_durs_tab[$inc+2].is_string())
				    {
					   $type := $presets_durs_tab[$inc+1]
					   // $preset2 := 
					   $preset2 := $json_file($module)($presets_durs_tab[$inc+2]).range() // recupere les donnees du present json
					   $dur := $presets_durs_tab[$inc]

					   $inc := $inc + 3;
				    }
				    else
				    {
					   $type := "linear"
					   // $preset2 := 
					   $preset2 := $json_file($module)($presets_durs_tab[$inc+1]).range() // recupere les donnees du present json
					   $dur := $presets_durs_tab[$inc]
					   $inc := $inc + 2;
				    }
				// }
			  //   	print preset1 $preset1
					// print preset2 $preset2
					// print params $params
					// print inc $inc


				abort $curve
			   $curve := {

			   Curve 	@Grain := 0.01,
						@Action {
							
								forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
								{
									// scServer "n_set" $node ([$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size()*2))
									$Servers($server_name).n_set($node, [$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size()*2))
									// print $node ([$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size*2))
								}
							} 
						{ $val 	{            
								{0} @type $type
						 $dur  	{1}
						} 
				  }
			   }
		

		}while ($inc < @size($presets_durs_tab)) //($inc < (@size($presets_durs_tab)-2))
	}
	}

	// preset_interpol_tab("TestSynth3", ["preset1", 3, "", "preset2", 2, "preset3", 3.4, "preset4"])

	@proc_def preset_interpol_bpf($module, $preset1, $preset2, $bpf)
	{
		@local $json_file, $params, $params1, $params2, $nim, $val, $id
		// print prestsss
		$nim := @build_nim_from_bpf($bpf)
		$id := ($synths_map($server_name)($mix_group)($track_name)($module))

		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

		
		$params1 := $json_file($module)($preset1).map2tab() // recupere les donnees du present json
		$params2 := $json_file($module)($preset2).map2tab() // recupere les donnees du present json

		$params := $json_file($module)($preset2).domain() // recupere les keys des presets

		$preset1 := $json_file($module)($preset1).range() // recupere les duonnees du present json
		$preset2 := $json_file($module)($preset2).range() // recupere les donnees du present json

		// $params := $json_file($module)($preset).map2tab() // recupere les donnees du present json
		// print $params1
		// print $params2
		// print $params
		// print $preset1
		// print $preset2

		print ([$params, $preset2].lace($params.size()*2))
		

	   Curve   @Grain := 0.01,  
			 @Action 
			 {
				// scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))                    
				$Servers($server_name).n_set($id, [$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))
			 }          

			 { $val : $nim }

	}


	// @fun_def amp($group_amp)
	// {
	// 		// {msg[2] == \amp} {~synth[msg[1]].outsynth.set(\amp, msg[3])}
	// 	// scServer "n_set" $node_id_out amp $group_amp
	// 	$Servers($server_name).n_set($node_id_out, ["amp", $group_amp])
	// }
	@proc_def amp($amp, $add = 0)
	{
		@local $nim, $lamp, $last_bpf_amp_curve

		if($track_proc($server_name)($mix_group)($track_name).is_defined("amp"))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("amp") // stop process to avoid interferences
		}		
		// abort $last_bpf_amp_curve // to avoid interferences

		if($amp.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($amp)
			// .CheckParam($module, $param, $MYSELF)
			$amp_bpf_x_min := @min_key($nim)
			$amp_bpf_x_max := @max_key($nim)
			$lamp := $amp[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["amp", $lamp+$add])	
					// print amp $node_id_out $lamp
				} 
				{ $lamp : $nim }
			}
		$track_proc($server_name)($mix_group)($track_name).add_pair("amp", $last_bpf_amp_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["amp", $amp+$add])
		}
	}

	@fun_def set_track($params) // set track parameters for HOA_Encode for exemple
	{
			$Servers($server_name).n_set($node_id_out, $params)
	}

///// hacer

	@proc_def track_amp_bpf($bpf)  // [-6, 7.5, "circ", 3, 4.5, -118]
    {
		@local $nim, $lamp
		// abort $last_bpf_amp_curve //evita interferencias
		$nim := @build_nim_from_bpf($bpf)
		// print $nim
		$lamp := $bpf[0]
		$last_bpf_amp_curve := { curve @grain := 0.01, @action {
			// scServer "n_set" $node_id_out amp $lamp
			$Servers($server_name).n_set($node_id_out, ["amp", $lamp])
		} 
			{ $lamp : $nim }
	    }
	}

    @proc_def line_amp($lmin1, $lmax1, $dur1, $type) 
    {
	   @local $lamp
	// .CheckParam($module, $param, $MYSELF)
	   Curve
	   @grain := 0.01,
	   @action {
			forall $x in ($synths_map($server_name)($mix_group)($track_name)($module))
		{
			// scServer "n_set" $x $params
			$Servers($server_name).n_set($x, $params)
		}
	   // print scServer "n_set" $node_id_out amp $lamp
	} 
	   { $lamp {            
				    {$lmin1} @type := $type
			 $dur1   {$lmax1}} 
	   }
    }

	@fun_def mod_kill($module, $fade_out) // kill module
	{
		@local $mod_id, $test := 104
		$mod_id := $synths_map($server_name)($mix_group)($track_name)($module)
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)) matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($mod_id, ["matrix_ramp", $fade_out, "free", 0])
		
		$module2 :=  MAP{ (104, MAP{ ("TestSynth3fc", 1234) }) }

		// print is_int0 (""+(504.is_int()))
		print is_int ($test.is_int())
		print is_int ($mod_id.is_int())
		print module (""+$module2($mod_id))
		print module1 $mod_id
		print module2 (""+$track_proc($server_name)($mix_group)($track_name))
		print module3 (""+$track_proc($server_name)($mix_group)($track_name)($mod_id))
		print module4 (""+$track_proc($server_name)($mix_group)($track_name).domain())
		// $tracks($track_name).is_undef())

		// $fade_out forall $k, $v in $track_proc($server_name)($mix_group)($track_name)($mod_id) // parcours la liste de node de la même synth
		// {
		// 	abort $v
		// }




		$synths_map($server_name)($mix_group)($track_name).remove($module)
	$track_proc($server_name)($mix_group)($track_name).remove($module) // delete track_proc from map
	// $synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

		//remove synth
		//$sc_struct($server_name)
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module)))
	}

	@fun_def pause($time)
	{
		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 0
		$Servers($server_name).n_set($group_id, ["matrix_ramp", @dur2sec($time), "gate", 0])
		// @dur2sec($time) scServer "n_set" $group_id gate 0
	}


	@fun_def resume($time)
	{	
		// scServer "n_run" $group_id 1
		$Servers($server_name).n_run($group_id, 1)

		$Servers($server_name).n_set($group_id, ["matrix_ramp", @dur2sec($time), "gate", 1])

		forall $x in $sc_struct($server_name)($group_id)($track_name)
		{
			// scServer "n_run" $x 1
			$Servers($server_name).n_run($x, 1)
			$Servers($server_name).n_set($x, ["matrix_ramp", @dur2sec($time), "gate", 1])

		}	
	}


	@fun_def mod_size($module)
	{
		return (($synths_map($server_name)($mix_group)($track_name)($module)).size())
	}



    @proc_def line_param($module, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
				{
					// scServer "n_set" $node $param $lparam1
					$Servers($server_name).n_set($node, [$param, $lparam1])
				}
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}} 
		  }

    }

    @proc_def line_param_single($module, $num, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $param $lparam1
				$Servers($server_name).n_set($synths_map($server_name)($mix_group)($track_name)($module)[$num], [$param, $lparam1])
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}}
		  }
    }

    @proc_def bpf_param($module, $param, $bpf) 
    {
		@local $nim, $lpar, $last_bpf_param_curve, $nodes, $vst_nodeID, $vst_name

		$nodes := $synths_map($server_name)($mix_group)($track_name)($module)

		if($track_proc($server_name)($mix_group)($track_name).is_defined("bpf_param"+$module+$param))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("bpf_param"+$module+$param) // to avoid interferences
		}	

		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		
		$lpar := $bpf[0]
		$last_bpf_param_curve := { curve @grain := 0.01, 
			@action 
			{


				forall $node in $nodes // ($synths_map($server_name)($mix_group)($track_name)($module))
				{
					// scServer "n_set" $node $param $lpar 
					$Servers($server_name).n_set($node, [$param, $lpar])
				}
			} 
			{ $lpar : $nim }
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("bpf_param"+$module+$param, $last_bpf_param_curve) // store curve in map to avoid interference between different groups
	}

    @proc_def bpf_param_single($module, $num, $param, $bpf) // seulement quand une un track a plusieurs instances du même module
    {
		@local $nim, $lpar, $node
		$node := $synths_map($server_name)($mix_group)($track_name)($module)[$num]
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $param $lpar
			$Servers($server_name).n_set($node , [$param, $lpar])
		} 
		{ $lpar : $nim }
    }

////////// lfo

	@fun_def sin_lfo($module, $param, $r_low, $r_hi, $t) 
    {
	forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_sin
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		} 
		   $track_proc($server_name)($mix_group)($track_name)($x).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t))                	
	   }
	}

	@fun_def sin_lfo_single($module, $num, $param, $r_low, $r_hi, $t) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])

	if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	} 
	   $track_proc($server_name)($mix_group)($track_name)($node_num).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $node_num, $param, $r_low, $r_hi, $t))                	
	}


//($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo)
	@fun_def brown_lfo($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_brown
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		} 
		   $track_proc($server_name)($mix_group)($track_name)($x).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $x, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	   }
	}

	@fun_def brown_lfo_single($module, $num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])

	if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($mix_group)($track_name)($module+$param) 
	} 
	   $track_proc($server_name)($mix_group)($track_name)($node_num).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $node_num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	}


	@fun_def rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo) 
	{ 
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		}
			$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $tpo, $gui)) // instantie un le processus dans le dico

		}
	}

	@proc_def rand_lfo_mod($module, $param, $min, $max, $init_val, $type) 
	{ 
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		}
			_ := $track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::rand_lfo_mod_temp_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $gui)) // instantie un le processus dans le dico

		}
	}

	@fun_def rand_lfo_single($module, $num, $param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($track_name)($module))
		if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($track_name)($node_num).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $node_num, $param, $min, $max, $init_val, $type, $tpo))		
	}


	@fun_def tri_lfo($module, $param, $r_low, $r_hi, $t, $type1, $type2) 
	{ 
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_lfo_tri
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		}
			$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2)) // instantie un le processus dans le dico

		}
	}


	@fun_def tri_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $type1, $type2) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($track_name)($module))
		if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($track_name)($node_num).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2))		
	}



	@fun_def saw_lfo($module, $param, $r_low, $r_hi, $t, $dir, $type) 
	{ 
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_lfo_tri
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		}
			$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type)) // instantie un le processus dans le dico

		}
	}


	@fun_def saw_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $dir, $type) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($track_name)($module))
		if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($track_name)($node_num).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type))		
	}

	@fun_def lfo_abort($module, $param)
	{
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		}
	}

	@fun_def lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])

		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}

///////// rythms prob

	@proc_def ryth_prob_rand($mod_params, $prob, $rmin, $rmax, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		forall $x in $mod_params
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		// print (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_prob_rand($server_name, $node_params, $prob, $rmin, $rmax, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

	@proc_def ryth_prob($mod_params, $prob, $rit, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		forall $x in $mod_params
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		print node_params_ryth_prob (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_prob($server_name, $node_params, $prob, $rit, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}


	@proc_def change_prob($val)
	{
		@local $nim, $lpar, $proc_name := "prob"+$track_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			// .CheckParam($module, $param, $MYSELF)
			// print $nim
			// [2000, 5, "exp", 20, 3, 3000, 10, "exp_out", 20]
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
				let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$prob := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$prob := $val

		}
	}

	@proc_def change_proc_tempo($val) 
	{
		@local $nim, $lpar, $proc_name := "prob"+$track_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			// .CheckParam($module, $param, $MYSELF)
			// print $nim
			// [2000, 5, "exp", 20, 3, 3000, 10, "exp_out", 20]
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
				let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$tpo := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$tpo := $val

		}
	}


	@fun_def change_proc_tempo_rand_lfo_global($rand_lfo_instance, $tpo_min, $tpo_max) // $modules_params -> module, params, min, max
	{
		@local $proc_name := "global_change_proc_tempo"+$track_name

		// $node_params := $synths_map($server_name)($mix_group) // reconstruit liste avec nodes_id
		// print node_params $node_params

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name) ) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, obj::change_proc_tempo_rand_lfo_global($rand_lfo_instance, $THISOBJ, $tpo_min, $tpo_max))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}
	// @proc_def test_rand_lfo_glob($rand_lfo_instance, $nom, $min, $max)
	// {
	//   @init {
	//         $rand_lfo_instance.suscribe($THISOBJ)
	//    }
	//    @fun_def rand_lfo_glob($rand_lfo)
	//    {
	//         ; handling a new data
	//         print $nom (@scale($rand_lfo, 0, 1, $min, $max, 1))
	//    }
	//    @abort {
	//       $rand_lfo_instance.unsuscribe($THISOBJ)
	//       // $osc_gest.unsuscribe($THISOBJ)
	//    }
	// }

	// @fun_def rand_lfo_global_send($rand_lfo_instance, $module, $param, $min, $max, $init_val, $type, $tpo) 
	// { 
	// 	forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
	// 	{
	// 		if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
	//     	{
	//     		print abort_rand
	//     		abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
	//     	}
	// 		$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $tpo, $gui)) // instantie un le processus dans le dico

	// 	}
	// }
	@proc_def track_rand_lfo_global_send($rand_lfo_instance, $modules_params) // $modules_params -> module, params, min, max
	{
		@local $node_params := [], $proc_name := "track_rand_lfo_global_send"+$track_name

		forall $x in $modules_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		// print (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, $node_params))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

	@broadcast track_rand_lfo_global_send_all($rand_lfo_instance, $modules_params) // $modules_params -> module, params, min, max
	{
		@local $node_params := [], $proc_name := "track_rand_lfo_global_send_all"+$track_name
		
		forall $x in $modules_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		// print (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, $node_params))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}	

	@broadcast track_change_param_all($mod_params) //change pour toutes les instances de l'objet
	{
		@local $node_params := []
		
		forall $x in $mod_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		forall $y in $node_params // 
		{
			
			$Servers($server_name).n_set($node_params.car(), $node_params.cdr())		
		}		
		// $THISOBJ.change_param($module, $param, $lin) // change parametres pour toutes les objets play_Ingran_rand_paramA
		// $THISOBJ.change_tempo($lin_t)
	}





	@fun_def gui()
	{
		@local $addsynth := [], $tab_ids
		// print struct $sc_struct($server_name)($group_id)($track_name)
		// print struct2 (""+$sc_struct($server_name)($group_id)($track_name))
		$tab_ids := $sc_struct($server_name)($group_id)($track_name).drop(-1)
		// print $tab_ids
		$gui := true
		// TTracks8.new(track_name.asString, nil, group, bus, outsynth);
		// print $tab_ids

		forall $x in $tab_ids
		{
			// print (""+($sc_struct($server_name)($group_id)($x)))
			// print (""+($sc_struct($server_name)($x)))
			$addsynth.push_back($x)
			$addsynth.push_back($sc_struct($server_name)($x)("_synth"))
			// $addsynth.push_back($sc_struct($server_name)($group_id)($x))
		}
		gui_antes $server_name $track_name $group_id $main_group_id $node_id_out $addsynth
		print gui_antes $server_name $track_name $group_id $main_group_id $node_id_out $addsynth

		// forall $k, $v in $track_proc($server_name)($mix_group)($track_name) // active envoie OSC vers GUI
		// {
		// 	if($v.size() > 0) // si la valeur contiens deja un proc avant creation GUI
		// 	{
		// 		$v.$gui := true // alors activer l'envoie par l'argument $gui (variable locale) 
		// 	}
		// }
	}




	@fun_def play_sample($sample, $ampli, $channel)
	{
		$THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		// print buf ($SF_map($server_name)($sample))
	}

	@fun_def play_sample_ste($sample, $ampli, $channel)
	{
		$THISOBJ.mod_add(["TPlaybuf2_ste", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		// print buf_ste ($SF_map($server_name)($sample))
	}	

	@fun_def play_sample_ste2($sample, $ampli, $loop = 0) // sin channel!!
	{
		$THISOBJ.mod_add_top(["TPlaybuf2_ste", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop])
		
	}	
	@fun_def play_sample8($sample, $ampli, $loop = 0)
	{
		$THISOBJ.mod_add(["TPlaybuf8", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop], "top")
	}	

	@fun_def play_sample8_stop($sample, $fade_out) // hacer map con samplers tocados para stop
	{
		$THISOBJ.set("TPlaybuf8", ["matrix_ramp", $fade_out, "free", 0])
	}

	@proc_def free($time = 1) // @proc_def parce qu'il y a un delay pour arrter les proc
	{
			// print mix_group mix_group (""+$SC_Groups($mix_group))
			// print sub_group sub_group (""+$SC_Groups($mix_group)("sub_group"))
			// print track_name track_name track_name $track_name

		// scServer "n_set" $node_id_out out_ramp @dur2sec($time) gatee 0 // free group in $time
		$Servers($server_name).n_set($node_id_out, ["out_ramp", @dur2sec($time), "gatee", 0]) // free group in $time

		// ("abort track "+ $THISOBJ).post()
		// ("server_name "+ $server_name).post()
		// ("mix_group "+ $mix_group).post()
		// ("track_name "+ $track_name).post()
		// ($track_proc($server_name)($mix_group)($track_name)).post()
		if(($track_proc($server_name)($mix_group)($track_name)).is_undef())
		{
			$track_proc($server_name)($mix_group).remove($track_name) // delete track_proc from map
			$SC_Groups($mix_group)("sub_group").remove($track_name) // delete sub_group objects			
		}
		else
		{
			($time-0.01) forall $k, $v in $track_proc($server_name)($mix_group)($track_name) // parcours liste de nodes
			{
				// print track_proc (""+$v)
				if($v.is_map()) // si map abort proc modules
				{
				forall $proc_name, $proc in $v // parcours liste de proc en route
					{
						// ("abort proc_name " + $proc_name).post()
						// ("abort proc " + $proc_name).post()
						abort $proc

					}
				}
				else // si proc solo proc de HOA (orbit, ...)
				{
					abort $v
				}
			}

			$track_proc($server_name)($mix_group).remove($track_name) // delete track_proc from map
			$SC_Groups($mix_group)("sub_group").remove($track_name) // delete sub_group objects
			// abort $THISOBJ
		}

		$sc_struct($server_name).remove($group_id) // enleve group key de la MAP $sc_struct 
		$synths_map($server_name)($mix_group).remove($track_name) // delete synths_map from map
		$tracks.remove($track_name)
		// abort $THISOBJ // abort tout l'objet
	}

	@abort
	{
		print ("abort "+$track_name)
	    // $THISOBJ.free(0.01) // 
	 //    forall $k, $v in $track_proc($server_name)($track_name) // abort processus
		// {
		// 	abort $v
		// }
	}
}

$track_amp_action := 0 // action à faire quand seuil amp
$free_track := 0 // send info to program when track is free
@obj_def crea_track_HOA($track_name, $mix_group, $synth_collection = [], $fade_in = 1, $amp = 0, $plane_spherical = 1, $spk_radius = 1.07, $max_radius = 5, $doppler = 1, $encoder = true, $in_channels = "mono", $xyz_init_pos = [0, 0, 0], $ext_id = false) // recuperar el nombre de la variable
{	
    @init 
    {
	    @local $group_id, $bus, $gbus, $hoa_bus, $hoa_inter_bus, $rev_bus, $ambi_bus, $node_id_out, $node_id_out2, $gui, $server_name, $group_name, $main_group_id, $rand_spat_pos := false, $t_trig := 0, $order, $hoa_num_ch, $rec_map := map{}, $decriptors_map := map{}, $sflist_map := map{}, $amp_bpf_x_min, $amp_bpf_x_max, $out_name, $amp2_out := 0, $dae_list, $xyz_list := [0, 0, 0],  $int_loop := 0, $struct_main_group_id, $struct_group_id, $HOA_global_track_xyz := [0, 0, 0], $HOA_xyz_factor := 1, $d_factor := 1, $proc_index, $sync_track := @rand_int(1000)+2000, $get_when := 0

		// if($mix_group.is_tab()) 
		// {
		// 	$server_name := $SC_Groups($mix_group[1])
		// 	$server_group_id := $SC_Groups($mix_group[0])
		// }
		// else
		// {
			// print DOPPLER $doppler

		if($SC_Groups($mix_group).is_undef()) // si le groupe n'existe pas
		{
			print this "group" does not exist
		} 
		else
		{
			if($mix_group == "default")
			{
				print default
				// $server := $SC_Servers($mix_group[0])
				$main_group_id := 1
			}
			else
			{
				if($tracks($track_name).is_undef())
				{
					// print no_default
					$server_name := $SC_Groups($mix_group)("server_name")
					$main_group_id := $SC_Groups($mix_group)("main_group_id")
					$gbus := $SC_Groups($mix_group)("main_bus")
					$group_name := $SC_Groups($mix_group)("name")
					// $rev_bus := $SC_Groups($mix_group)("hoa_rev_bus")
					$hoa_bus := $SC_Groups($mix_group)("hoa_bus")
					$order :=  $SC_Groups($mix_group)("order")
					// $SC_Groups($group_name).insert("hoa_bus", $hoa_bus)
	    // 			$SC_Groups($group_name).insert("rev_bus", $rev_bus)
				

					if($ext_id.is_numeric()) // externally defined node_id 
					{
						$group_id := $ext_id
					}
					else
					{
				    	$group_id := $SC_Servers($server_name)("node_id")
					}		
						 
					if ($sc_struct($server_name).is_defined($group_id)) // if group_id exist on the program
					{
						print group_id (""+$sc_struct($server_name)($group_id))
						// print node_id_out (""+$sc_struct($server_name)($group_id+1))
						$bus := $sc_struct($server_name)($group_id)[1]("in")
						$struct_group_id := $sc_struct($server_name)($group_id)[0]
						print track_bus $bus
					}
					else
					{
						$bus := $SC_Servers($server_name)("bus_index")
					}
				    
				 //    $rev_bus := $SC_Servers($server_name)("rev_bus")
					// $hoa_bus := $SC_Servers($server_name)("hoa_bus") 
					/*
				    print bus $bus
				    // print rev_bus $rev_bus
				    print hoa_bus $hoa_bus
				    print group_id $group_id
				    print server_name $server_name
				    print main_group_id $main_group_id
				    */

				    $gui := false

				    // $track_name := ("group_"+$group_id)

				    $hoa_num_ch := ($order+1).pow(2) // HOA number of channels

				    // print track_name $track_name
					// print $server_name
					// print synths_map (""+$synths_map)

				    $synths_map($server_name)($mix_group).insert($track_name, map{}) // map pour synth à reemplacer par sc_struct plus tard
				    $track_proc($server_name)($mix_group).insert($track_name, map{}) // map des processus pour chaque track
				    $vst_plugins($server_name)($mix_group).insert($track_name, map{}) // map des processus pour chaque track


				    
				    // print synths_map (""+$synths_map)
				    // print track_proc (""+$track_proc)
				    // print toto

				    // scServer "g_new" $group_id 0 $main_group_id // group_id, add group to the head [0], into group $main_group_id
				    $Servers($server_name).g_new($group_id, 0, $main_group_id)
				    //SuperNova
				    // scServer "p_new" $group_id 0 $main_group_id // group_id, add group to the head [0], into group $main_group_id

				    $SC_Servers($server_name).add_pair("node_id", $group_id + 1)
				    // $node_id := $node_id + 1
				    // print $node_id
				    $node_id_out := $SC_Servers($server_name)("node_id")
				    // $node_id_out := $node_id
				    // scServer "s_new" audioOut8 $node_id_out 1 $group_id in $bus out ($gbus+$chnl) index $bus in_ramp $fade_in amp $amp
				    
				    // ~espace = Synth(\HOA_Encode4_out, [\in,  ~bus1, \dopon, 1, \glev, 1, \llev, 1, \gbfbus, ~gbfbus, \globTBus, ~globTBus], ~s1, \addAfter)

				    // scServer "s_new" ("HOA_Encode"+$order+"_out") $node_id_out 1 $group_id in $bus globTBus $hoa_bus in_ramp $fade_in amp $amp dopon 1 dopamnt 1 glev 1 llev 1  //gbfbus $rev_bus
				    // print encoder $encoder
				    // print in_channels $in_channels
				    // $hoa_inter_bus := $SC_Servers($server_name)("bus_index") // define nuevo audio bus
					
					/// OpenFrameworks_visual
					$proc_index := $trajs_index
					$trajs.add_pair($proc_index, $xyz_list)
					$trajs_index += 1

					switch //($encoder) + +$hoa_num_ch
					{
						case ($encoder && ($in_channels == "mono")): // mono or in_channels = 1 (|| $in_channels == 1)
						print encoder1 $encoder
						$out_name := "HOA_Encode"+$order+"_out"
						$hoa_inter_bus := $bus+1 //
						$Servers($server_name).s_new([$out_name, $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_inter_bus, "in_ramp", $fade_in, "amp", 0, "dopon", $doppler , "dopamnt", 1, "glev", 1, "llev", 1, "plane_spherical", $plane_spherical, "spk_radius", $spk_radius, "max_radius", $max_radius, "x", $xyz_init_pos[0], "y", $xyz_init_pos[1], "z", $xyz_init_pos[2]])				   				    	
						$SC_Servers($server_name).insert("bus_index", $bus+$hoa_num_ch+1) // +1 = mono input bus incrementa bus de server A ver en funcion del decoder!!!!!!!

						case ($encoder && $in_channels == "stereo"): // Stereo hoa Ambitool panning 
						print encoder2 $encoder
						$out_name := "HOA_Encode_Ste"+$order+"_out"
						$hoa_inter_bus := $bus+2 //
						$Servers($server_name).s_new([$out_name, $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_inter_bus, "in_ramp", $fade_in, "amp", 0, "dopon", $doppler, "dopamnt", 1, "glev", 1, "llev", 1, "plane_spherical", $plane_spherical, "spk_radius", $spk_radius, "max_radius", $max_radius])				   				    	
						$SC_Servers($server_name).insert("bus_index", $bus+$hoa_num_ch+2) // +2 = stereo input incrementa bus de server A ver en funcion del decoder!!!!!!!
							
						// case ($encoder && $in_channels == "24ch"):
						// print encoder2 $encoder
						// $out_name := "HOA_Encode_24ch"+$order+"_out"
						// $hoa_inter_bus := $bus+24 //
						// $Servers($server_name).s_new([$out_name, $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_inter_bus, "in_ramp", $fade_in, "amp", 0, "dopon", $doppler, "dopamnt", 1, "glev", 1, "llev", 1, "plane_spherical", $plane_spherical, "spk_radius", $spk_radius])				   				    	
						// $SC_Servers($server_name).insert("bus_index", $bus+$hoa_num_ch+24) // +2 = stereo input incrementa bus de server A ver en funcion del decoder!!!!!!!

						case ($encoder && $in_channels.is_int()):
						if($in_channels >= 1 && $in_channels <= 24) // maxi 24, can be changed
						{
							print encoder HOA_Ambitools $in_channels channels
							// Version 2 Ambitools HOA_Encode2_1ch7_out
							$out_name := "HOA_Encode2_"+$in_channels+"ch"+$order+"_out"
							$hoa_inter_bus := $bus+$in_channels
							$Servers($server_name).s_new([$out_name, $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_inter_bus, "in_ramp", $fade_in, "amp", 0, "dopon", $doppler, "dopamnt", 1, "glev", 1, "llev", 1, "plane_spherical", $plane_spherical, "spk_radius", $spk_radius])				   				    	
							$SC_Servers($server_name).insert("bus_index", $hoa_inter_bus+$hoa_num_ch) // +2 = stereo input incrementa bus de server A ver en funcion del decoder!!!!!!!
						}
						else
						{
							print wrong number of channels 
						}

						case (! $encoder && ($in_channels == "mono" || $in_channels == 1)): // for pre-hoa stream 
						print encoder3 no encoder $encoder 
						$out_name := "HOA_Out_"+$order
						$hoa_inter_bus := $bus+$hoa_num_ch //add hoa input order channel number	
						$Servers($server_name).s_new([$out_name, $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_inter_bus, "in_ramp", $fade_in, "amp", 0])
						$SC_Servers($server_name).insert("bus_index", $hoa_inter_bus+$hoa_num_ch) // add hoa stream for next bu

						case (! $encoder && $in_channels == "stereo"):
						print "HOA_Group is ambisonic input signal, no stereo input, use encoder = true..."

						case $encoder == "iem":

					}

					// $node_id := $node_id + 1 // incremente de 1 la variable $node_id pour le prochain node
					$SC_Servers($server_name).insert("node_id", $node_id_out + 1)

					// if($encoder) // crée sortie globale du track HOA_Out
					// {
					$node_id_out2 := $SC_Servers($server_name)("node_id")
					$Servers($server_name).s_new(["HOA_Out_"+$order, $node_id_out2, 3, $node_id_out, "in", $hoa_inter_bus, "globTBus", $hoa_bus, "in_ramp", $fade_in, "amp", $amp])	 // "amp", $amp])			   				    	
					$SC_Servers($server_name).insert("node_id", $node_id_out2 + 1)
					// }
					// else
					// {
					// 	$node_id_out2 := $node_id_out // Si pas de encoder 
					// }
				// $SC_Servers($server_name).insert("bus_index", $hoa_num_ch+1) // +1 = mono input incrementa bus de server A ver en funcion del decoder!!!!!!!


				    // if($encoder && $in_channels == "mono") // default mono input Encoder group
				    // {
				    // 	$Servers($server_name).s_new(["HOA_Encode"+$order+"_out", $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_bus, "in_ramp", $fade_in, "amp", $amp, "dopon", $doppler, "dopamnt", 1, "glev", 1, "llev", 1, "spk_radius", $spk_radius])				   				    	
				    // 	$SC_Servers($server_name).insert("bus_index", $bus+$hoa_num_ch) // incrementa bus de server A ver en funcion del decoder!!!!!!!

				    // }

				    // if($encoder && $in_channels == "stereo") // default mono input Encoder group
				    // {
				    // 	$Servers($server_name).s_new(["HOA_Encode_Ste"+$order+"_out", $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_bus, "in_ramp", $fade_in, "amp", $amp, "dopon", $doppler, "dopamnt", 1, "glev", 1, "llev", 1, "spk_radius", $spk_radius])				   				    	
				    // 	$SC_Servers($server_name).insert("bus_index", $bus+1+$hoa_num_ch) // incrementa bus de server A ver en funcion del decoder!!!!!!!

				    // }

				    // if(! $encoder && $in_channels == "mono") // no decoder group 
				    // {
				// 	$Servers($server_name).s_new(["HOA_Group"+$order+"_out", $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_bus, "in_ramp", $fade_in, "amp", $amp])
				    // }
				    // print ("s_new"+$server_name) ("HOA_Encode"+$order+"_out") $node_id_out 1 $group_id in $bus  globTBus $hoa_bus in_ramp $fade_in amp $amp dopon 1 dopamnt 1 glev 1 llev 1  //gbfbus $rev_bus

				    // ~espace = Synth(\ATK_Omni_8_new, [\in,  ~bus1, \dopon, 1, \glev, 1, \llev, 1, \gbfbus, ~gbfbus, \globTBus, ~globTBus], ~s1, \addAfter)
				    $synths_map($server_name)($mix_group)($track_name).insert("group", $group_id)
					$synths_map($server_name)($mix_group)($track_name).insert("audioOut8", $node_id_out)

					////// 
					$tracks.add_pair($track_name, $THISOBJ) // put this group object in dico $group


					/// node structure
					if ($sc_struct($server_name)($group_id).is_undef()) // if group_id exist on the program
					{
						$struct_main_group_id := $sc_struct($server_name)($main_group_id)[0]
						$struct_main_group_id.push_front($group_id) // !!!!!! !!!!! root tree 0


						$sc_struct($server_name).add_pair($group_id, [[$node_id_out2], map {("track_name", $track_name), ("encoder", $encoder), ("in_channels", $in_channels), ("amp", $amp), ("doppler", $doppler), ("dopamnt", 1), ("fade_in", $fade_in), ("track_id", $group_id), ("in", $bus) }]) // crea nueva key group + audioOut
						$struct_group_id := $sc_struct($server_name)($group_id)[0]
						$struct_group_id.push_front($node_id_out) // 

						$sc_struct($server_name).add_pair($node_id_out, map{("out_encoder", $out_name), ("globTBus", $hoa_inter_bus), ("in", $bus), ("in_ramp", $fade_in), ("amp", 0), ("dopon", $doppler), ("dopamnt", 1), ("glev", 1), ("llev", 1), ("encoder", $encoder), ("in_channels", $in_channels), ("plane_spherical", $plane_spherical), ("spk_radius", $spk_radius) }) // , ("gbfbus", $rev_bus) crea MAP para nombre_synth + parametros
						$sc_struct($server_name).add_pair($node_id_out2, map{("track_output", "HOA_Out_"+$order), ("globTBus", $hoa_inter_bus), ("in", $hoa_inter_bus), ("globTBus", $hoa_bus), ("in_ramp", $fade_in), ("amp", $amp) }) // , ("gbfbus", $rev_bus) crea MAP para nombre_synth + parametros
					}

					// $rev_bus := $SC_Servers($server_name)("bus_index")
					// $SC_Servers($server_name).insert("bus_index", $bus+4) // incrementa bus de server para ambi rev

				    
				    $SC_Groups($mix_group)("sub_group").add_pair($track_name, $THISOBJ) // store thisobject in TAB of SC_Groups(mix_group)

				    if($synth_collection.size()>0)
				    {
					$THISOBJ.mod_add($synth_collection)
					}
						// forall $x in $synth_collection
					    // {
					    //         $THISOBJ.mod_add($x)
					    // } 
				}
				    else
					{
						print track $track_name already exists
					}
				}
			}
   }

   @fun_def mod_add($module, $action = "before_out", $target_mod = <undef>, $fade_in = 0.01, $ext_id = false)
   {
	@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod, $target_id, $mod_name, $json_file, $json_map, $vst_module

	if($ext_id.is_numeric()) // externally defined node_id 
	{
		$node_id_mod := $ext_id
		$target_mod := $node_id_out
		// print node_id externe $ext_id
	}
	else
	{
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
	}
	
    if($target_mod.is_undef())
    {
		$target_mod := $node_id_out
    }

	// print node_id externe $ext_id
    // print node_id_mod $node_id_mod 

    if($struct_group_id.member($node_id_mod))
    {
    	print this synth id already exist
    }
    else
    {
    	$target_id := $synths_map($server_name)($mix_group)($track_name)($target_mod)[0] // recupera $target_id

    // print modules_synth1 (""+$module)

    // print size ($module.size())
    // print params $params
    if ($module.dim() > 1 && $module.car().is_tab()){ // si c'est tab multi
    // print MULTI_
	forall $chain in $module // s'il y a plus des modules
	{
		// print chain_synth1 $chain
		$mod_name := $chain.car()
		
		// if($chain[0] == "VST")
		// {
		// $vst_module := $chain[1] // VST module name
		
		if($vst_all_map.is_defined($mod_name)) // VST existe?
		{	    		
				$vst_module := $mod_name
				// $mod_name := $vst_module
	   //  		if($vst_all_map.is_defined($vst_module)) // VST existe?
				// {
					// if($vst_all_map.is_defined($mod_name)) // VST existe?
					// {
			if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
		    {
				// $mod_name := $mod_name+".vst3"
				$vst_module := $mod_name+".vst3"
		    }
			// $vst_id := $vst_plugins($server_name)($group_name)($mod_name) // retrieve vst node_id
						// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
			// }
			// else
			// {
			// 	print "module not found"
			// }


				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						$struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(@occurs($struct_group_id, $target_id)+1, $node_id_mod) // root tree 0
						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])		   		
						$struct_group_id.insert(@occurs($struct_group_id, $target_id), $node_id_mod) // root tree 0
						case "top":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(0, $node_id_mod) // root tree 0

					}
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
				$vst_plugins($server_name)($mix_group)($track_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins

			$params := $chain.cdr()
			if($params.car() == "preset")
			{
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/program_read", $vst_presets+$vst_all_map($mod_name)("vendor")+"/"+$mod_name+"/"+$params[1], 1]) // 6 = UGen id inside Synthdef
				print preset (""+$vst_presets+$vst_all_map($mod_name)("vendor")+"/"+$mod_name+"/"+$params[1])
			}

		}
		else
		{
			$params := $chain.cdr()
		
			// print test_syn1_params (""+$params)
				// scServer "s_new" ($chain[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])
					// print $params
			if($params.car() == "preset"){
				@local $params_preset, $par_init, $inc := 0

				$json_file := $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"

				$json_file := @json_read($json_file)
				// print JSON (""+$json_file($mod_name)($params[1]))

				$params_preset := $json_file($mod_name)($params[1]) // recupere la map du preset
				if($params_preset.is_undef())
				{
					print "this preset does not exist"
				}
				else
				{
					$par_init := $params.drop(2)

					loop 
					{
						$params_preset.add_pair($par_init[$inc], $par_init[$inc+1]) // replace parameters after 
						$inc += 2
					} until ($inc==$par_init.size())

					$params := $params_preset.map2tab() // convert map to tab
				}
			}

				switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
					$struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
					$struct_group_id.insert(@occurs($struct_group_id, $target_id)+1, $node_id_mod) // root tree 0

					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
					$struct_group_id.insert(@occurs($struct_group_id, $target_id), $node_id_mod) // root tree 0

					case "top":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
					$struct_group_id.insert(0, $node_id_mod) // root tree 0

				}
			}

			// $struct_group_id.insert($synth_id_index, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $bus), ("out", $bus), ("node_id", $node_id_mod)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			// $synth_id_index += 1
			// print synth_id_indexsynth_id_index $synth_id_index
			// print params ($synths_map($track_name)($mix_group)($mod_name))

			if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($mod_name) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
			}else 
			{
				// print ($mod_name) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod) // si existe rajouter a la TAB

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		$node_id_mod := $SC_Servers($server_name)("node_id") // set prochain id au nouveau id ligne precedente


		}
		}else{
			if($module.is_tab()) // si c'est tab 1 dim
			{
				// print DIM 1
				// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
				
				$mod_name := $module.car()

				// if($mod_name == "VST") // if VST plugins
			// {
				// $vst_module := $module[1] // VST module name	    		

			if($vst_all_map.is_defined($mod_name))
				{	    		
				
					$vst_module := $mod_name // VST module name	    		

				// $mod_name := $vst_module

		   //  		if($vst_all_map.is_defined($vst_module))
					// {
				// if($vst_all_map.is_defined($mod_name)) // VST existe?
				// {
				if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
				    {
					$vst_module := $mod_name+".vst3"
				    }
					// $vst_id := $vst_plugins($server_name)($group_name)($mod_name) // retrieve vst node_id
					// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
				// }
				// else
				// {
				// 	print "module not found"
				// }					
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						$struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0

						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(@occurs($struct_group_id, $target_id)+1, $node_id_mod) // root tree 0

						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])		   		
						$struct_group_id.insert(@occurs($struct_group_id, $target_id), $node_id_mod) // root tree 0

						case "top":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(0, $node_id_mod) // root tree 0

					}
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
				$vst_plugins($server_name)($mix_group)($track_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins

				$params := $chain.cdr()
				if($params.car() == "preset")
				{
					$Servers($server_name).u_cmd([$node_id_mod, 6, "/program_read", $vst_presets+$vst_all_map($mod_name)("vendor")+"/"+$mod_name+"/"+$params[1], 1]) // 6 = UGen id inside Synthdef
					print preset (""+$vst_presets+$vst_all_map($mod_name)("vendor")+"/"+$mod_name+"/"+$params[1])
				}
			}
			else
			{
				$params := $module.cdr()
			
					// print $params
					if($params.car() == "preset"){
						@local $params_preset, $par_init, $inc := 0

						$json_file := $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"

						$json_file := @json_read($json_file)
						// print JSON (""+$json_file($mod_name)($params[1]))

						$params_preset := $json_file($mod_name)($params[1]) // recupere la map du preset
						if($params_preset.is_undef())
						{
							print "this preset does not exist"
						}
						else
						{
							$par_init := $params.drop(2)

							loop 
							{
								$params_preset.add_pair($par_init[$inc], $par_init[$inc+1]) // replace parameters after 
								$inc += 2
							} until ($inc==$par_init.size())

							$params := $params_preset.map2tab() // convert map to tab
						}
					}

					// scServer "s_new" ($module[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
					// $Servers($server_name).s_new([$module[0], $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

					switch ($action)
				{
					case "before_out":
					 // @set_osc_handling_tab(1) ///SuperCollider a diferencia de antescofo/sclang
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
						$struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0

						// print titititi (""+[$mod_name, $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in, $params])
						// print params (""+$params)
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
						$struct_group_id.insert(@occurs($struct_group_id, $target_id)+1, $node_id_mod) // root tree 0

						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
						$struct_group_id.insert(@occurs($struct_group_id, $target_id), $node_id_mod) // root tree 0

						case "top":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
						$struct_group_id.insert(0, $node_id_mod) // root tree 0

					}			   	
				}
				// $synths_map($server_name)($mix_group)($track_name).insert($mod_name, $node_id_mod)
				// $struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0
				// $struct_group_id.insert($synth_id_index, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				// $synth_id_index += 1

				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($mod_name) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod])
				}else 
				{
					// print ($mod_name) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod)

				}
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))
				
				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
			else
			{
				print este
				// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new" ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$module, $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				$mod_name := $module

			if($vst_all_map.is_defined($mod_name))
				{	    		
				
					$vst_module := $mod_name // VST module name	    		

				// $mod_name := $vst_module

		   //  		if($vst_all_map.is_defined($vst_module))
					// {
				// if($vst_all_map.is_defined($mod_name)) // VST existe?
				// {
				if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
			    {
					$vst_module := $mod_name+".vst3"
			    }
					// $vst_id := $vst_plugins($server_name)($group_name)($mod_name) // retrieve vst node_id
					// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
				// }
				// else
				// {
				// 	print "module not found"
				// }	
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						$struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0

						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(@occurs($struct_group_id, $target_id)+1, $node_id_mod) // root tree 0

						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])		   		
						$struct_group_id.insert(@occurs($struct_group_id, $target_id), $node_id_mod) // root tree 0

						case "top":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(0, $node_id_mod) // root tree 0

				}
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
				$vst_plugins($server_name)($mix_group)($track_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins

				$params := $chain.cdr()
				if($params.car() == "preset")
				{
					$Servers($server_name).u_cmd([$node_id_mod, 6, "/program_read", $vst_presets+$vst_all_map($mod_name)("vendor")+"/"+$mod_name+"/"+$params[1], 1]) // 6 = UGen id inside Synthdef
					print preset (""+$vst_presets+$vst_all_map($mod_name)("vendor")+"/"+$mod_name+"/"+$params[1])
				}
			
			}
			else
			{
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						$struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0

						case "after":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(@occurs($struct_group_id, $target_id)+1, $node_id_mod) // root tree 0

						case "before":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])		   		
						$struct_group_id.insert(@occurs($struct_group_id, $target_id), $node_id_mod) // root tree 0

						case "top":
						$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
						$struct_group_id.insert(0, $node_id_mod) // root tree 0

				}
			}
				// $struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0
				// $struct_group_id.insert($synth_id_index, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				// $synth_id_index += 1

				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
					
				if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($mod_name) is not member at $node_id_mod
					// ($synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod])).post()
					$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod])
				}else 
				{
					// print ($mod_name) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod)

				}

				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
			
		}
    }


	
	}

   @fun_def group_add($module, $action = "before_out", $target_mod = <undef>, $fade_in = 0.01, $channels = 1)
   {
	@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod, $target_id, $mod_name, $json_file, $json_map, $vst_module, $sub_group_id, $sub_group_bus, $local_group_id_out	
	
 //    if($target_mod.is_undef())
 //    {
	// $target_mod := $node_id_out
 //    }
 	// new group id
    $sub_group_id := $SC_Servers($server_name)("node_id")
    $Servers($server_name).g_new($sub_group_id, 0, $group_id)
    $SC_Servers($server_name).add_pair("node_id", $sub_group_id + 1) // incremente node id
    // print sub_group_id $sub_group_id
    // new bus
    $sub_group_bus := $SC_Servers($server_name)("bus_index")
    $SC_Servers($server_name).insert("bus_index", $sub_group_bus+$channels) // incremente bus id (+1 mono)
 	// print sub_group_bus $sub_group_bus

 	// $local_group_id_out := $SC_Servers($server_name)("node_id")
 	// $Servers($server_name).s_new(["HOA_Out_"+$order, $local_group_id_out, 1, $sub_group_id, "in", $sub_group_bus, "globTBus", $bus, "in_ramp", $fade_in, "amp", $amp]) //$gbus+$chnl_offset
  //   $SC_Servers($server_name).add_pair("node_id", $local_group_id_out + 1) // incremente node id
    // print local_group_id_out $local_group_id_out
    // $target_id := $synths_map($server_name)($mix_group)($track_name)($target_mod)[0] // recupera $target_id
	$target_id := $sub_group_id
	$target_mod := $sub_group_id
    // print modules_synth1 (""+$module)

    $node_id_mod := $SC_Servers($server_name)("node_id") // last id
    // print node_id_mod $node_id_mod
    // print size ($module.size())
    // print params $params
    if ($module.dim() > 1 && $module.car().is_tab()){ // si c'est tab multi
    // print MULTI_GROUP
	forall $chain in @reverse($module) // reverse pour commencer par la fin (Out, Env) // s'il y a plus des modules
	{
		// print chain_synth1 $chain
		$mod_name := $chain.car()
		// print module (""+$chain)
		// if($chain[0] == "VST")
		// {
		// $vst_module := $chain[1] // VST module name
		
		if($vst_all_map.is_defined($mod_name)) // VST existe?
		{	    		
				// $vst_module := $mod_name
				// $mod_name := $vst_module
	   //  		if($vst_all_map.is_defined($vst_module)) // VST existe?
				// {
					// if($vst_all_map.is_defined($mod_name)) // VST existe?
					// {
			if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
		    {
				$mod_name := $mod_name+".vst3"
		    }
			// $vst_id := $vst_plugins($server_name)($group_name)($mod_name) // retrieve vst node_id
						// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
			// }
			// else
			// {
			// 	print "module not found"
			// }
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 0, $target_mod, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 3, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])		   		
						case "top":
						$Servers($server_name).s_new(["VST_2", $node_id_mod, 0, $group_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
					}
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $mod_name, 1, 0, 0]) // 6 = UGen id inside Synthdef
				$vst_plugins($server_name)($mix_group)($track_name).insert($mod_name, $node_id_mod) // dictionaire pour les id des vst_plugins
				// }
				// else
				// {
				// 	print vst $vst_module does not exist
				// }		    		
		}
		else
		{
			$params := $chain.cdr()
		
			// print test_syn1_params (""+$params)
				// scServer "s_new" ($chain[0]) $node_id_mod 2 $node_id_out in $sub_group_bus out $sub_group_bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $node_id_out, "in", $sub_group_bus, "out", $sub_group_bus, $params, "matrix_ramp", $fade_in_mod])

				switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $sub_group_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))
					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))		   		
					case "top":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))
				}
			}

			$struct_group_id.insert(@size($struct_group_id)-3, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $sub_group_bus), ("out", $sub_group_bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($track_name)($mix_group)($mod_name))

			if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($mod_name) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
			}else 
			{
				// print ($mod_name) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod) // si existe rajouter a la TAB

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		$node_id_mod := $SC_Servers($server_name)("node_id") // set prochain id au nouveau id ligne precedente


		}
	}else{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			// print DIM 1
			// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
			
			$mod_name := $module.car()

			// if($mod_name == "VST") // if VST plugins
		// {
			// $vst_module := $module[1] // VST module name	    		

		if($vst_all_map.is_defined($mod_name))
			{	    		
			
				// $vst_module := $mod_name // VST module name	    		

			// $mod_name := $vst_module

	   //  		if($vst_all_map.is_defined($vst_module))
				// {
			// if($vst_all_map.is_defined($mod_name)) // VST existe?
			// {
			if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
			    {
				$mod_name := $mod_name+".vst3"
			    }
				// $vst_id := $vst_plugins($server_name)($group_name)($mod_name) // retrieve vst node_id
				// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
			// }
			// else
			// {
			// 	print "module not found"
			// }					
			switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_mod, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 3, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])		   		
					case "top":
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 0, $group_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
				}
			$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $mod_name, 1, 0, 0]) // 6 = UGen id inside Synthdef
			$vst_plugins($server_name)($mix_group)($track_name).insert($mod_name, $node_id_mod) // dictionaire pour les id des vst_plugins
				// }
				// else
				// {
				// 	print vst $vst_module does not exist
				// }
		}
		else
		{
			$params := $module.cdr()
		
				// print $params
				if($params.car() == "preset"){
					@local $params_preset, $par_init, $inc := 0

					$json_file := $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"

					$json_file := @json_read($json_file)
					// print JSON (""+$json_file($mod_name)($params[1]))

					$params_preset := $json_file($mod_name)($params[1]) // recupere la map du preset
					if($params_preset.is_undef())
					{
						print "this preset does not exist"
					}
					else
					{
						$par_init := $params.drop(2)

						loop 
						{
							$params_preset.add_pair($par_init[$inc], $par_init[$inc+1]) // replace parameters after 
							$inc += 2
						} until ($inc==$par_init.size())

						$params := $params_preset.map2tab() // convert map to tab
					}
				}

				// scServer "s_new" ($module[0]) $node_id_mod 2 $node_id_out in $sub_group_bus out $sub_group_bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$module[0], $node_id_mod, 2, $node_id_out, "in", $sub_group_bus, "out", $sub_group_bus, $params, "matrix_ramp", $fade_in_mod])

				switch ($action)
			{
				case "before_out":
				 // @set_osc_handling_tab(1) ///SuperCollider a diferencia de antescofo/sclang
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
					// print titititi (""+[$mod_name, $node_id_mod, 2, $target_mod, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in, $params])
					// print params (""+$params)
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))
					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))		   		
					case "top":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in].concat($params))
				}			   	
			}
			// $synths_map($server_name)($mix_group)($track_name).insert($mod_name, $node_id_mod)
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-3, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $sub_group_bus), ("out", $sub_group_bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($mod_name) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod])
			}else 
			{
				// print ($mod_name) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			print este
			// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// scServer "s_new" ($module) $node_id_mod 2 $node_id_out in $sub_group_bus out $sub_group_bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			// $Servers($server_name).s_new([$module, $node_id_mod, 2, $node_id_out, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in_mod])
			// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
			$mod_name := $module

		if($vst_all_map.is_defined($mod_name))
			{	    		
			
				// $vst_module := $mod_name // VST module name	    		

			// $mod_name := $vst_module

	   //  		if($vst_all_map.is_defined($vst_module))
				// {
			// if($vst_all_map.is_defined($mod_name)) // VST existe?
			// {
			if($vst_all_map($mod_name)("sdkversion")[4] == "3") // pour VST3
			    {
				$mod_name := $mod_name+".vst3"
			    }
				// $vst_id := $vst_plugins($server_name)($group_name)($mod_name) // retrieve vst node_id
				// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
			// }
			// else
			// {
			// 	print "module not found"
			// }	
			switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_mod, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 3, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 2, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])		   		
					case "top":
					$Servers($server_name).s_new(["VST_2", $node_id_mod, 0, $group_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
				}
			$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $mod_name, 1, 0, 0]) // 6 = UGen id inside Synthdef
			$vst_plugins($server_name)($mix_group)($track_name).insert($mod_name, $node_id_mod) // dictionaire pour les id des vst_plugins
				// }
				// else
				// {
				// 	print vst $vst_module does not exist
				// }
		}
		else
		{
				switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_mod, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
					case "after":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 3, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
					case "before":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 2, $target_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])		   		
					case "top":
					$Servers($server_name).s_new([$mod_name, $node_id_mod, 0, $group_id, "in", $sub_group_bus, "out", $sub_group_bus, "matrix_ramp", $fade_in])
				}
			}
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-3, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $mod_name), ("in", $sub_group_bus), ("out", $sub_group_bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
				
			if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($mod_name) is not member at $node_id_mod
				// ($synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod])).post()
				$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod])
			}else 
			{
				// print ($mod_name) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
		
	}
	}

	@fun_def mod_add_top($module, $fade_in_mod = 0.1)
	{
		@local $addmod_index := 0, $params, $node_id_mod

		// $fade_in_mod := 0 // deberia ser un argumento opcional!!
		// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
		// print modulos $module
	    // print groupo $group_id
	    // print node_id $node_id
	    // print size ($module.dim())
	    // print params $params
	    if ($module.dim() > 1){ // si c'est tab multi
	    // print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
			// print params $params
				// scServer "s_new" ($chain[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$chain[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))  //target 2 justo despues del nodo 180 audioOut


				// $synths_map($server_name)($mix_group)($track_name).insert($chain[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

				}

				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}else{ 
			if($module.is_tab()) // si c'est tab 1 dim
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// print params $params
				// scServer "s_new" ($module[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$module[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])
				$Servers($server_name).s_new([$module[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))  //target 2 justo despues del nodo 180 audioOut

				// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

				}
				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}else{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new"($module) $node_id_mod 0 $group_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$module, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
				$Servers($server_name).s_new([$module, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))  //target 2 justo despues del nodo 180 audioOut

				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

				}
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}


	@fun_def mod_add_botton($module, $fade_in_mod = 0.1)
	{
		@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod

	    if ($module.dim() > 1){ // si c'est tab multi
	    // print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
			// print params $params
				// scServer "s_new" ($chain[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))

				// $synths_map($server_name)($mix_group)($track_name).insert($chain[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

				}

				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}else{ 
			if($module.is_tab()) // si c'est tab 1 dim
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// print params $params
				// scServer "s_new" ($module[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))

				// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

				}
				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}else{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new"($module) $node_id_mod 0 $group_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

				}
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}

	@fun_def mod_after($module, $mod_after)
	{
		@local $addmod_index := 0, $params, $fade_in_mod, $mod_after_id, $node_id_mod

		$fade_in_mod := 1 // deberia ser un argumento opcional!!
		// $node_id_mod := $SC_Servers($server_name)("node_id") // last id

	    $mod_after_id := $synths_map($server_name)($mix_group)($track_name)($mod_after)[0] // recupera $mod_after id

	    "post".post()
		$node_id_mod.post()
		$mod_after_id.post()
		"post".post()

	    if ($module.dim() > 1){ // si c'est tab multi
	    print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
				// scServer "s_new" ($chain[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				// print params ($synths_map($server_name)($mix_group)($track_name)($chain[0]))

				if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

				}
			   
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}
		else
		{
			if($module.is_tab()) // si c'est tab 1 dim
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// scServer "s_new" ($module[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
				// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

				}
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))
				
				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
			else
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new" ($module) $node_id_mod 3 $mod_after_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

				}

				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
				
		}
	}

	@fun_def mod_before($module, $mod_before)
	{
	@local $addmod_index := 0, $params, $fade_in_mod, $mod_before_id, $node_id_mod
	$fade_in_mod := 1 // deberia ser un argumento opcional!!
	// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
    $mod_before_id := $synths_map($server_name)($mix_group)($track_name)($mod_before)[0] // recupera $mod_after id
    // print (""+$synths_map($server_name)($mix_group)($track_name))
    // print size ($module.dim())
    // print params $params
    if ($module.dim() > 1){ // si c'est tab multi
    // print MULTI_
	forall $chain in $module // s'il y a plus des modules
	{
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		// print $chain
		$params := $chain.cdr()
			// scServer "s_new" ($chain[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($server_name)($mix_group)($track_name)($chain[0]))

			if(($synths_map($server_name)($mix_group)($track_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($chain[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($chain[0], [$node_id_mod])
			}else 
			{
				print ($chain[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($chain[0]).push_back($node_id_mod)

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
	}
	else
	{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			$params := $module.cdr()
			// scServer "s_new" ($module[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod].concat($params))
			// $synths_map($server_name)($mix_group)($track_name).insert($module[0], $node_id_mod)
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($mix_group)($track_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($module[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($module[0], [$node_id_mod])
			}else 
			{
				print ($module[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($module[0]).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// scServer "s_new"($module) $node_id_mod 2 $mod_before_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$module, $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
			// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($module) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod]) // tab dans le cas de plusieurs instances du même module
			}else 
			{
				print ($module) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
			
	}
	}


	@proc_def mod_remove($module, $time_off = 0.1)
	{
	
		print remove (""+($synths_map($server_name)($mix_group)($track_name)($module)))
		forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		{			
			// scServer "n_set" $node matrix_ramp $time_off free 0
			$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])
			$sc_struct($server_name).remove($node)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
			if($track_proc($server_name)($mix_group)($track_name)($node).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
				{
					abort $proc 
				}
			}
			// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		}
	// }
		$synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_remove_id($nodes, $time_off = 0.1)
	{
		if($nodes.is_tab())
		{
			forall $x in $nodes
			{
				// scServer "n_set" $x matrix_ramp $time_off free 0
				$Servers($server_name).n_set($x, ["matrix_ramp", $time_off, "free", 0])
				_ := $synths_map($server_name)($mix_group)($track_name).remove($sc_struct($server_name)($group_id)($x)("_synth"))
				$sc_struct($server_name)($server_name).remove($x)
				_ := $sc_struct($server_name)($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($x))
				if($track_proc($server_name)($mix_group)($track_name)($x).size() != 0) // abort proc des modules
				{	
					$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($x) // parcours le dico de proc
					{
						abort $proc 
					}
				}	
			}
		}
		else
		{
			// scServer "n_set" $nodes matrix_ramp $time_off free 0
			$Servers($server_name).n_set($nodes, ["matrix_ramp", $time_off, "free", 0])
			_ := $synths_map($server_name)($mix_group)($track_name).remove($sc_struct($server_name)($group_id)($nodes)("_synth"))
			$sc_struct($server_name).remove($nodes)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($nodes))
			if($track_proc($server_name)($mix_group)($track_name)($nodes).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($nodes) // parcours le dico de proc
				{
					abort $proc 
				}
			}
		}	
	}

	@proc_def mod_remove_single($module, $num, $time_off = 0.1) // quand il y a plusieurs instances d'un même module, sinon utiliser la methode mod_remove
	{
		@local $node
		$node := $synths_map($server_name)($mix_group)($track_name)($module)[$num]
		// scServer "n_set" $node matrix_ramp $time_off free 0
		$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])

		$sc_struct($server_name).remove($node)
		$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		_ := $synths_map($server_name)($mix_group)($track_name)($module).remove($synths_map($server_name)($mix_group)($track_name)($module).occurs($node))
		
		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		{
			abort $proc 
		}
	_ := $synths_map($server_name)($mix_group)($track_name).remove($node)	
	}

	@fun_def mod_replace($module_old, $module_new, $cross_fade = 1)
	{
		$THISOBJ.mod_remove($module_old, $cross_fade)
		$THISOBJ.mod_add($module_new, fade_in = $cross_fade)
	}

	@proc_def mod_move_before($module, $mod_mov_before)
	{
		// n_before ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])

		print n_before ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])

		// scServer "n_before" ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])

		$Servers($server_name).n_before([$synths_map($server_name)($mix_group)($track_name)($module), $synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0]])


		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_move_before_id($module_id, $mod_mov_before_id)
	{
		n_before $module_id $mod_mov_before_id

		print n_before $module_id $mod_mov_before_id

		// scServer "n_before" $module_id $mod_mov_before_id
		$Servers($server_name).n_before([$module_id, $mod_mov_before_id])


		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_move_after($module, $mod_mov_after)
	{
		// n_after ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0])

		print n_after ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0])

		// scServer "n_after" ($synths_map($server_name)($mix_group)($track_name)($module)) ($synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0])
		$Servers($server_name).n_after([$synths_map($server_name)($mix_group)($track_name)($module), $synths_map($server_name)($mix_group)($track_name)($mod_mov_after)[0]])


		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_move_after_id($module_id, $mod_mov_after_id)
	{
		// n_after $module_id $mod_mov_after_id

		print n_after $module_id $mod_mov_after_id

		// scServer "n_after" $module_id $mod_mov_after_id

		$Servers($server_name).n_after([$module_id, $mod_mov_after_id])

		// forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($track_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($track_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($track_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($track_name).remove($module)
	}

	@proc_def mod_rand()
	{
		@local $audioOut_val, $track_node_list, $group_va
		$group_val := $synths_map($server_name)($mix_group)($track_name)("group")
		// print toto (""+$synths_map($server_name)($mix_group)($track_name)("group"))
		$audioOut_val := $synths_map($server_name)($mix_group)($track_name)("audioOut8")
		// print tata (""+$synths_map($server_name)($mix_group)($track_name)("audioOut8"))
		$track_node_list := $sc_struct($server_name)($group_val)
		print ttrack_node $track_node_list
		// print mix_group (""+$track_name)
		// print titi (""+$sc_struct($server_name)($group_val)($track_name))
		// $Servers($server_name).n_before($synths_map($server_name)($mix_group)($track_name)($module), $synths_map($server_name)($mix_group)($track_name)($mod_mov_before)[0])
		
		$track_node_list := $track_node_list.rotate(1)
		// print tutu (""+$track_node_list.rotate(1))
		$track_node_list := $track_node_list.cdr()
		// print tete (""+$track_node_list.cdr())
		$track_node_list := $track_node_list.scramble()
		// print tretre (""+$track_node_list.scramble())
		$track_node_list := $track_node_list.push_back($audioOut_val)
		// print tyu (""+$track_node_list.push_back($audioOut_val))
		// print ("n_order"+$server_name) 0 $group_val (""+$track_node_list)
		// @command("n_order"+$server_name) 0 $group_val $track_node_list
		// scServer "n_order" 0 $group_val $track_node_list
		$Servers($server_name).n_order(0, $group_val, $track_node_list)
		// $track_node_list := @remove($sc_struct($server_name)($group_val), $audioOut_val)
		// $track_node_list := $track_node_list.scramble
		// print audioOut_val (""+$audioOut_val)
		// print group_val (""+$group_val)
		// print track_node_list (""+$track_node_list)
		// print (""+$sc_struct($server_name))
		// print (""+$sc_struct($server_name)($group_val))

		// print (""+($synths_map($server_name)($mix_group)($track_name)("group")))
		// print (""+$sc_struct($server_name))

		// @command("n_after"+$server_name) $module_id $mod_mov_after_id
	}

   @fun_def master_vst($module, $action = "before_out", $target_mod = <undef>, $fade_in = 0.01)
   {
	@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod, $target_id, $mod_name, $json_file, $json_map, $vst_module

	$node_id_mod := $SC_Servers($server_name)("node_id") // last id

    if($target_mod.is_undef())
    {
	$target_mod := $node_id_out2
    }
    $target_id := $synths_map($server_name)($mix_group)($track_name)($target_mod)[0] // recupera $target_id
    // print target_id_master_vst $target_id


    print vst_module $module 

    if($vst_all_map.is_defined($module)) // si vst existe
	{



	    // print modules_synth1 (""+$module)

	    // print size ($module.size())	
	    // print params $params
	    if ($module.dim() > 1 && $module.car().is_tab()){ // si c'est tab multi
	    // print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			// print chain_synth1 $chain
			// $mod_name := $chain.car()

				$vst_module := $chain[0] // VST module name
				// $mod_name := ($chain[0]+"_"+$vst_module)
				$mod_name := $vst_module
				if($vst_all_map($module)("sdkversion")[4] == "3") // pour VST3
				    {
					$vst_module := $vst_module+".vst3"
				    }
				switch ($action)
				{
					case "before_out":
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_mod, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
						case "after":
						// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 3, $target_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])
						case "before":
						// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])		   		
						case "top":
						$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 0, $group_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])
					}
				$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
				$vst_plugins($server_name)($mix_group)($track_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins



				$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_vst", $mod_name), ("in", $hoa_inter_bus), ("out", $hoa_inter_bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
				
				// print params ($synths_map($track_name)($mix_group)($mod_name))

				if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($mod_name) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
				}else 
				{
					// print ($mod_name) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod) // si existe rajouter a la TAB

				}
			   
			 //   	loop 
				// {
				// 	$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				// 	$addmod_index := $addmod_index + 2
				// } while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			$node_id_mod := $SC_Servers($server_name)("node_id") // set prochain id au nouveau id ligne precedente


			}
		}
		else
		{
			if($module.is_tab()) // si c'est tab 1 dim
			{
				// print DIM 1
				// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
				
				$mod_name := $module.car()
			
			// $vst_module := $module[1] // VST module name
			switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_mod, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 3, $target_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])
					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])		   		
					case "top":
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 0, $group_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])
				}

			$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $mod_name, 1, 0, 0]) // 6 = UGen id inside Synthdef
			$vst_plugins($server_name)($mix_group)($track_name).insert($mod_name, $node_id_mod) // dictionaire pour les id des vst_plugins
				
				// $synths_map($server_name)($mix_group)($track_name).insert($mod_name, $node_id_mod)
				$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_vst", $mod_name), ("in", $hoa_inter_bus), ("out", $hoa_inter_bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($track_name)($mod_name)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($mod_name) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name).insert($mod_name, [$node_id_mod])
				}
				else 
				{
					// print ($mod_name) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($mod_name).push_back($node_id_mod)

				}
			 //   	loop 
				// {
				// 	$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				// 	$addmod_index := $addmod_index + 2
				// } while ($addmod_index+2 <= @size($params))
				
				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
			else
			{
				print este
				// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new" ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				// $Servers($server_name).s_new([$module, $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
				// $synths_map($server_name)($mix_group)($track_name).insert($module, $node_id_mod)
				if($vst_all_map($module)("sdkversion")[4] == "3") // pour VST3
			    {
				$vst_module := $module+".vst3"
				print vst_module $vst_module
			    }
			    else
			    {
				$vst_module := $module
				print vst_module $vst_module
			    }
			switch ($action)
			{
				case "before_out":
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_mod, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
					case "after":
					// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 3, $target_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])
					case "before":
					// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 2, $target_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])		   		
					case "top":
					$Servers($server_name).s_new(["VST_HOA_Insert"+$order, $node_id_mod, 0, $group_id, "in", $hoa_inter_bus, "globTBus", $hoa_inter_bus, "matrix_ramp", $fade_in])
				}

			$Servers($server_name).u_cmd([$node_id_mod, 6, "/open", $vst_module, 1, 0, 0]) // 6 = UGen id inside Synthdef
			$vst_plugins($server_name)($mix_group)($track_name).insert($vst_module, $node_id_mod) // dictionaire pour les id des vst_plugins
			
				$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $hoa_inter_bus), ("out", $hoa_inter_bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($track_name).insert($node_id_mod, map{}) // dictionaire pour les processus
					
				if(($synths_map($server_name)($mix_group)($track_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					// ($synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])).post()
					$synths_map($server_name)($mix_group)($track_name).insert($module, [$node_id_mod])
				}
				else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($track_name)($module).push_back($node_id_mod)

				}

				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}
	else
	{
		print "vst not found"
	}
}

	@fun_def set($module, $params)
	{
		@local $vst_nodeID, $vst_param_index, $loop_index := 0, $vst_params_tab := []
		// print scServer "n_set" $module $params
		// print scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)) $params
		// if($module.is_tab())
		// {
			// if($module[0] == "VST") // ["VST", "my_plugins"]
			// {
		if($vst_all_map.is_defined($module)) // VST existe?
		{	
			$vst_nodeID := $vst_plugins($server_name)($mix_group)($track_name)($module) // retrieve id des vst_plugins
			// $vst_param_index := $vst_all_map($vst_name)("parameters")($param)
			
			
			loop
			{
				// print ($a[$idx])
				if($vst_all_map($module)("parameters").is_defined($params[$loop_index]))
				{
					$vst_params_tab.push_back($vst_all_map($module)("parameters")($params[$loop_index])) // parameter to vst index
					$vst_params_tab.push_back(@to_char($params[$loop_index+1])) // value non normalized
				}
				else
				{
					if($params[$loop_index] == "bypass") // parameter of SynthDef, not VST UGEN
					{
						$Servers($server_name).n_set($vst_nodeID, ["bypass", $params[$loop_index+1]])
					}
					else
					{
						print parameter ($params[$loop_index]) does not exist
					}
				}

				$loop_index += 2
			} until ($loop_index == @size($params))

			$Servers($server_name).u_cmd([$vst_nodeID, 6, "/set"].concat($vst_params_tab)) // 6 = UGen id inside Synthdef

		}
		// }
		else
		{
			forall $x in ($synths_map($server_name)($mix_group)($track_name)($module))
			{
				// scServer "n_set" $x $params
				$Servers($server_name).n_set($x, $params)
				forall $i in $params.size()-1 // store param/val in $struct map
				{
					$sc_struct($server_name)($x).add_pair($params[$i], $params[$i+1]) 
				}
			}

		}
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)) 
		// $sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq") := 100
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module)))
	}

	@proc_def s_get($module, $param) // call param from server a faire directement dans antescofo $struct
	{
		// print getget (""+[$synths_map($server_name)($mix_group)($track_name)($module)[0], $param])
		$Servers($server_name).s_get([$synths_map($server_name)($mix_group)($track_name)($module)[0], $param])
		$Servers($server_name).sync($sync_track)
		$get_when := {
			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_track))
			{
				print $node_set
				abort $get_when
			}
		}		
	}

	@fun_def get($module, $param) // call param from server a faire directement dans antescofo $struct
	{	
		@local $nodeid
		$nodeid := $synths_map($server_name)($mix_group)($track_name)($module)[0]
		return $sc_struct($server_name)($nodeid)($param)	
	}

	@fun_def record($name, $headerFormat = "aiff", $sampleFormat = "int24", $num_frames = 65536, $fade_in = 0.1, $start_frame = 0, $leave_file_open = 1)
	{	
		@local $buff_id, $rec_node

		$buff_id := $SC_Servers($server_name)("buffer_id")
		$rec_node := $SC_Servers($server_name)("node_id") // last id
		$rec_map.add_pair($name, [$buff_id, $rec_node]) // store buf_id and node_id
		print rec_node_start $rec_node
		
		$Servers($server_name).b_alloc($buff_id, $num_frames, $hoa_num_ch) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, 0, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open


		$Servers($server_name).s_new(["Diskout_hoa_"+$order, $rec_node, 3, $node_id_out, "in", $hoa_bus, "bufnum", $buff_id, "in_ramp", $fade_in])
		

		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
		$SC_Servers($server_name).add_pair("node_id", $rec_node + 1)

	}

	@proc_def stop_record($name, $fade_out = 0.1)
	{
		@local $buff_id, $rec_node			
		// print rec_node_stop

		$buff_id := $rec_map($name)[0]
		$rec_node := $rec_map($name)[1]
		print rec_node_stop $rec_node

		$Servers($server_name).n_set($rec_node, ["out_ramp", @dur2sec($fade_out), "free", 0]) // stop recording

		$fade_out $Servers($server_name).b_free($buff_id) // close the file.

	}	


	@proc_def add_descriptors($name, $descriptors, $host = "localhost", $port = 9999) //8765
	{
		@local $descp_node_id

		oscsend osc_send_descriptors @global $host : $port //("/"+$name)
		
		$descp_node_id := $SC_Servers($server_name)("node_id") // last id

		if($decriptors_map.is_defined($name))
		{
			print is defined 

			forall $desc in $descriptors
			{
				@local $local_id, $params := [], $desc_id

				if($desc.size()>1)
				{
					$params := $desc.cdr()
				}

				if($decriptors_map($name).is_defined($desc[0])) // if exist look for parameters
				{
					$local_id := $decriptors_map($name)($desc[0])

					print is defined $local_id

					$Servers($server_name).n_set($local_id, $params) // change descriptors parameters
				}
				else // if doesn't exist create new descriptor
				{
					$desc_id := $descp_node_id
					whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
					{			
						// print receive_descript (""+$descriptors_receives)
						//   osc_send_descriptors (["/"+$name+$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor values
						osc_send_descriptors ("/" + $name + $descriptors_receives[1][0]) ($descriptors_receives[1][3]) // prefix includes the data = /$name, data = /descriptor values
					}
					
					if($desc.size()>1)
					{
						$params := $desc.cdr()
					}
					$Servers($server_name).s_new([$desc[0]+"_Replay", $descp_node_id, 3, $node_id_out, "in", $bus, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
					$decriptors_map($name).add_pair($desc[0], $descp_node_id)
					$descp_node_id += 1
					$SC_Servers($server_name).add_pair("node_id", $descp_node_id)
				}
			}
		}
		else
		{
			print not defined
			$decriptors_map.add_pair($name, map{}) // dico for descriptors

			
			// oscsend recbufaux "localhost" :7002 "/recbufaux"
			forall $desc in $descriptors
			{
				@local $desc_id, $params := []
				$desc_id := $descp_node_id
				print descriptors_start $descp_node_id
				print (""+$desc)

				whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
				{			
					// print receive_descript (""+$descriptors_receives)
					// osc_send_descriptors ([$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor value
					// osc_send_descriptors (("/" + $name + $descriptors_receives[1][0]) + " " + $descriptors_receives[1][3]) "" // prefix includes the data = /$name, data = /descriptor values
					osc_send_descriptors ("/" + $name + $descriptors_receives[1][0]) ($descriptors_receives[1][3]) // prefix includes the data = /$name, data = /descriptor values


				}
				
				if($desc.size()>1)
				{
					$params := $desc.cdr()
				}
				$Servers($server_name).s_new([$desc[0]+"_Replay", $descp_node_id, 3, $node_id_out, "in", $bus, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
				$decriptors_map($name).add_pair($desc[0], $descp_node_id)
				$descp_node_id += 1
				$SC_Servers($server_name).add_pair("node_id", $descp_node_id)
			}
		}	

	}


	@fun_def remove_descriptors($name, $descriptors = [])
	{
		// @local $descp_node_id
		print (""+$decriptors_map($name))
		if($descriptors.size()>0) // remove only $descriptors
		{
			forall $desc in $descriptors
			{
				$Servers($server_name).n_set($decriptors_map($name)($desc), ["free", 0]) // free node
				$decriptors_map($name).remove($desc)
			}

		}
		else // remove all descriptors
		{
			forall $k,$desc_id in $decriptors_map($name)
			{
				print descriptors_stop $desc_id
				$Servers($server_name).n_set($desc_id, ["free", 0]) // free node
			}

			$decriptors_map.remove($name)
		}
	}


	@fun_def set_multi($module, $params)
	{
		forall $x in $params
		{
			print (""+$params)
		}
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)).size
		// {
		// 	scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module))[$x]
		// }
	}
	
	@fun_def set_single ($module, $num, $params)
	{
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $params
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($track_name)($module)[$num], $params)

	}

	// @fun_def preset($module, $preset)
	// {
	// 	@local $json_file, $params, $i := 0, $node_id
	// 	$node_id := ($synths_map($server_name)($mix_group)($track_name)($module))
	// 	 // @set_osc_handling_tab(true) ///SuperCollider a diferencia de antescofo/sclang

	// 	// print prestsss
	// 	// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
	// 	$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

	// 					// $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"
	// 	// print ($json_file.post())

	// 	$params := $json_file($module)($preset).map2tab() // recupere les donnees du present json
	// 	// print params (""+$params)
	// 	forall $id in $node_id // pour toute les instances du Module
	// 	{
	// 		loop
	// 		{
	// 			// print (""+[$params[$i], $params[$i+1]])
	// 			// print toto
	// 			if(($params[$i+1].is_tab()))
	// 			{
	// 				// scServer "n_setn" $id ($params[$i]) @size($params[$i+1]) ($params[$i+1]) // if tab
	// 				$Servers($server_name).n_setn($id, [$params[$i], @size($params[$i+1]), $params[$i+1]]) // if tab
	// 			}else{
	// 				// scServer "n_set" $id ($params[$i]) ($params[$i+1])
	// 				$Servers($server_name).n_set($id, [$params[$i], $params[$i+1]].flatten())
	// 			}

	// 			// print ($synths_map($server_name)($mix_group)($track_name)($module)) ($params[$i]) ($params[$i+1])
	// 			$i := $i + 2
	// 		} while ($i < @size($params))
	// 	}


	// 	// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // pour toute les instances du Module
	// 	// {
	// 	// 	// scServer "n_set" $x $params
	// 	// 	print toto $x (""+$params)
	// 	// 	s_server $x $params
	// 	// }
	// 	// @set_osc_handling_tab(false) ///SuperCollider a diferencia de antescofo/sclang

	// }

	@fun_def preset($module, $preset)
	{
		@local $json_file, $node_id, $params_preset, $module_vst

		if($vst_all_map.is_defined($module)) // VST existe?
		{
			if($vst_all_map($module)("sdkversion")[4] == "3") // pour VST3
		    {
				$module_vst := $module+".vst3"
		    }
		    else
		    {
		    	$module_vst := $module
		    }
		    	$node_id :=	($vst_plugins($server_name)($mix_group)($track_name)($module_vst)) // dictionaire pour les id des vst_plugins

				$Servers($server_name).u_cmd([$node_id, 6, "/program_read", $vst_presets+$vst_all_map($module)("vendor")+"/"+$module+"/"+$preset+".fxp", 1]) // 6 = UGen id inside Synthdef
				print preset node $node_id (""+$vst_presets+$vst_all_map($module)("vendor")+"/"+$module+"/"+$preset+".fxp")
		}
		else
		{
			$node_id := ($synths_map($server_name)($mix_group)($track_name)($module))
			$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

			if($json_file.is_undef())
			{
				print "this preset does not exist"
			}
			else
			{
				$params_preset := $json_file($module)($preset).map2tab()

				forall $id in $node_id // pour toute les instances du Module
				{
					$Servers($server_name).n_set($id, $params_preset)
				}

			}
		}	


	}

	@fun_def save_preset($module, $preset) // save VST preset
	{
		@local $json_file, $node_id, $params_preset, $module_vst

		if($vst_all_map.is_defined($module)) // VST existe?
		{
			if($vst_all_map($module)("sdkversion")[4] == "3") // pour VST3
		    {
				$module_vst := $module+".vst3"
		    }
		    else
		    {
		    	$module_vst := $module
		    }
		    	$node_id :=	($vst_plugins($server_name)($mix_group)($track_name)($module_vst)) // dictionaire pour les id des vst_plugins

				$Servers($server_name).u_cmd([$node_id, 6, "/program_write", $vst_presets+$vst_all_map($module)("vendor")+"/"+$module+"/"+$preset+".fxp", 1]) // 6 = UGen id inside Synthdef
				print save_preset node $node_id (""+$vst_presets+$vst_all_map($module)("vendor")+"/"+$module+"/"+$preset+".fxp")
		}
		/*else // not yet implemented ...
		{
			$node_id := ($synths_map($server_name)($mix_group)($track_name)($module))
			$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

			if($json_file.is_undef())
			{
				print "this preset does not exist"
			}
			else
			{
				$params_preset := $json_file($module)($preset).map2tab()

				forall $id in $node_id // pour toute les instances du Module
				{
					$Servers($server_name).n_set($id, $params_preset)
				}

			}
		}	*/
	}

	@fun_def preset_single($module, $num, $preset)
	{
		@local $json_file, $params
		print prestsss
		// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")


		$params := $json_file($module)($preset).map2tab() // recupere les donnees du present json
		print (""+$params)
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $params
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($track_name)($module)[$num], $params)


	}

	@proc_def preset_interpol($module, $preset1, $preset2, $dur)
	{
		@local $json_file, $params, $params1, $params2, $nim, $val //, $id
		// print prestsss
		// $nim := @build_nim_from_bpf($bpf)
		// $id := ($synths_map($server_name)($mix_group)($track_name)($module))

		
		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")


		// $params1 := $json_file($module)($preset1).map2tab // recupere les donnees du present json
		// $params2 := $json_file($module)($preset2).map2tab // recupere les donnees du present json

		$params := $json_file($module)($preset2).domain() // recupere les keys des presets

		$preset1 := $json_file($module)($preset1).range() // recupere les donnees du present json
		$preset2 := $json_file($module)($preset2).range() // recupere les donnees du present json

		
	   Curve 	@Grain := 0.01,
			@Action {
					forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
					{
						// scServer "n_set" $node ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2))
						print $node (""+([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2)))
					}
				} 
	   { $val 	{            
					{0} 
			 $dur  	{1}
			} 
	   }

	   // Curve   @Grain := 0.01,  
	   //         @Action {

	   //             scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2))
	   //         }            
	   //         { $val : $nim }

	}

	@proc_def preset_interpol_tab($module, $presets_durs_tab)
	{
		@local $dur, $json_file, $params, $preset1, $preset2, $nim, $inc := 0, $curve := 0, $type := "linear" //, $id
		// print prestsss
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

		$params := $json_file($module)($presets_durs_tab[0]).domain() // recupere les keys des presets

		// $preset1 := $presets_durs_tab[$inc]
		// $preset2 := $presets_durs_tab[$inc+2]
		$dur := $presets_durs_tab[$inc+1]

		$preset2 := $json_file($module)($presets_durs_tab[$inc]).range() // recupere les donnees du present json
		// $preset2 := $json_file($module)($preset2).range // recupere les donnees du present json

		// print preset1_1 $preset2
		// // print preset2_1 $preset2
		// print params_1 $params
		// print inc_1 $inc
		print dur_1 $dur

		$inc := $inc + 1 // start from dur

		Loop $dur
		{	
			@local $val
			print durloop $dur
			$preset1 := $preset2 
			// if($inc <= @size($presets_durs_tab)-2)
			// {
				if ($presets_durs_tab[$inc+2].is_string())
			    {
				   $type := $presets_durs_tab[$inc+1]
				   // $preset2 := 
				   $preset2 := $json_file($module)($presets_durs_tab[$inc+2]).range() // recupere les donnees du present json
				   $dur := $presets_durs_tab[$inc]

				   $inc := $inc + 3;
			    }
			    else
			    {
				   $type := "linear"
				   // $preset2 := 
				   $preset2 := $json_file($module)($presets_durs_tab[$inc+1]).range() // recupere les donnees du present json
				   $dur := $presets_durs_tab[$inc]
				   $inc := $inc + 2;
			    }
			// }
		  //   	print preset1 $preset1
				// print preset2 $preset2
				// print params $params
				// print inc $inc


			abort $curve
		   $curve := {

		   Curve 	@Grain := 0.01,
					@Action {
						
							forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
							{
								// scServer "n_set" $node ([$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size()*2))
								$Servers($server_name).n_set($node , [$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size()*2))

								// print $node ([$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size*2))
							}
						} 
					{ $val 	{            
							{0} @type $type
					 $dur  	{1}
					} 
			  }
		   }
	

	}while ($inc < @size($presets_durs_tab)) //($inc < (@size($presets_durs_tab)-2))
	}

	// preset_interpol_tab("TestSynth3", ["preset1", 3, "", "preset2", 2, "preset3", 3.4, "preset4"])

	@proc_def preset_interpol_bpf($module, $preset1, $preset2, $bpf)
	{
		@local $json_file, $params, $params1, $params2, $nim, $val, $id
		// print prestsss
		$nim := @build_nim_from_bpf($bpf)
		$id := ($synths_map($server_name)($mix_group)($track_name)($module))

		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

		
		$params1 := $json_file($module)($preset1).map2tab() // recupere les donnees du present json
		$params2 := $json_file($module)($preset2).map2tab() // recupere les donnees du present json

		$params := $json_file($module)($preset2).domain() // recupere les keys des presets

		$preset1 := $json_file($module)($preset1).range() // recupere les duonnees du present json
		$preset2 := $json_file($module)($preset2).range() // recupere les donnees du present json

		// $params := $json_file($module)($preset).map2tab // recupere les donnees du present json
		// print $params1
		// print $params2
		// print $params
		// print $preset1
		// print $preset2

		print ([$params, $preset2].lace($params.size()*2))
		

	   Curve   @Grain := 0.01,  
			 @Action 
			 {
				// scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))  
				$Servers($server_name).n_set($id, [$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))             
			 }          

			 { $val : $nim }

	}

	@proc_def preset_interpol_vector($module, $preset_list) // interpol par boule
	{
		@local $json_file, $params, $params_name, $params1, $params2, $nim, $val, $id, $result, $temp
		// print prestsss
		$params := []
		// $nim := @build_nim_from_bpf($bpf)
		$id := ($synths_map($server_name)($mix_group)($track_name)($module))


		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$params_name := $json_file($module)($preset_list[0]).domain() // recupere les keys des presets


		forall $prst in $preset_list
		{
			// $temp := $json_file($module)($prst).map2tab
			// $temp := 
			$params.push_back($json_file($module)($prst).range())
		}

		whenever ($from_nodes == $from_nodes) // from_nodes viene de Max gmm static posture recognition 
		{
			if (@size($from_nodes) != @size($params))
			{
				print ERROR SIZE
				print $from_nodes
			}
			else
			{
				$result := $from_nodes * $params
				// interpol @reduce(@+, $result)
				// print from_nodes $from_nodes
				// print params (""+$params)
				print params_name (""+$params_name)	
				// print json_file (""+$json_file)
				print result (""+@reduce(@+, $result))
				print (""+([$params_name, @reduce(@+, $result)].lace($params_name.size()*2)))

				// scServer "n_set" $id ([$params_name, @reduce(@+, $result)].lace($params.size()*2))
				$Servers($server_name).n_set($id, [$params_name, @reduce(@+, $result)].lace($params.size()*2))
			}
		}

		// $params1 := $json_file($module)($prst).map2tab // recupere les donnees du present json
		// $params2 := $json_file($module)($preset2).map2tab // recupere les donnees du present json

		// $params := $json_file($module)($preset2).domain // recupere les keys des presets

		// $preset1 := $json_file($module)($preset1).range // recupere les duonnees du present json
		// $preset2 := $json_file($module)($preset2).range // recupere les donnees du present json

		// print ([$params, $preset2].lace($params.size*2))
		

	   // Curve   @Grain := 0.01,  
	   //         @Action 
	   //         {
	   //             scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2))                    
	   //         }          

	   //         { $val : $nim }

	}


	// @fun_def amp($group_amp)
	// {
	// 		// {msg[2] == \amp} {~synth[msg[1]].outsynth.set(\amp, msg[3])}
	// 	// scServer "n_set" $node_id_out amp $group_amp
	// 	$Servers($server_name).n_set($node_id_out, ["amp", $group_amp])
	// }

	// @proc_def amp($amp)
	// {
	// 	@local $nim, $lamp
	// 	abort $last_bpf_amp_curve // to avoid interferences

	// 	if($amp.is_tab()) // if $val is bpf
	// 	{
	// 		$nim := @build_nim_from_bpf($amp)
	// 		// .CheckParam($module, $param, $MYSELF)
	// 		$lamp := $amp[0]
	// 		$last_bpf_amp_curve := { curve @grain := 0.01, 
	// 			@action 
	// 			{
	// 				$Servers($server_name).n_set($node_id_out, ["amp", $lamp])	
	// 			} 
	// 			{ $lamp : $nim }
	// 		}
	// 	}
	// 	else
	// 	{
	// 		$Servers($server_name).n_set($node_id_out, ["amp", $amp])
	// 	}
	// }

///// track

	// @proc_def track_amp_bpf($bpf)  // [-6, 7.5, "circ", 3, 4.5, -118]
 //    {
	// 	@local $nim, $lamp
	// 	// abort $last_bpf_amp_curve //evita interferencias
	// 	$nim := @build_nim_from_bpf($bpf)
	// 	// print $nim
	// 	$lamp := $bpf[0]
	// 	$last_bpf_amp_curve := { curve @grain := 0.01, @action {
	// 		// scServer "n_set" $node_id_out amp $lamp
	// 		$Servers($server_name).n_set($node_id_out, ["amp", $lamp])
	// 	} 
	// 		{ $lamp : $nim }
	//     }
	// }

    @proc_def track_line_amp($lmin1, $lmax1, $dur1, $type) 
    {
	   @local $lamp
	// .CheckParam($module, $param, $MYSELF)
	   Curve
	   @grain := 0.01,
	   @action {
    //     		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module))
				// {
				// 	scServer "n_set" $x $params
				// }
			// scServer "n_set" $node_id_out amp $lamp
			$Servers($server_name).n_set($node_id_out, ["amp", $lamp])

	   // print scServer "n_set" $node_id_out amp $lamp
	} 
	   { $lamp {            
				    {$lmin1} @type := $type
			 $dur1   {$lmax1}} 
	   }
    }


	@proc_def amp($ampli, $add = 0, $free = false, $action = false)
	{
		@local $nim, $lamp, $last_bpf_amp_curve

		if($track_proc($server_name)($mix_group)($track_name).is_defined("amp"))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("amp") // stop process to avoid interferences
		}		
		// abort $last_bpf_amp_curve // to avoid interferences

		if($ampli.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($ampli)
			// .CheckParam($module, $param, $MYSELF)
			$amp_bpf_x_min := @min_key($nim)
			$amp_bpf_x_max := @max_key($nim)
			$lamp := $ampli[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out2, ["amp", $lamp+$add])
					// $Servers($server_name).n_set($node_id_out, ["amp", $lamp+$add])	
					// print amp $node_id_out2 $lamp
					$amp := $lamp+$add // global amp
				} 
				{ $lamp : $nim }
				==> { 	if($free.is_numeric()) // if free number then free track in number time
						{
							$THISOBJ.free($free)
						}
						if($action) // action after amp for exemple clear buffers
							{
								// print "fin curve action" (""+$action)
								($free+0.1) $track_amp_action := $action
							}
						}
					}
		$track_proc($server_name)($mix_group)($track_name).add_pair("amp", $last_bpf_amp_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out2, ["amp", $ampli+$add])
			// $Servers($server_name).n_set($node_id_out, ["amp", $amp+$add])
			$amp := $ampli // global amp 
		}
	}
	@proc_def amp_add($ampli)
	{
		@local $nim, $lamp, $last_bpf_amp_curve

		if($track_proc($server_name)($mix_group)($track_name).is_defined("amp_add"))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("amp_add") // stop process to avoid interferences
		}		
		// abort $last_bpf_amp_curve // to avoid interferences

		if($ampli.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($ampli)
			// .CheckParam($module, $param, $MYSELF)
			$amp_bpf_x_min := @min_key($nim)
			$amp_bpf_x_max := @max_key($nim)
			$lamp := $ampli[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out2, ["amp", $lamp+$amp])
					// $Servers($server_name).n_set($node_id_out, ["amp", $lamp+$add])	
					// print amp $node_id_out2 $lamp
					// $amp := $lamp+$add // global amp
				} 
				{ $lamp : $nim }				
			}
		$track_proc($server_name)($mix_group)($track_name).add_pair("amp_add", $last_bpf_amp_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out2, ["amp", $ampli+$amp])
			// $Servers($server_name).n_set($node_id_out, ["amp", $amp+$add])
			// $amp := $ampli // global amp 
		}
	}	
	@fun_def get_amp()
	{
		return $amp
	}
	@proc_def amp2($ampli, $add = 0) //control encoder amp
	{
		@local $nim, $lamp, $last_bpf_amp_curve

		if($track_proc($server_name)($mix_group)($track_name).is_defined("amp"))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("amp") // stop process to avoid interferences
		}		
		// abort $last_bpf_amp_curve // to avoid interferences

		if($ampli.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($ampli)
			// .CheckParam($module, $param, $MYSELF)
			$amp_bpf_x_min := @min_key($nim)
			$amp_bpf_x_max := @max_key($nim)
			$lamp := $ampli[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					// $Servers($server_name).n_set($node_id_out2, ["amp", $lamp+$add])
					$Servers($server_name).n_set($node_id_out, ["amp", $lamp+$add])	
					// print amp $node_id_out2 $lamp
				} 
				{ $lamp : $nim }
			}
		$track_proc($server_name)($mix_group)($track_name).add_pair("amp", $last_bpf_amp_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			// $Servers($server_name).n_set($node_id_out2, ["amp", $ampli+$add])
			$Servers($server_name).n_set($node_id_out, ["amp", $ampli+$add])
		}
	}


	@fun_def set_track($params) // set track parameters for all modules in track
	{
			$Servers($server_name).n_set($group_id, $params)
	}	

	@fun_def set_out($params) // set track parameters for HOA_Encode for exemple
	{
			$Servers($server_name).n_set($node_id_out, $params)
	}

	// @fun_def HOABeamDirac2Hoa() // add BeamDirac2Hoa HOA FILTER
	// {
	// 	@local $node_id_mod

	// 	$node_id_mod := $SC_Servers($server_name)("node_id") // last id

	// 	scServer "s_new" ("HOA_Filter_HOABeamDirac2Hoa"+$order) $node_id_mod 3 $node_id_out in $bus out $bus

	// 	$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1) // increment node_i
	// }

	@fun_def dae($dae_tab)
	{
		@local $dae_res

		$dae_res := [$dae_tab[0]*$d_factor, $dae_tab[1], $dae_tab[2]]
		$Servers($server_name).n_set($node_id_out, ["coords", $dae_res])
		// $dae_list_cart := @poltocar3D_tab($dae_res)
		$trajs.insert($proc_index, @poltocar3D_tab($dae_res)) // to OpenFrameworks
	}

	@fun_def d_factor($d_fac) // distance factor
	{
		$d_factor := $d_fac
	}

	@proc_def d_factor_interp($start_dist, $end_dist, $dur, $type = "linear") // distance factor
	{
		@local $r_val, $last_curve

		$last_curve := { curve @grain := 0.01, 
			@action 
			{	// change $radio_fac du processus
				$THISOBJ.d_factor($r_val)
			} 
		    { $r_val {            
			  		   {$start_dist} @type $type
			  	$dur   {$end_dist}} 
		    }
		}
	}
	@proc_def dae_rand_lfo($range, $tpo = 60, $type = "linear") // [min0,max0,init_val0, min1,max1,init_val1, min_n,max_n,init_val_n], tempo, type_interpol
	{
	  	@local $dae_list_cart := [] //, $proc_index //, $dae_list
	    if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_multi_lfo_track")) // si ça existe abort et refait
		{
			$THISOBJ.dae_rand_lfo_abort()
		}
		$dae_list := [0 | ($range.size()/3)]
		$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_multi_lfo_track", [ ::rand_lfo_multi($dae_list, $i/3, $range[$i], $range[$i+1], $range[$i+2], $type, $tpo)  | $i in $range.size() : 3 ]) // instantie un le processus dans le dico
		// $proc_index := $trajs_index
		// $trajs.add_pair($proc_index, $dae_list_cart)
		// $trajs_index += 1

		$int_loop := {
			loop  10ms  
			@abort { print "===> loop killed" $track_name }
			{ 
				// print dae_list (""+$dae_list)
				// $Servers($server_name).n_set($node_id_out, ["coords", $dae_list]) 
				$THISOBJ.dae($dae_list)
				// $dae_list_cart := @poltocar3D_tab($dae_list)
				// $trajs.insert($proc_index, $dae_list_cart)
				// print dae_list_cart $dae_list_cart
			}
		}
	}

	@fun_def dae_rand_lfo_abort()
	{
		abort $int_loop
		forall $lfo in $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_multi_lfo_track") 
		{
			// abort dae_rand_lfo // abort loop 
			// print aborte $lfo
			abort $lfo
		}
	}

	@proc_def rand_lfo_amp_param_dfactor($mod_params_min_max1, $mod_params_min_max2, $amp_min_max_tab, $d_factor_min_max, $tpo= 60, $type = "linear") 
	{
		@local $rand_lfo_glob_val := [0], $res_val

		if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"rand_lfo_glob")) // si ça existe abort et refait
		{
			// abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"rand_lfo_glob")
			// abort $int_loop
			$THISOBJ.rand_lfo_amp_param_dfactor_abort()
		}
		$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"rand_lfo_glob", ::rand_lfo_multi($rand_lfo_glob_val, 0, 0, 1, 0.5, $type, $tpo)) 
		$int_loop := {
			loop  10ms  
			// @abort { print "===> loop killed" $track_name }
			{ 	
				$res_val := $rand_lfo_glob_val[0]
				// $THISOBJ.dae($dae_list)
				// print (""+$res_val)
				$THISOBJ.set($mod_params_min_max1[0], [$mod_params_min_max1[1], @scale_compiled($res_val, 0, 1, $mod_params_min_max1[2], $mod_params_min_max1[3], 1)])
				$THISOBJ.set($mod_params_min_max2[0], [$mod_params_min_max2[1], @scale_compiled($res_val, 0, 1, $mod_params_min_max2[2], $mod_params_min_max2[3], 1)])
				$THISOBJ.amp(@scale_compiled($res_val, 0, 1, $amp_min_max_tab[0], $amp_min_max_tab[1], 1))
				$THISOBJ.d_factor(@scale_compiled($res_val, 0, 1, $d_factor_min_max[0], $d_factor_min_max[1], 1))
			}
		}
	}

	@fun_def rand_lfo_amp_param_dfactor_abort()
	{
		abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"rand_lfo_glob")
		abort $int_loop
/*		forall $lfo in $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_multi_lfo_track") 
		{
			// abort dae_rand_lfo // abort loop 
			// print aborte $lfo
			abort $lfo
		}*/
	}

	@fun_def xyz($pos_xyz) // Ambitools
	{
		@local $dae_tab

		$xyz_list := ($pos_xyz+$HOA_global_track_xyz)*$HOA_xyz_factor // update object global variable

		$dae_tab := @cartopol3D_tab($xyz_list)
		// print $dae_tab
		$Servers($server_name).n_set($node_id_out, ["coords", $dae_tab])
		$trajs.insert($proc_index, $xyz_list) // send to ::gui_oF_trajs() process
	}	

	@proc_def xyz_rand_lfo($range, $tpo = 60, $type = "linear") // [min0,max0,init_val0, min1,max1,init_val1, min_n,max_n,init_val_n], tempo, type_interpol
	{
	  	@local $xyz_rand_list // , $proc_index //, $xyz_list
	    if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_multi_lfo_track")) // si ça existe abort et refait
		{
			$THISOBJ.dae_rand_lfo_abort()
		}
		$xyz_rand_list := [0 | ($range.size()/3)]
		$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_multi_lfo_track", [ ::rand_lfo_multi($xyz_rand_list, $i/3, $range[$i], $range[$i+1], $range[$i+2], $type, $tpo)  | $i in $range.size() : 3 ]) // instantie un le processus dans le dico


		$int_loop := {
			loop  10ms  
			// @abort { print "===> loop killed" $track_name }
			{ 
				// print xyz_rand_list (""+$xyz_rand_list)
				$THISOBJ.xyz($xyz_rand_list)
				// $dae_list_pol := @cartopol3D_tab(($xyz_list+$HOA_global_track_xyz)*$HOA_xyz_factor)
				// $Servers($server_name).n_set($node_id_out, ["coords", $dae_list_pol]) 
				// $dae_list_cart := @poltocar3D_tab($dae_list)
				// $trajs.insert($proc_index, ($xyz_list+$HOA_global_track_xyz)*$HOA_xyz_factor)
				// print dae_list_cart $dae_list_cart
			}
		}
	}	

	@proc_def xyz_rand($range, $loop = 1) // [min0,max0,init_val0, min1,max1,init_val1, min_n,max_n,init_val_n], tempo, type_interpol
	{
	  	@local $xyz_rand_list // , $proc_index //, $xyz_list
	 //    if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_multi_lfo_track")) // si ça existe abort et refait
		// {
		// 	$THISOBJ.dae_rand_lfo_abort()
		// }
		$xyz_rand_list := [0 | ($range.size()/3)]
		// $track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_multi_lfo_track", [ ::rand_lfo_multi($xyz_rand_list, $i/3, $range[$i], $range[$i+1], $range[$i+2], $type, $tpo)  | $i in $range.size() : 3 ]) // instantie un le processus dans le dico

		$xyz_rand_list := [@rand_range_compiled($range[0], $range[1]), @rand_range_compiled($range[2], $range[3]), @rand_range_compiled($range[4], $range[5])]

		abort $int_loop

		$int_loop := {
			loop  $loop 
			// @abort { print "===> loop killed" $track_name }
			{ 
				// print xyz_rand_list (""+$xyz_rand_list)
				$THISOBJ.xyz($xyz_rand_list)

				$xyz_rand_list := [@rand_range_compiled($range[0], $range[1]), @rand_range_compiled($range[2], $range[3]), @rand_range_compiled($range[4], $range[5])]

				// $dae_list_pol := @cartopol3D_tab(($xyz_list+$HOA_global_track_xyz)*$HOA_xyz_factor)
				// $Servers($server_name).n_set($node_id_out, ["coords", $dae_list_pol]) 
				// $dae_list_cart := @poltocar3D_tab($dae_list)
				// $trajs.insert($proc_index, ($xyz_list+$HOA_global_track_xyz)*$HOA_xyz_factor)
				// print dae_list_cart $dae_list_cart
			}
		}
	}		

	@fun_def xyz_rand_lfo_abort()
	{
		abort $int_loop
		forall $lfo in $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_multi_lfo_track") 
		{
			// abort dae_rand_lfo // abort loop 
			// print aborte $lfo
			abort $lfo
		}
	}
	@fun_def dae_list()
	{
		return $dae_list
	}
	@fun_def xyz_list()
	{
		return $xyz_list
	}	
	@fun_def HOA_global_track_xyz($xyz_offset)
	{
		$HOA_global_track_xyz := $xyz_offset
		$THISOBJ.xyz($xyz_list) // update with global $xyz_list
	}
	@fun_def HOA_xyz_factor($xyz_factor)
	{
		$HOA_xyz_factor := $xyz_factor
	}	

	@fun_def traj_automation($name, $dur = false) // Ambitools
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::play_automation($server_name, $node_id_out, $name, $dur)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

	// traj_circ($server_name, $node_id_out, $dir, $duree, $start_radio, $end_radio, $start_angle, $end_angle, $start_elev, $end_elev, $period, $type, $loop)
	@fun_def traj_circ($dir, $duree, $start_radio, $end_radio, $start_angle, $end_angle, $start_elev, $end_elev, $period, $type, $loop = 1) // Ambitools
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_circ($server_name, $node_id_out, $dir, $duree, $start_radio, $end_radio, $start_angle, $end_angle, $start_elev, $end_elev, $period, $type, $loop)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

	// @proc_def traj_circ2($server_name, $track_id, $start_coords, $clockwise, $tpo) // , $clockwise = 1
	@proc_def traj_circ2($start_coords, $clockwise, $tpo = 60) // Ambitools
	{ 
		@local $coords_val
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D")
			abort $int_loop 
		}
		$coords_val := $start_coords
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			// $track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_circ2($server_name, $node_id_out, $start_coords, $clockwise, $tpo)) // instantie un le processus dans le dico
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_circ22($coords_val, $start_coords, $clockwise, $tpo)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
		
		$int_loop := {
			loop  10ms  
			// @abort { print "===> loop killed" $track_name }
			{ 
				$THISOBJ.dae($coords_val)
				// print coords_val (""+$coords_val)

			}
		}
	}

//// deprecate use d_factor / d_factor_interp!!
	@proc_def traj_radio_fac_interp($start_radio, $end_radio, $dur, $type = "linear") // Ambitools
	{ 
		@local $r_val, $traj_process
/*			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}*/	
		$traj_process := $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D")
		// print traj_process (""+$traj_process)
		Curve
		@grain := 0.01,
		@action 
		{	// change $radio_fac du processus
			$traj_process.$radio_fac := $r_val
		} 
	    { $r_val {            
		  		   {$start_radio} @type $type
		  	$dur   {$end_radio}} 
	    }

	}
	// @proc_def traj_circ_interp($server_name, $track_id, $start_coords, $end_coords, $duree, $type)
	@fun_def traj_circ_interp($start_coords, $end_coords, $duree, $type = "linear")
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_circ_interp($server_name, $node_id_out, $start_coords, $end_coords, $duree, $type)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

	// @proc_def traj_circ_interp2($server_name, $track_id, $start_coords, $end_coords, $duree, $clockwise, $type) // , $clockwise = 1
	@fun_def traj_circ_interp2($start_coords, $end_coords, $duree, $clockwise = 1, $type = "linear")
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_circ_interp2($server_name, $node_id_out, $start_coords, $end_coords, $duree, $clockwise, $type)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

	@fun_def traj_linear_interp($start_coords, $end_coords, $duree, $type = "linear") // coords in polar
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_linear_interp($server_name, $node_id_out, $start_coords, $end_coords, $duree, $type)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

// @proc_def traj_linear_ele_interp($server_name, $track_id, $start_coords, $end_coords, $duree = 1, $max_ele = 1, $type = "linear")

	@fun_def traj_linear_ele_interp($start_coords, $end_coords, $duree, $max_ele = 1, $type = "linear") // coords in polar
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_linear_ele_interp($server_name, $node_id_out, $start_coords, $end_coords, $duree, $max_ele, $type)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}


	@fun_def traj_rand_circ($radio_min, $radio_max, $radio_init, $az_min, $az_max, $az_init, $elev_min, $elev_max, $elev_init, $tpo = 60, $type = "linear") // coords in polar
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::traj_rand_circ($server_name, $node_id_out, $radio_min, $radio_max, $radio_init, $az_min, $az_max, $az_init, $elev_min, $elev_max, $elev_init, $tpo, $type)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}	
	@fun_def ambi_xyz($pos_xyz) // SC-HOA
	{
		// scServer "n_set" $node_id_out x ($pos_xyz[0]) y ($pos_xyz[1]) z ($pos_xyz[2])
		$Servers($server_name).n_set($node_id_out, ["x", ($pos_xyz[0]), "y", ($pos_xyz[1]), "z", ($pos_xyz[2])])
	}

	@fun_def ambi_ste_xyz($pos_xyz)
	{
		// scServer "n_set" $node_id_out x ($pos_xyz[0]) y ($pos_xyz[1]) z ($pos_xyz[2])
		$Servers($server_name).n_set($node_id_out, ["x", ($pos_xyz[0]), "y", ($pos_xyz[1]), "z", ($pos_xyz[2]), "x1", ($pos_xyz[3]), "y1", ($pos_xyz[4]), "z1", ($pos_xyz[5])])
	}

	@proc_def ambi_x($pos_x, $x_index = "")
	{
		@local $nim, $lpos_x, $last_bpf_pos_x_curve, $pos_x_bpf_x_min, $pos_x_bpf_x_max

		if($track_proc($server_name)($mix_group)($track_name).is_defined("pos_x"+$x_index))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("pos_x"+$x_index) // to avoid interferences
		}		
		// abort $last_bpf_pos_x_curve // to avoid interferences

		if($pos_x.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($pos_x)
			// .CheckParam($module, $param, $MYSELF)
			$pos_x_bpf_x_min := @min_key($nim)
			$pos_x_bpf_x_max := @max_key($nim)
			$lpos_x := $pos_x[0]
			$last_bpf_pos_x_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["x"+$x_index, $lpos_x])	
					// print amp $node_id_out $lpos_x
				} 
				{ $lpos_x : $nim }
			}
		$track_proc($server_name)($mix_group)($track_name).add_pair("pos_x"+$x_index, $last_bpf_pos_x_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["x"+$x_index, $pos_x])
		}
	}

	@proc_def ambi_y($pos_y, $y_index = "")
	{
		@local $nim, $lpos_y, $last_bpf_pos_y_curve, $pos_y_bpf_x_min, $pos_y_bpf_x_max

		if($track_proc($server_name)($mix_group)($track_name).is_defined("pos_y"+$y_index))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("pos_y"+$y_index) // to avoid interferences
		}		
		// abort $last_bpf_pos_y_curve // to avoid interferences

		if($pos_y.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($pos_y)
			// .CheckParam($module, $param, $MYSELF)
			$pos_y_bpf_x_min := @min_key($nim)
			$pos_y_bpf_x_max := @max_key($nim)
			$lpos_y := $pos_y[0]
			$last_bpf_pos_y_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["y"+$y_index, $lpos_y])	
					// print amp $node_id_out $lpos_y
				} 
				{ $lpos_y : $nim }
			}
		$track_proc($server_name)($mix_group)($track_name).add_pair("pos_y"+$y_index, $last_bpf_pos_y_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["y"+$y_index, $pos_y])
		}
	}

	@proc_def ambi_z($pos_z, $z_index = "")
	{
		@local $nim, $lpos_z, $last_bpf_pos_z_curve, $pos_z_bpf_x_min, $pos_z_bpf_x_max

		if($track_proc($server_name)($mix_group)($track_name).is_defined("pos_z"+$z_index))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("pos_z"+$z_index) // to avoid interferences
		}		
		// abort $last_bpf_pos_z_curve // to avoid interferences

		if($pos_z.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($pos_z)
			// .CheckParam($module, $param, $MYSELF)
			$pos_z_bpf_x_min := @min_key($nim)
			$pos_z_bpf_x_max := @max_key($nim)
			$lpos_z := $pos_z[0]
			$last_bpf_pos_z_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["z"+$z_index, $lpos_z])	
					// print amp $node_id_out $lpos_z
				} 
				{ $lpos_z : $nim }
			}
		$track_proc($server_name)($mix_group)($track_name).add_pair("pos_z"+$z_index, $last_bpf_pos_z_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["z"+$z_index, $pos_z])
		}
	}	

	@fun_def pitch($pitch)
	{
		// scServer "n_set" $node_id_out pitch @ang2rad($pitch)
		$Servers($server_name).n_set($node_id_out,  ["pitch", @ang2rad($pitch)])
		// print ("n_set"+$server_name) $node_id_out x $pos_x
	}

	@fun_def roll($roll)
	{
		// scServer "n_set" $node_id_out roll @ang2rad($roll)
		$Servers($server_name).n_set($node_id_out, ["roll", @ang2rad($roll)])
		// print ("n_set"+$server_name) $node_id_out y $pos_y
	}
		
	@fun_def yaw($yaw)
	{
		// scServer "n_set" $node_id_out yaw @ang2rad($yaw)
		$Servers($server_name).n_set($node_id_out, ["yaw", @ang2rad($yaw)])


		// print ("n_set"+$server_name) $node_id_out z $pos_z
	}

	@fun_def doppler($dop)
	{
		// scServer "n_set" $node_id_out dopon $dop
		$Servers($server_name).n_set($node_id_out, ["dopon", $dop])
	}

	@fun_def doppler_lev($dop_lev)
	{
		// scServer "n_set" $node_id_out dopamnt $dop_lev
		$Servers($server_name).n_set($node_id_out, ["dopamnt", $dop_lev])
	}

	@fun_def traj_lib_ellipse($initT = 0, $endT=2, $a=2, $b=0.2, $alpha=0, $beta=0, $offsetX=0, $offsetY=0, $speed=0, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::ellipse($server_name, $node_id_out, $initT, $endT, $a, $b, $alpha, $beta, $offsetX, $offsetY, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}

	@fun_def traj_lib_sin($iniT=-1, $targeT=1, $amp=1, $w=1, $offset=0, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::sin_trajectory($server_name, $node_id_out, $iniT, $targeT, $amp, $w, $offset, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}	
									
	@fun_def traj_lib_lissajou($initT=-1, $endT=1, $a=1, $b=1, $m=1, $n=1, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::lissajou($server_name, $node_id_out, $initT, $endT, $a, $b, $m, $n, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}	

	@fun_def traj_lib_lissajou_bis($initT=0, $targeT=1, $k=1, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::lissajou_bis($server_name, $node_id_out, $initT, $targeT, $k, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}	

	@fun_def traj_lib_deltoide($initT=-1, $endT=1, $r=0.2, $offsetX=0.2, $offsetY=0, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::deltoide($server_name, $node_id_out, $initT, $endT, $r, $offsetX, $offsetY, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}	
	@fun_def traj_lib_rosace($initT=0, $targeT=2, $k=2, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::rosace_trajectory($server_name, $node_id_out, $initT, $targeT, $k, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}	

	@fun_def traj_lib_rosace_var($initC=0, $cycle=2, $p=1, $q=2, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::rosace_trajectory_variation($server_name, $node_id_out, $initC, $cycle, $p, $q, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}			

	@fun_def traj_lib_gauss($iniT=-3, $targeT=1, $k=-1, $offset=0, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::gauss($server_name, $node_id_out,$iniT, $targeT, $k, $offset, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}			
										
	@fun_def traj_lib_hypocycloide1($initT=0, $endT=2, $a=0.3, $b=0.3, $offsetX=0, $offsetY=0, $speed=4, $loop_num=1, $elev=0, $ambi=1)
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::hypocycloide1($server_name, $node_id_out, $initT, $endT, $a, $b, $offsetX, $offsetY, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}			
									
	@fun_def traj_lib_hypocycloide2($initT=0, $endT=2, $a=0.3, $b=0.3, $offsetX=0, $offsetY=0, $speed=4, $loop_num=1, $elev=0, $ambi=1)
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::hypocycloide2($server_name, $node_id_out, $initT, $endT, $a, $b, $offsetX, $offsetY, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}			
							
	@fun_def traj_lib_curvoide($initT=-1, $endT=1, $a=0.2, $b=0.2, $offsetX=0, $offsetY=0, $speed=4, $loop_num=1, $elev=0, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::curvoide($server_name, $node_id_out, $initT, $endT, $a, $b, $offsetX, $offsetY, $speed, $loop_num, $elev, $ambi=1))
	}			

	@fun_def traj_lib_hypo_var($initT=0, $endT=2, $R=1, $r=1/3, $offsetX=0, $offsetY=0, $speed=4, $loop_num=1, $elev=0, $ambi=1)
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::hypocycloideVariations($server_name, $node_id_out, $initT, $endT, $R, $r, $offsetX, $offsetY, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}			

	@fun_def traj_lib_epi($initT=0.01, $endT=2, $m=(2*$pi), $offsetX=0, $offsetY=0, $speed=4, $loop_num=1, $elev=0, $ambi=1)
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::epi($server_name, $node_id_out, $initT, $endT, $m, $offsetX, $offsetY, $speed, $loop_num, $elev, $ambi=1)) // instantie un le processus dans le dico
	}			
		

	@fun_def traj_lib_generic3D($initT=1, $targeT=3, $a=1,$b=1,$c=1, $offsetX=0, $offsetY=0, $offsetZ=1, $speed=1, $loop_num=1, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::generic3D($server_name, $node_id_out, $initT, $targeT, $a, $b, $c, $offsetX, $offsetY, $offsetZ, $speed, $loop_num, $ambi=1)) // instantie un le processus dans le dico
	}

	@fun_def traj_lib_helicoide3D($initT=1/2, $endT=4+1/2, $a=0.7, $b=0.2, $offsetX=0, $offsetY=0, $offsetZ=0, $speed=4, $loop_num=1, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::helicoide3D($server_name, $node_id_out, $initT, $endT, $a, $b, $offsetX, $offsetY, $offsetZ, $speed, $loop_num, $ambi=1)) // instantie un le processus dans le dico
	}

	@fun_def traj_lib_couronne3D($initT=-1, $endT=1, $a=1, $b=1, $n=1, $offsetX=0, $offsetY=0, $offsetZ=0, $speed=4, $loop_num=1, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::couronne3D($server_name, $node_id_out, $initT, $endT, $a, $b, $n, $offsetX, $offsetY, $offsetZ, $speed, $loop_num, $ambi=1)) // instantie un le processus dans le dico
	}

	@fun_def traj_lib_clelie3D($initT=-1, $endT=1, $R=1, $n=1, $offsetX=0, $offsetY=0, $offsetZ=0, $speed=4, $loop_num=1, $ambi=1) 
	{ 
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::clelie3D($server_name, $node_id_out, $initT, $endT, $R, $n, $offsetX, $offsetY, $offsetZ, $speed, $loop_num, $ambi=1)) // instantie un le processus dans le dico
	}

	@fun_def traj_lib_lissajou3D($initT=0, $endT=4, $a=1, $b=1, $c=1, $n=1/2, $m=1/2, $offsetX=0, $offsetY=0, $offsetZ=0, $speed=4, $loop_num=1, $ambi=1) 
	{ 
		// @local $num_params
		// 	switch($traj)
		// 	case lissajou3D:
		// 	$num_params := 12

			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_traj3D", ::lissajou3D($server_name, $node_id_out, $initT, $endT, $a, $b, $c, $n, $m, $offsetX, $offsetY, $offsetZ, $speed, $loop_num, $ambi=1)) // instantie un le processus dans le dico
			// print track_proc (""+$track_proc($server_name)($mix_group))
	}	
// ::ambi_orbit($track_id, $angle, $grain)

	// $proc_rand_theta := $sc_track_hoa1.ambi_rand_lfo_sphere($radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period) 
	
	@fun_def ambi_orbit($angle, $grain) 
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::ambi_orbit($server_name, $node_id_out, $angle, $grain)) // instantie un le processus dans le dico
			print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

	@fun_def orbit_traj($angle, $grain) 
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::orbit_traj($server_name, $node_id_out, $angle, $grain)) // instantie un le processus dans le dico
			print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

	@fun_def orbit_traj2($angle, $grain) 
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_traj3D")) // si ça existe abort et refait
		{
			// print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($track_name).add_pair(($node_id_out+"_traj3D"), ::orbit_traj2($server_name, $node_id_out, $angle, $grain)) // instantie un le processus dans le dico
			print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}
	@fun_def traj_abort() 
	{
		abort $int_loop
		abort $track_proc($server_name)($mix_group)($track_name)($node_id_out+"_traj3D")
	}		

	@fun_def ambi_rand_lfo_sphere($radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id = 0, $host = "192.168.1.12", $port = 9999, $descripteur = ["Loudness"], $scale = [0, 60, 0, 1, 1] ) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::ambi_rand_lfo_sphere($server_name, $track_name, $mix_group, $radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id, $host, $port, $descripteur, $scale)) // instantie un le processus dans le dico
	}

	@fun_def ambi_rand_lfo_sphere2($radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id = 0, $host = "192.168.1.12", $port = 9999) 
	{ 
	    if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	    {
		   // print abort_rand
		   abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	    }
	    $track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::ambi_rand_lfo_sphere2($server_name, $node_id_out, $mix_group, $radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id, $host, $port)) // instantie un le processus dans le dico
	}	

	@fun_def ambi_rand_lfo_sphere_ste($radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id = 0, $host = "192.168.1.12", $port = 9999) 
	{ 
	    if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	    {
		   // print abort_rand
		   abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	    }
	    $track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::ambi_rand_lfo_sphere_ste($server_name, $node_id_out, $mix_group, $radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id, $host, $port)) // instantie un le processus dans le dico
	}

	@fun_def ambi_rand_lfo_sphere_abort() 
	{
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D")
	}
	@fun_def source_traj_abort() 
	{
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D")
	}	

	@fun_def source_pol_traj($duree, $radio, $theta, $start_pos, $end_pos, $period, $type, $loop = 0, $dir = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_pol_traj($server_name, $node_id_out, $mix_group, $dir, $duree, $radio, $theta, $start_pos, $end_pos, $period, $type, $loop)) // instantie un le processus dans le dico
	}

	@fun_def pol_traj_bpf($pol_bpf) // from bach roll interface
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::pol_traj_bpf($server_name, $node_id_out, $mix_group, $pol_bpf)) // instantie un le processus dans le dico
	}

	@fun_def pol_traj_bpf2($pol_bpf, $id, $descripteur = ["Loudness"]) // from bach roll interface
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::pol_traj_bpf2($server_name, $track_name, $mix_group, $pol_bpf, $id, $descripteur)) // instantie un le processus dans le dico
	}


	@fun_def source_cart_traj($duree, $x, $y, $z, $type = "linear", $loop = 0) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_cart_traj($server_name, $node_id_out, $mix_group, $duree, $x, $y, $z, $type, $loop)) // instantie un le processus dans le dico
	}

	@fun_def source_cart_traj_bpf($x, $y, $z, $loop = 0) // x, y, z are bpf !
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_cart_traj_bpf($server_name, $node_id_out, $mix_group, $x, $y, $z, $loop)) // instantie un le processus dans le dico
	}


	@fun_def source_elevation_traj($duree, $radio, $phi, $start_pos, $end_pos, $period, $type, $loop = 0, $dir = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_elevation_traj($server_name, $node_id_out, $mix_group, $dir, $duree, $radio, $phi, $start_pos, $end_pos, $period, $type, $loop)) // instantie un le processus dans le dico
	}

	// avec descriptor
	@fun_def hoa_pol_rotation($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $dir = 1, $id = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::hoa_pol_rotation($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $id)) // instantie un le processus dans le dico
	}																		  

	// sans descriptor																		  
	@fun_def hoa_pol_rota($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $dir = 1, $id = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::hoa_pol_rota($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $id)) // instantie un le processus dans le dico
	}																		  

	@fun_def source_comete($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $loop = 0, $dir = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_comete($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id)) // instantie un le processus dans le dico
	}
	@fun_def source_comete_solo($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $loop = 0, $dir = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_comete_solo($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id)) // instantie un le processus dans le dico
	}	

	@fun_def source_comete_solo2($radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $loop = 0, $dir = 1) // calcule la duree a partir methode "amp" ($amp_bpf_x_max)
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_comete_solo2($server_name, $track_name, $mix_group, $dir, $amp_bpf_x_max, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id)) // instantie un le processus dans le dico
	}	
		// $tracks($nota_name).source_comete_solo2(0.1, @rand_range(0, 50), @rand_range(0, 360), @rand_range(0, 90), @rand_range(0, 360), 60, "linear", 1, 1, 1)	
	// @proc_def source_comete_solo3($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id)

	@fun_def source_comete_solo3($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop = 0) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::source_comete_solo3($server_name, $track_name, $mix_group, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop)) // instantie un le processus dans le dico
	}	
	@fun_def rand_lfo_basic_track_pos_x($min, $max, $init_val, $tpo, $type) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj_x")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj_x") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj_x", ::rand_lfo_basic_track_pos_x($server_name, $track_name, $mix_group, $min, $max, $init_val, $tpo, $type)) // instantie un le processus dans le dico
	}
	@fun_def rand_lfo_basic_track_pos_y($min, $max, $init_val, $tpo, $type) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj_y")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj_y") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj_y", ::rand_lfo_basic_track_pos_y($server_name, $track_name, $mix_group, $min, $max, $init_val, $tpo, $type)) // instantie un le processus dans le dico
	}
	@fun_def rand_lfo_basic_track_pos_z($min, $max, $init_val, $tpo, $type) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj_z")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj_z") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj_z", ::rand_lfo_basic_track_pos_z($server_name, $track_name, $mix_group, $min, $max, $init_val, $tpo, $type)) // instantie un le processus dans le dico
	}

	@fun_def rand_lfo_track_pos_xyz($min_x, $max_x, $init_val_x, $min_y, $max_y, $init_val_y, $min_z, $max_z, $init_val_z, $tpo, $type) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("_traj3D")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("_traj3D", ::rand_lfo_track_pos_xyz($server_name, $track_name, $mix_group, $min_x, $max_x, $init_val_x, $min_y, $max_y, $init_val_y, $min_z, $max_z, $init_val_z, $tpo, $type)) // instantie un le processus dans le dico
	}

	@fun_def rand_lfo_basic_track_pos_abort() 
	{
		abort $track_proc($server_name)($mix_group)($track_name)("_traj_x")
		abort $track_proc($server_name)($mix_group)($track_name)("_traj_y")
		abort $track_proc($server_name)($mix_group)($track_name)("_traj_z")
		abort $track_proc($server_name)($mix_group)($track_name)("_traj3D")
	}	

    // hacer para los otros lfos (sin,brown,etc)

   @fun_def rand_lfo_basic_s_track($param, $min, $max, $init_val, $type, $tpo)
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("rand_lfo")) // si ça existe abort et refait
	{
		// print abort_rand_track
		abort $track_proc($server_name)($mix_group)($track_name)("rand_lfo_basic_s_track") 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("rand_lfo_basic_s_track", ::rand_lfo_basic_s_track($server_name, $node_id_out, $param, $min, $max, $init_val, $type, $tpo)) // instantie un le processus dans le dico
	}

	///// track

	// hacer para todos los lfos

	@fun_def mod_kill($module, $fade_out) // kill module
	{
		// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)) matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($track_name)($module), ["matrix_ramp", $fade_out, "free", 0])
		//remove synth
		//$sc_struct($server_name)
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($track_name)($module)))
	}

	@fun_def pause($time)
	{
		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 0
		$Servers($server_name).n_set($group_id, ["matrix_ramp", @dur2sec($time), "gate", 0])
		// @dur2sec($time) scServer "n_set" $group_id gate 0
	}

	@fun_def resume($time)
	{	
		// scServer "n_run" $group_id 1
		$Servers($server_name).n_run($group_id, 1)

		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 1
		$Servers($server_name).n_set($group_id, ["matrix_ramp", @dur2sec($time), "gate", 1])

		forall $x in $sc_struct($server_name)($group_id) //
		{
			// scServer "n_run" $x 1
			$Servers($server_name).n_run($x, 1)
		}	
	}


	@fun_def mod_size($module)
	{
		return (($synths_map($server_name)($mix_group)($track_name)($module)).size())
	}



    @proc_def line_param($module, $param, $lmin1, $lmax1, $dur1, $type = "linear") 
    {
		  @local $lparam1, $nodes
	// .CheckParam($module, $param, $MYSELF)
			$nodes := $synths_map($server_name)($mix_group)($track_name)($module)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				forall $node in $nodes 
				{
					// scServer "n_set" $node $param $lparam1
					$Servers($server_name).n_set($node, [$param, $lparam1])
				}
			} 
		  { $lparam1 {            
					   {$lmin1} @type $type
				$dur1   {$lmax1}} 
		  }

    }

    @proc_def line_param_single($module, $num, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1, $node
	// .CheckParam($module, $param, $MYSELF)
			$node := $synths_map($server_name)($mix_group)($track_name)($module)[$num]
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $param $lparam1
				$Servers($server_name).n_set($node, [$param, $lparam1])
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}}
		  }
    }

  //   @proc_def bpf_param($module, $param, $bpf) 
  //   {
		// @local $nim, $lpar
		// $nim := @build_nim_from_bpf($bpf)
		// // .CheckParam($module, $param, $MYSELF)
		// // print $nim
		// $lpar := $bpf[0]
		// curve @grain := 0.01, 
		// @action 
		// {
		// 	forall $node in ($synths_map($server_name)($mix_group)($track_name)($module))
		// 	{
		// 		// scServer "n_set" $node $param $lpar 
		// 		$Servers($server_name).n_set($node, [$param ,$lpar])
		// 	}
		// } 
		// { $lpar : $nim }
  //   }

    @proc_def bpf_param($module, $param, $bpf) 
    {
		@local $nim, $lpar, $last_bpf_param_curve, $nodes

		$nodes := $synths_map($server_name)($mix_group)($track_name)($module)

		if($track_proc($server_name)($mix_group)($track_name).is_defined("bpf_param"+$module+$param))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("bpf_param"+$module+$param) // to avoid interferences
		}	

		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		// print module $module
		// print param $param
		// print bpf (""+$bpf)
		
		$lpar := $bpf[0]
		$last_bpf_param_curve := { curve 
			@tempo := $RT_TEMPO
			@grain := 0.01, 
			@action 
			{


				forall $node in $nodes
				{
					// scServer "n_set" $node $param $lpar 
					$Servers($server_name).n_set($node, [$param, $lpar])
				}
			} 
			{ $lpar : $nim }
			==> {
					forall $node in $nodes // rajoute changement parametre module dans $struct
					{
						$sc_struct($server_name)($node).add_pair($param, $lpar) 
					}
				}
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair("bpf_param"+$module+$param, $last_bpf_param_curve) // store curve in map to avoid interference between different groups
	}

    @proc_def bpf_param_single($module, $num, $param, $bpf) // seulement quand une un track a plusieurs instances du même module
    {
		@local $nim, $lpar, $node
		$node := $synths_map($server_name)($mix_group)($track_name)($module)[$num]
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			// scServer "n_set" ($synths_map($server_name)($mix_group)($track_name)($module)[$num]) $param $lpar
			$Servers($server_name).n_set($node, [$param, $lpar])
		} 
		{ $lpar : $nim }
    }

    @proc_def interpol_2tab_param($module, $param, $list, $intertime, $type = "linear") // for interpol between list (freqs, amps, etc)
    {
		@local $i_val, $last_bpf_param_curve

		if($track_proc($server_name)($mix_group)($track_name).is_defined("interp_tab_param"+$module+$param))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("interp_tab_param"+$module+$param) // to avoid interferences
		}	

	    $last_bpf_param_curve := { curve @Grain := 0.01,
		@action 
		{
			forall $x in ($synths_map($server_name)($mix_group)($track_name)($module))
			{
				$Servers($server_name).n_set($x, [$param, ($list[0]*$i_val)+($list[1]*(1-$i_val))])
			}
		}
		
		   { $i_val 	{            
						{0} @type $type
				 $intertime  	{1}
				} 
		   }	
	   }	
	   	$track_proc($server_name)($mix_group)($track_name).add_pair("interp_tab_param"+$module+$param, $last_bpf_param_curve) // store curve in map to avoid interference between different groups

    }

	// $tracks("track").interpol_formant(Multi5BandPass, $formants("bassI"), $formants("altoO"), 5) 

    @proc_def interpol_formant($module, $form1, $form2, $intertime, $type = "linear") // for interpol between list (freqs, amps, etc)
    {
		@local $i_val, $last_bpf_param_curve

		if($track_proc($server_name)($mix_group)($track_name).is_defined("interp_tab_param"+$module))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("interp_tab_param"+$module) // to avoid interferences
		}	

	    $last_bpf_param_curve := { 
	    	curve @Grain := 0.01,
			@action 
			{
				forall $x in ($synths_map($server_name)($mix_group)($track_name)($module))
				{
					$Servers($server_name).n_set($x, [freqs, ($formants($form1)[0]*$i_val)+($formants($form2)[0]*(1-$i_val))])
					$Servers($server_name).n_set($x, [amps, ($formants($form1)[1]*$i_val)+($formants($form2)[1]*(1-$i_val))])
					$Servers($server_name).n_set($x, [q, ($formants($form1)[2]*$i_val)+($formants($form2)[2]*(1-$i_val))])
				}
			}
			
			   { $i_val 	{            
							{0} @type $type
					 $intertime  	{1}
					} 
			   }	
	   }	
	   	$track_proc($server_name)($mix_group)($track_name).add_pair("interp_tab_param"+$module, $last_bpf_param_curve) // store curve in map to avoid interference between different groups

    }
    // interpolation tab multi formant
    @proc_def interpol_formant_multi($module, $form1_tab, $min_time, $max_time, $type = "linear", $tmpo = 60) // for interpol between list (freqs, amps, etc)
    {
		@local $i_val, $multi_curve, $del, $form1, $form2

		if($track_proc($server_name)($mix_group)($track_name).is_defined("interp_tab_multi"+$module))
		{
			abort $track_proc($server_name)($mix_group)($track_name)("interp_tab_multi"+$module) // to avoid interferences
		}	
		$del := @rand_range($min_time, $max_time)

		$form1 := @choose($form1_tab)
		$form2 := @choose($form1_tab)

		$multi_curve := { 
			group 
			{
				loop $del @tempo := $tmpo
				{
					$form1 := $form2
					$form2 := @choose($form1_tab)

					
			    	curve @Grain := 0.01,
					@action 
					{
						
						forall $x in ($synths_map($server_name)($mix_group)($track_name)($module))
						{
							$Servers($server_name).n_set($x, [freqs, ($formants($form1)[0]*$i_val)+($formants($form2)[0]*(1-$i_val))])
							$Servers($server_name).n_set($x, [amps, ($formants($form1)[1]*$i_val)+($formants($form2)[1]*(1-$i_val))])
							$Servers($server_name).n_set($x, [q, ($formants($form1)[2]*$i_val)+($formants($form2)[2]*(1-$i_val))])
						
						}
					}
					
					   { $i_val 	{            
									{0} @type $type
							 $del  	{1}
							} 
					   }	
					   $del := @rand_range($min_time, $max_time)
				}
	   		}	
   		}
	   	$track_proc($server_name)($mix_group)($track_name).add_pair("interp_tab_multi"+$module, $multi_curve) // store curve in map to avoid interference between different groups
    }

    @proc_def interpol_formant_multi_abort($module)
    {
    	abort $track_proc($server_name)($mix_group)($track_name)("interp_tab_multi"+$module)
    }

    @proc_def nim_param($module, $param, $nim) 
    {
		@local $lpar
		// $nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		// $lpar := $bpf[0]
		curve 
		@tempo := $RT_TEMPO,
		@grain := 0.01, 
		@action 
		{
			forall $node in ($synths_map($server_name)($group_name)($module))
			{
				// scServer "n_set" $node $param $lpar 
				$Servers($server_name).n_set($node, [$param, $lpar])

			}
		} 
		{ $lpar : $nim }
    }

    @proc_def nim_multi_param($module, $v_nim, $free = false) 
    {
		@local $lpar, $nim_play, $vzer_nim, $vzer_crv_size, $nims_agre := [], $nodes

		if($vezer_curves($v_nim).is_undef())
		{
			print this vezer xml file does not exist
		}
		else
		{
			$vzer_nim := $vezer_curves($v_nim)
			$vzer_crv_size := $vezer_curves($v_nim).size()
			// print vzer_nim (""+$vzer_nim)

			forall $n in $vzer_crv_size
			{
				$nims_agre.push_back($vzer_nim($n)[1])
			}
			// print nims_agre (""+$nims_agre)
			$nim_play := @aggregate($nims_agre) // aggregate nims for multidim
			// print nim_play (""+$nim_play)

			$nodes := $synths_map($server_name)($mix_group)($track_name)($module)

			curve 
			@tempo := $RT_TEMPO,
			@grain := 0.01, 
			@action 
			{
				forall $crv in $vzer_crv_size
				{
					forall $node in $nodes
					{
						// print  (""+[$vzer_nim($crv)[0], $lpar[$crv]])
						$Servers($server_name).n_set($node, [$vzer_nim($crv)[0], $lpar[$crv]])
					}
				}
			} 
			{ $lpar : $nim_play }
			==> {   if($free.is_numeric()) // if free number then free track in number time
			      	{
			         	$THISOBJ.free($free)
			      	}
			  	}
		}
    }  

	@fun_def sin_lfo($module, $param, $r_low, $r_hi, $t) 
    {
	@local $vst_nodeID, $vst_name

		if($vst_all_map.is_defined($module)) // VST existe?
		{				
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($mix_group)($track_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($mix_group)($track_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($mix_group)($track_name).add_pair(("vst"+$vst_nodeID+$param), ::sin_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t))  // instantie un le processus dans le dico
		}
		else
		{	
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
			{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_sin
				abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
			} 
			   $track_proc($server_name)($mix_group)($track_name)($x).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t))                	
		   }
	    }
	}

	@fun_def sin_lfo_single($module, $num, $param, $r_low, $r_hi, $t) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])

	if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	} 
	   $track_proc($server_name)($mix_group)($track_name)($node_num).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $node_num, $param, $r_low, $r_hi, $t))                	
	}


//($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo)
	@fun_def brown_lfo($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
		@local $vst_nodeID, $vst_name

		if($vst_all_map.is_defined($module)) // VST existe?
		{				
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($mix_group)($track_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($mix_group)($track_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($mix_group)($track_name).add_pair(("vst"+$vst_nodeID+$param), ::brown_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))  // instantie un le processus dans le dico
		}
		else
		{	    	
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
			{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_brown
				abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
			} 
			   $track_proc($server_name)($mix_group)($track_name)($x).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $x, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
		   }
	    }
	}

	@fun_def brown_lfo_single($module, $num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])

	if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($mix_group)($track_name)($module+$param) 
	} 
	   $track_proc($server_name)($mix_group)($track_name)($node_num).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $node_num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	}


	@fun_def rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo, $min_interval = 0) 
	{ 
		@local $vst_nodeID, $vst_name

		// if($module.is_tab()) // for VST
		// {
			// if($module[0] == "VST") // ["VST", "my_plugins"]
			// {
		if($vst_all_map.is_defined($module)) // VST existe?
		{				
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($mix_group)($track_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($mix_group)($track_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($mix_group)($track_name).add_pair(("vst"+$vst_nodeID+$param), ::rand_lfo_vst($server_name, $vst_name, $vst_nodeID, $param, $min, $max, $init_val, $type, $tpo))  // instantie un le processus dans le dico

			// }
		}
		else
		{
			forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
			{
				if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_rand
				abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
			}
				$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $tpo, $min_interval, $gui)) // instantie un le processus dans le dico
			}	
		}

	}

	@fun_def rand_lfo_dyn($module, $param, $init_val, $type, $tpo, $ref_obj) 
	{ 

		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		}																								   //$server_name, $module, $param, $init_val, $type, $tpo, $ref_obj
			$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::rand_lfo_dyn($server_name, $x, $param, $init_val, $type, $tpo, $ref_obj)) // instantie un le processus dans le dico
		}	
	}

	@fun_def rand_lfo_dyn_bpf($module, $param, $init_val, $bpf_end_val, $type, $tpo) 
	{ 

		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
		}																								   //  ($server_name, $module, $param, $init_val, $bpf_end_val, $type, $tpo)
			$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::rand_lfo_dyn_bpf($server_name, $x, $param, $init_val, $bpf_end_val, $type, $tpo)) // instantie un le processus dans le dico
		}	
	}	

	@fun_def rand_lfo_single($module, $num, $param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($track_name)($module))
		if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($track_name)($node_num).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $node_num, $param, $min, $max, $init_val, $type, $tpo))		
	}


	@fun_def tri_lfo($module, $param, $r_low, $r_hi, $t, $type1 = "linear", $type2 = "linear") 
	{ 
		@local $vst_nodeID, $vst_name

		if($vst_all_map.is_defined($module)) // VST existe?
		{				
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($mix_group)($track_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($mix_group)($track_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($mix_group)($track_name).add_pair(("vst"+$vst_nodeID+$param), ::lfo_tri_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t, $type1, $type2))  // instantie un le processus dans le dico
		}
		else
		{				
			forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
			{
				if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_lfo_tri
				abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
			}
				$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2)) // instantie un le processus dans le dico

			}
		}
	}


	@fun_def tri_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $type1, $type2) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($track_name)($module))
		if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($track_name)($node_num).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2))		
	}



	@fun_def saw_lfo($module, $param, $r_low, $r_hi, $t, $dir, $type) 
	{ 
		@local $vst_nodeID, $vst_name

		if($vst_all_map.is_defined($module)) // VST existe?
		{				
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($mix_group)($track_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($mix_group)($track_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)("vst"+$vst_nodeID+$param) 
		}
		$track_proc($server_name)($mix_group)($track_name).add_pair(("vst"+$vst_nodeID+$param), ::saw_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t, $dir, $type))  // instantie un le processus dans le dico
		}
		else
		{			
			forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
			{
				if($track_proc($server_name)($mix_group)($track_name)($x).is_defined($module+$param)) // si ça existe abort et refait
			{
				print abort_lfo_tri
				abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
			}
				$track_proc($server_name)($mix_group)($track_name)($x).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type)) // instantie un le processus dans le dico

			}
		}
	}


	@fun_def saw_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $dir, $type) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($track_name)($module))
		if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($track_name)($node_num).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type))		
	}

	@fun_def lfo_abort($module, $param)
	{
	@local $vst_nodeID, $vst_name
	
		if($vst_all_map.is_defined($module)) // VST existe?
		{			
			$vst_name := $module
			$vst_nodeID := $vst_plugins($server_name)($mix_group)($track_name)($vst_name) // retrieve id des vst_plugins
			
			if($track_proc($server_name)($mix_group)($track_name).is_defined("vst"+$vst_nodeID+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)("vst"+$vst_nodeID+$param) 
		}
		else
		{
			print lfo_abort $module $param does not existe
		}
		}
		else
		{ 			
			forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
			{
				abort $track_proc($server_name)($mix_group)($track_name)($x)($module+$param) 
			}
		}
	}

	@fun_def lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$num])

		abort $track_proc($server_name)($mix_group)($track_name)($node_num)($module+$param) 
	}

///////// rythms seq, prob


	@proc_def ryth_seq($mod_params, $ritmos_tab, $prob, $rit, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				if($x[0] == "HOA_Encode")
				{
					$node_params.push_back(["HOA_Encode", $node_id_out].concat($x.cdr())) // for ambisonic encoder coords
					// print cons_decoder (""+$node_id_out.cons($x.cdr()))
				}
				else
				{
					// print mod_params (""+$x)
					$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
				}
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		// print node_params (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_seq($server_name, $node_params, $ritmos_tab, $prob, $rit, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

	@proc_def ryth_vect_prob($mod_params, $ryth_tab, $ryth_prob, $prob, $rit, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				if($x[0] == "HOA_Encode")
				{
					$node_params.push_back(["HOA_Encode", $node_id_out].concat($x.cdr())) // for ambisonic encoder coords
					// print cons_decoder (""+$node_id_out.cons($x.cdr()))
				}
				else
				{
					// print mod_params (""+$x)
					$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
				}
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		// print node_params (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_vect_prob($server_name, $node_params, $ryth_tab, $ryth_prob, $prob, $rit, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

	@proc_def ryth_vect_prob_mod_sin($mod_params, $ryth_tab, $ryth_prob, $prob, $r_low, $r_hi, $t, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				if($x[0] == "HOA_Encode")
				{
					$node_params.push_back(["HOA_Encode", $node_id_out].concat($x.cdr())) // for ambisonic encoder coords
					// print cons_decoder (""+$node_id_out.cons($x.cdr()))
				}
				else
				{
					// print mod_params (""+$x)
					$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
				}
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		// print node_params (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_vect_prob_mod_sin($server_name, $node_params, $ryth_tab, $ryth_prob, $prob, $r_low, $r_hi, $t, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

	@proc_def ryth_vect_prob_mod_sin_dur($mod_params, $ryth_tab, $ryth_prob, $prob, $r_low, $r_hi, $t, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				if($x[0] == "HOA_Encode")
				{
					$node_params.push_back(["HOA_Encode", $node_id_out].concat($x.cdr())) // for ambisonic encoder coords
					// print cons_decoder (""+$node_id_out.cons($x.cdr()))
				}
				else
				{
					// print mod_params (""+$x)
					$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
				}
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		// print node_params (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_vect_prob_mod_sin_dur($server_name, $node_params, $ryth_tab, $ryth_prob, $prob, $r_low, $r_hi, $t, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}
	
	@proc_def change_proc_mod_sin_r_low_tpo($val) 
	{
		@local $nim, $lpar, $proc_name := "prob"+$track_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
					
				let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$r_low := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$r_low := $val

		}
	}

	@proc_def change_proc_mod_sin_r_hi_tpo($val) 
	{
		@local $nim, $lpar, $proc_name := "prob"+$track_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
				let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$r_hi := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$r_hi := $val

		}
	}

	@proc_def ryth_prob_rand($mod_params, $prob, $rmin, $rmax, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				// print mod_params (""+$x)
				if($x[0] == "HOA_Encode")
				{
					$node_params.push_back(["HOA_Encode", $node_id_out].concat($x.cdr())) // for ambisonic encoder coords
					// print cons_decoder (""+$node_id_out.cons($x.cdr()))
				}
				else
				{
					$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
				}
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		// print node_params (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_prob_rand($server_name, $node_params, $prob, $rmin, $rmax, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}


	@proc_def ryth_prob_rand_mod($mod_params, $prob, $rmin, $rmax, $r_low, $r_hi, $t, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				// print mod_params (""+$x)
				if($x[0] == "HOA_Encode")
				{
					$node_params.push_back(["HOA_Encode", $node_id_out].concat($x.cdr())) // for ambisonic encoder coords
					// print cons_decoder (""+$node_id_out.cons($x.cdr()))
				}
				else
				{
					$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
				}
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		// print node_params (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_prob_rand_mod($server_name, $node_params, $prob, $rmin, $rmax, $r_low, $r_hi, $t, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

	@proc_def ryth_stop()
	{	
		@local $proc_name := "prob"+$track_name

		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}

	@proc_def ryth_prob($mod_params, $prob, $rit, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$track_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				// print mod_params (""+$x)
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		print node_params_ryth_prob (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, ::ryth_prob($server_name, $node_params, $prob, $rit, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}


	@proc_def change_prob($val)
	{
		@local $nim, $lpar, $proc_name := "prob"+$track_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			// .CheckParam($module, $param, $MYSELF)
			// print $nim
			// [2000, 5, "exp", 20, 3, 3000, 10, "exp_out", 20]
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
				let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$prob := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$prob := $val

		}
	}

	@proc_def change_proc_tempo($val) 
	{
		@local $nim, $lpar, $proc_name := "prob"+$track_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			// .CheckParam($module, $param, $MYSELF)
			// print $nim
			// [2000, 5, "exp", 20, 3, 3000, 10, "exp_out", 20]
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
				let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$tpo := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($track_name)($proc_name)).$tpo := $val

		}
	}

	@proc_def track_rand_lfo_global_send($proc_name, $rand_lfo_instance, $modules_params) // $modules_params -> module, params, min, max
	{
		@local $node_params := [] //, $proc_name := "toto"

		forall $x in $modules_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		// print (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, $node_params))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}

	@broadcast track_rand_lfo_global_send_all($proc_name, $rand_lfo_instance, $modules_params) // $modules_params -> module, params, min, max
	{
		@local $node_params := [] //, $proc_name := "toto"
		
		forall $x in $modules_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		// print (""+$node_params)

		if($track_proc($server_name)($mix_group)($track_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($track_name)($proc_name) 
	}
		$track_proc($server_name)($mix_group)($track_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, $node_params))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($track_name))
	}	

	@broadcast track_change_param_all($mod_params) //change pour toutes les instances de l'objet
	{
		@local $node_params := []
		
		forall $x in $mod_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($track_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		forall $y in $node_params // 
		{
			
			$Servers($server_name).n_set($node_params.car(), $node_params.cdr())		
		}		
		// $THISOBJ.change_param($module, $param, $lin) // change parametres pour toutes les objets play_Ingran_rand_paramA
		// $THISOBJ.change_tempo($lin_t)
	}

	@fun_def gui($module = <undef>, $view = 1)
	{
		@local $addsynth := [], $tab_ids, $vst_id
		if($module == <undef>)
		{		
		$tab_ids := $sc_struct($server_name)($group_id).drop(-1)
		$gui := true
		// TTracks8.new(track_name.asString, nil, group, bus, outsynth);
		print $tab_ids

		forall $x in $tab_ids
		{
			// print (""+($sc_struct($server_name)($group_id)($x)))
			// print (""+($sc_struct($server_name)($x)))
			$addsynth.push_back($x)
			$addsynth.push_back($sc_struct($server_name)($x)("_synth"))
			// $addsynth.push_back($sc_struct($server_name)($group_id)($x))
		}
		gui_antes $server_name $track_name $group_id $bus $node_id_out $addsynth

		// forall $k, $v in $track_proc($server_name)($mix_group)($track_name) // active envoie OSC vers GUI
		// {
		// 	if($v.size > 0) // si la valeur contiens deja un proc avant creation GUI
		// 	{
		// 		$v.$gui := true // alors activer l'envoie par l'argument $gui (variable locale) 
		// 	}
		// }
		}
		else
		{
			if($vst_all_map.is_defined($module)) // VST existe?
			{
				if($vst_all_map($module)("sdkversion")[4] == "3") // pour VST3
			    {
					$module := $module+".vst3"
			    }
			$vst_id := $vst_plugins($server_name)($mix_group)($track_name)($module) // retrieve vst node_id
			print vst_ID $vst_id
			$Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
			}
			else
			{
				print "module not found"
			}
		}
	}

	@fun_def vst_gui($vst_module, $view) // vst_name, open = 1, close = 0
	{
		// @local $vst_id
		// $vst_id := $vst_plugins($server_name)($mix_group)($track_name)($vst_module) // retrieve vst node_id

		// $Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id

		@local $vst_id
		if($vst_all_map.is_defined($vst_module)) // VST existe?
		{
			if($vst_all_map($vst_module)("sdkversion")[4] == "3") // pour VST3
		    {
				$vst_module := $vst_module+".vst3"
		    }
			$vst_id := $vst_plugins($server_name)($mix_group)($track_name)($vst_module) // retrieve vst node_id
			$Servers($server_name).u_cmd([$vst_id, 6, "/vis", $view]) // 6 Synthdef UGEN id
		}
		else
		{
			print "module not found"
		}			
		
	}

	// @proc_def ryth_prob($module, $param, $val, $prob, $tmpo) // @proc_def parce qu'il y a un delay pour arrter les proc
	// {
	// 	@local $noterest := 0, $node_id

	// 	$node_id := ($synths_map($server_name)($mix_group)($track_name)($module))

	// 	loop $rit @tempo := $tmpo
	//                 {
 //                        $noterest := ((@rand(1.) < $prob)? 1: 0)
 //                        if ($noterest == 1)
 //                        {

 //                                // crea_track8 $track set 01_TGranInterpExt t_trig 1
 //                                scServer "n_set" $node_id $module $param $val
 //                                $t_trig := 1
 //                                // if($rand_spat_pos)
 //                                // {
 //                                //         crea_track8 $track set 02_TPan8 pos @choose($tpan_hp_tab)

 //                                // }
 //                        }
	//                     $rit := @rand_range($rmin, $rmax)
	//                 }
 //    }

	// @proc_def ryth_prob($module, $param, $val, $prob, $tmpo) // @proc_def parce qu'il y a un delay pour arrter les proc
	// {
	// 	@local $noterest := 0, $node_id

	// 	$node_id := ($synths_map($server_name)($mix_group)($track_name)($module))

	// 	loop $rit @tempo := $tmpo
	//                 {
	//                         $noterest := ((@rand(1.) < $prob)? 1: 0)
	//                         if ($noterest == 1)
	//                         {

	//                                 // crea_track8 $track set 01_TGranInterpExt t_trig 1
	//                                 scServer "n_set" $node_id $module $param $val
	//                                 $t_trig := 1
	//                                 // if($rand_spat_pos)
	//                                 // {
	//                                 //         crea_track8 $track set 02_TPan8 pos @choose($tpan_hp_tab)
	
	//                                 // }
	//                         }
	//                 }
 //    }



	@fun_def play_sample($sample, $ampli = 0, $loop = 0)
	{
		$THISOBJ.mod_add_top(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop])
		print sample (""+$SF_map($server_name)($sample))
	}

	@fun_def play_sampleHOA($sample, $ampli = 0, $coord = [1, 0, 0], $loop = 0) // only track no_encoder
	{
		$THISOBJ.mod_add_top(["TPlaybuf2_HOA"+$order, "buf", $SF_map($server_name)($sample), "amp", $ampli, "coords", $coord, "globTBus", $bus, "loop", $loop])
		print sample (""+$SF_map($server_name)($sample))
	}	
	@fun_def play_sample2($sample, $ampli = 0, $loop = 0)
	{
		$THISOBJ.mod_add_top(["TPlaybuf2_ste", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop])
		print sample (""+$SF_map($server_name)($sample))
	}

	@proc_def play_sample_ste_HOA($sample, $ampli = 0, $coords = [1, -90, 0, 1, 90, 0], $loop = 0) // only track no_encoder
	{
		// $THISOBJ.mod_add_top(["TPlaybuf2_HOA_ste"+$order, "buf", $SF_map($server_name)($sample), "amp", $ampli, "coords", $coord, "globTBus", $bus, "loop", $loop])
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$sflist_map.add_pair($sample, $node_id_mod)
		$Servers($server_name).s_new(["TPlaybuf2_HOA_ste"+$order, $node_id_mod, 2, $node_id_out, "globTBus", $bus, "buf", $SF_map($server_name)($sample), "coords", $coords, "amp", $ampli, "loop", $loop])
		// print (""+["TPlaybuf2_HOA_ste"+$order, $node_id_mod, 2, $node_id_out, "globTBus", $bus, "buf", $SF_map($server_name)($sample), "coords", $coords, "amp", $ampli, "loop", $loop])
		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		print sample (""+$SF_map($server_name)($sample))
	}

	@fun_def play_sampleHOA_stop($sample, $fade_out = 0.1) 
	{
		$Servers($server_name).n_set($sflist_map($sample), [matrix_out, $fade_out, free, 0])
	}

	@fun_def play_sampleHOA_stopAll($sample, $fade_out = 0.1) 
	{	
		forall $k, $v in $sflist_map
		{
			$Servers($server_name).n_set($v, [matrix_out, $fade_out, free, 0])
		}
	}
	// hacer map para controlar stop samples specificos 
	@fun_def play_sample_stop($sample, $fade_out = 0.1) // hacer map con samplers tocados para stop
	{
		$THISOBJ.set("TPlaybuf2", ["matrix_ramp", $fade_out, "free", 0])
		$THISOBJ.set("TPlaybuf2_ste", ["matrix_out", $fade_out, "free", 0])
	}

	@fun_def play_sample8($sample, $ampli = 0, $loop = 0)
	{
		print play_sample8
		$THISOBJ.mod_add(["TPlaybuf8", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop], "top")
	}	

	@fun_def play_sample8_stop($sample, $fade_out = 0.1) // hacer map con samplers tocados para stop
	{
		$THISOBJ.set("TPlaybuf8", ["matrix_ramp", $fade_out, "free", 0])
	}

	@fun_def play_sample16($sample, $ampli = 0, $loop = 0)
	{
		$THISOBJ.mod_add_top(["TPlaybuf16", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop])
	}	

	@fun_def play_sample16_stop($sample, $fade_out = 0.1) // hacer map con samplers tocados para stop
	{
		$THISOBJ.set("TPlaybuf16", ["matrix_ramp", $fade_out, "free", 0])
	}

	@fun_def play_sample24($sample, $ampli = 0, $loop = 0)
	{
		$THISOBJ.mod_add_top(["TPlaybuf24", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop])
	}	

	@fun_def play_sample24_stop($sample, $fade_out = 0.1) // hacer map con samplers tocados para stop
	{
		$THISOBJ.set("TPlaybuf24", ["matrix_ramp", $fade_out, "free", 0])
	}

	@proc_def playsegments($buf_id, $segment_tab, $ryth_loop, $dur_secs, $ampli = 0, $loop = 0) // hacer map con samplers tocados para stop
	{
		@local $inc_seg := 0, $dur_seg := 0

		loop $ryth_loop
		{
			$dur_seg := (($segment_tab[$inc_seg+1] - $segment_tab[$inc_seg]) / $sampling_rate) * 0.98 // 98% to avoid 
			print (""+["Sample_play_seg", "buf", $buf_id, "pos", $segment_tab[$inc_seg], "dur_secs", $dur_seg, "amp", $ampli, "loop", $loop])
			$THISOBJ.mod_add(["Sample_play_seg", "buf", $buf_id, "pos", $segment_tab[$inc_seg], "dur_secs", $dur_seg, "amp", $ampli, "loop", $loop], "top")
			$inc_seg += 1
		} until ($inc_seg == $segment_tab.size()-1)
	}


	@proc_def play_sample_gesture_pos_trig($list_samples) // interpol par boule
	{
		@local $last_val := 0
		whenever ($likelihood == $likelihood) // likelihood viene de Max gmm static posture recognition index
		{					               
				 if ($likelihood != $last_val) { //change dans Max
					$last_val := $likelihood
					print likelihood $likelihood
					// HOA_sample_xyz($buf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder) 
			  ::HOA_sample_xyz($SF_map($server_name)($list_samples[$likelihood-1]), 1, 1, 0, @rand_range(1, -1), @rand_range(1, -1), 0, 0, $mix_group)
				// $THISOBJ.mod_add_top(["TPlaybuf2", "buf", $SF_map($list_samples[$likelihood-1]), "amp", 0, "loop", 0])
		}
		}
	}

	//// Needs gesture riot lib

	@fun_def map_gesture($gest, $module, $param, $min, $max) // ($L_incli_lateral, "TMFxShift2", "modfreq", 1, 60)
	{
		print gest_inside_obj (""+$gest)
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined("gest"+$module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($x)("gest"+$module+$param) 
		}
			$track_proc($server_name)($mix_group)($track_name)($x).add_pair(("gest"+$module+$param), obj::map_gesture($gest, $server_name, $group_id, $x, $param, $min, $max)) // instantie un le processus dans le dico

		}
	}

	@fun_def map_gesture_index($gest, $module, $index, $param, $min, $max) // $tracks("synth1").map_gesture_index($L_incli_lateral, "TMFxShift2", 0, "modfreq", 1, 60)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($track_name)($module)[$index])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($track_name)($module))
		if($track_proc($server_name)($mix_group)($track_name)($node_num).is_defined("gest"+$module+$param)) // si ça existe abort et refait
		{
			print abort_rand_s
			abort $track_proc($server_name)($mix_group)($track_name)($node_num)("gest"+$module+$param) 
		}
		$track_proc($server_name)($mix_group)($track_name)($node_num).add_pair(("gest"+$module+$param), obj::map_gesture($gest, $server_name, $group_id, $node_num, $param, $min, $max))	
	}

	@fun_def map_gesture_func($gest, $func, $module, $param, $min, $max) // ($L_incli_lateral, "TMFxShift2", "modfreq", 1, 60)
	{
		print gest_inside_obj (""+$gest)
		forall $x in ($synths_map($server_name)($mix_group)($track_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($track_name)($x).is_defined("gest"+$module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)($x)("gest"+$module+$param) 
		}
			$track_proc($server_name)($mix_group)($track_name)($x).add_pair(("gest"+$module+$param), obj::map_gesture_func($gest, $func, $server_name, $group_id, $x, $param, $min, $max)) // instantie un le processus dans le dico

		}
	}

	@fun_def map_gesture_func_amp($gest, $func, $min, $max) // ($L_incli_lateral, "TMFxShift2", "modfreq", 1, 60)
	{
		if($track_proc($server_name)($mix_group)($track_name).is_defined("gest_amp")) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($track_name)("gest_amp") 
		}
		$track_proc($server_name)($mix_group)($track_name).add_pair(("gest_amp"), obj::map_gesture_func_amp($gest, $func, $server_name, $node_id_out2, $min, $max)) // instantie un le processus dans le dico		
	}


	@fun_def map_gesture_ambi_pol_angle($gest, $radio, $min, $max) 
	{ 
		if($track_proc($server_name)($mix_group)($track_name).is_defined("gest_spat")) // si ça existe abort et refait
	{
		// print abort_rand
		abort $track_proc($server_name)($mix_group)($track_name)("gest_spat") 
	}

		$track_proc($server_name)($mix_group)($track_name).add_pair("gest_spat", obj::map_gesture_ambi_pol_angle($server_name, $node_id_out2, $mix_group, $gest, $radio, $min, $max)) // instantie un le processus dans le dico
	}

	///////////////

	@fun_def server_name() 
	{ 
		return $server_name
	}

	@proc_def free($time = 1) // @proc_def parce qu'il y a un delay pour arrter les proc
	{
		// print track_proc_integral (""+$track_proc)
		// scServer "n_set" $node_id_out out_ramp @dur2sec($time) gatee 0 // free group in $time
		$Servers($server_name).n_set($node_id_out2, ["out_ramp", @dur2sec($time), "gatee", 0])

		// print free $track_name in @dur2sec($time) seconds

		// ("abort track "+ $THISOBJ).post()
		// ("server_name "+ $server_name).post()
		// ("mix_group "+ $mix_group).post()
		// ("track_name "+ $track_name).post()
		// ($track_proc($server_name)($mix_group)($track_name)).post()
		// if(($track_proc($server_name)($mix_group)($track_name)).is_undef())
		// {
		// 	($time+0.01) group // remove all maps
		// 	{
		// 		$track_proc($server_name)($mix_group).remove($track_name) // delete track_proc from map
		// 		$SC_Groups($mix_group)("sub_group").remove($track_name) // delete sub_group objects
		// 	}
			
		// }
		// else
		// {
		 				// $track_proc($server_name)($mix_group)($track_name).add_pair(($index+"_rambi_orbit"), ::ambi_orbit($server_name, $index, $node_id_out, $angle, $grain)) // instantie un le processus dans le dico
			// group
			// {

			// }
			group
			{
			($time-0.01) forall $k, $v in $track_proc($server_name)($mix_group)($track_name) // parcours liste de nodes
					{
					

					if($k == $node_id_out+"_multi_lfo_track")
					{
						$THISOBJ.dae_rand_lfo_abort()
					}
					// print track_proc (""+$v)
					if($v.is_map()) // si map abort proc modules
					{
						forall $proc_name, $proc in $v // parcours liste de proc en route
						{
								// ("abort proc_name " + $proc_name).post()
								// ("abort proc " + $proc_name).post()
								abort $proc

						}
					}
					else // si proc solo proc de HOA (orbit, ...)
					{
						if($v.is_tab()) // si map abort proc modules
						{
							forall $p in $v
							{
								abort $p
							}
						}
						else
						{
							abort $v
							
						}
					}
				}

			// $track_proc($server_name)($mix_group).remove($track_name) // delete track_proc from map
			// $SC_Groups($mix_group)("sub_group").remove($track_name) // delete sub_group objects
			// }

		// }

			($time+0.01) forall $id in $sc_struct($server_name)($group_id)[0]
			{
				// print remove_node_node_id $id in $track_name
				// print remove_node_node_id_map (""+$sc_struct($server_name)($id))
				$sc_struct($server_name).remove($id)
			}

			// print antesborrar (""+$sc_struct($server_name)($main_group_id))
			// print borrar (""+$struct_main_group_id.occurs($group_id))
			$free_track := $track_name
			0.1 $track_proc($server_name)($mix_group).remove($track_name) // delete track_proc from map
			$SC_Groups($mix_group)("sub_group").remove($track_name) // delete sub_group objects
			$struct_main_group_id.remove($struct_main_group_id.occurs($group_id))
			// print remove id $group_id
			$sc_struct($server_name).remove($group_id) // enleve group key de la MAP $sc_struct 
			$synths_map($server_name)($mix_group).remove($track_name) // delete synths_map from map
			$tracks.remove($track_name)
			$trajs.remove($proc_index)
			
			0.5 abort $THISOBJ // abort objet after 1 time
			}
			
		// 	}
	}

	@abort
	{
		print remove $track_name object
		// print "abort" toto $track_name object
	    // $THISOBJ.free() // 
	 //    forall $k, $v in $track_proc($server_name)($track_name) // abort processus
		// {
		// 	abort $v
		// }
	}
}

// actions à faire quand seuil amp:

whenever ($track_amp_action==$track_amp_action)
{
	if($track_amp_action.dim() > 1 && $track_amp_action.car().is_tab())
	{
		forall $action in $track_amp_action
		{
			switch ($action[0])
			{
				case "clearbuf":
					@local $clear_buf
					$clear_buf := $action[1]
					$clear_buf.clear()
					// print clear buffer ($action[1].id())
				case "abort":
				abort $action[1]
			}
		}
	}
	else
	{
		switch ($track_amp_action[0])
		{
			case "clearbuf":
				@local $clear_buf
				$clear_buf := $track_amp_action[1]
				$clear_buf.clear()
				// print clear buffer ($track_amp_action[1].id())
			case "abort":
			abort $track_amp_action[1]
		}
	}

}


@obj_def crea_aux_HOA($aux_name, $mix_group, $synth_collection, $fade_in = 1, $amp = 0, $spk_radius = 1.07) // recuperar el nombre de la variable
{
    @init 
    {
	    @local $group_id, $bus, $gbus, $hoa_bus, $rev_bus, $ambi_bus, $node_id_out, $gui, $server_name, $main_group_id, $rand_spat_pos := false, $t_trig := 0, $order, $hoa_num_ch, $decoder_id, $aux_track_map := map{}


		if($SC_Groups($mix_group).is_undef()) // si le groupe n'existe pas
		{
			print this "group" does not exist
		} 
		else
		{
			if($mix_group == "default")
			{
				print default
				// $server := $SC_Servers($mix_group[0])
				$main_group_id := 1
			}
			else
			{
				if($tracks($aux_name).is_undef())
				{
					// print no_default
					$server_name := $SC_Groups($mix_group)("server_name")
					$main_group_id := $SC_Groups($mix_group)("main_group_id")
					$gbus := $SC_Groups($mix_group)("main_bus")
					// $rev_bus := $SC_Groups($mix_group)("hoa_rev_bus")
					$hoa_bus := $SC_Groups($mix_group)("hoa_bus")
					$order :=  $SC_Groups($mix_group)("order")
					$decoder_id :=  $SC_Groups($mix_group)("decoder_id")
					
					// $SC_Groups($group_name).insert("hoa_bus", $hoa_bus)
	    // 			$SC_Groups($group_name).insert("rev_bus", $rev_bus)
				

				    $group_id := $SC_Servers($server_name)("node_id")
				    $bus := $SC_Servers($server_name)("bus_index")
				 //    $rev_bus := $SC_Servers($server_name)("rev_bus")
					// $hoa_bus := $SC_Servers($server_name)("hoa_bus") 
				    print bus $bus
				    // print rev_bus $rev_bus
				    print hoa_bus $hoa_bus
				    print group_id $group_id
				    print server_name $server_name
				    print main_group_id $main_group_id

				    $gui := false

				    // $aux_name := ("group_"+$group_id)

				    $hoa_num_ch := ($order+1).pow(2) // HOA number of channels

				    // print aux_name $aux_name
					print $server_name
					// print synths_map (""+$synths_map)

				    $synths_map($server_name)($mix_group).insert($aux_name, map{}) // map pour synth à reemplacer par sc_struct plus tard
				    $track_proc($server_name)($mix_group).insert($aux_name, map{}) // map des processus pour chaque track
				    

				    
				    // print synths_map (""+$synths_map)
				    // print track_proc (""+$track_proc)
				    // print toto

				    // scServer "g_new" $group_id 0 $main_group_id // group_id, add group to the head [0], into group $main_group_id
				    $Servers($server_name).g_new($group_id, 2, $decoder_id)
				    //SuperNova
				    // scServer "p_new" $group_id 0 $main_group_id // group_id, add group to the head [0], into group $main_group_id

				    $SC_Servers($server_name).add_pair("node_id", $group_id + 1)
				    // $node_id := $node_id + 1
				    // print $node_id
				    $node_id_out := $SC_Servers($server_name)("node_id")
				    // $node_id_out := $node_id
				    // scServer "s_new" audioOut8 $node_id_out 1 $group_id in $bus out ($gbus+$chnl) index $bus in_ramp $fade_in amp $amp
				    
				    // ~espace = Synth(\HOA_Encode4_out, [\in,  ~bus1, \dopon, 1, \glev, 1, \llev, 1, \gbfbus, ~gbfbus, \globTBus, ~globTBus], ~s1, \addAfter)

				    // scServer "s_new" ("HOA_Encode"+$order+"_out") $node_id_out 1 $group_id in $bus globTBus $hoa_bus in_ramp $fade_in amp $amp dopon 1 dopamnt 1 glev 1 llev 1  //gbfbus $rev_bus

				    $Servers($server_name).s_new(["HOA_Encode"+$order+"_out", $node_id_out, 1, $group_id, "in", $bus, "globTBus", $hoa_bus, "in_ramp", $fade_in, "amp", $amp, "dopon", 1, "dopamnt", 1, "glev", 1, "llev", 1, "spk_radius", $spk_radius])
				    print ("s_new"+$server_name) ("HOA_Encode"+$order+"_out") $node_id_out 1 $group_id in $bus  globTBus $hoa_bus in_ramp $fade_in amp $amp dopon 1 dopamnt 1 glev 1 llev 1  //gbfbus $rev_bus

				    // ~espace = Synth(\ATK_Omni_8_new, [\in,  ~bus1, \dopon, 1, \glev, 1, \llev, 1, \gbfbus, ~gbfbus, \globTBus, ~globTBus], ~s1, \addAfter)
				    _ := $synths_map($server_name)($mix_group)($aux_name).insert("group", $group_id)
					_ := $synths_map($server_name)($mix_group)($aux_name).insert("audioOut8", $node_id_out)

					////// 
					$aux.add_pair($aux_name, $THISOBJ) // put this group object in dico $aux

					$sc_struct($server_name)($main_group_id).push_front($group_id) // !!!!!! !!!!! root tree 0
				    $sc_struct($server_name).add_pair($group_id, [$node_id_out]) // crea nueva key group + audioOut
					$sc_struct($server_name).add_pair($node_id_out, map{("_synth", "HOA_Encode"+$order+"_out"), ("globTBus", $hoa_bus), ("in", $bus), ("in_ramp", $fade_in), ("amp", $amp), ("dopon", 1), ("glev", 1), ("llev", 1) }) // , ("gbfbus", $rev_bus) crea MAP para nombre_synth + parametros
					
					$SC_Servers($server_name).insert("bus_index", $bus+$hoa_num_ch) // incrementa bus de server A ver en funcion del decoder!!!!!!!
					// $rev_bus := $SC_Servers($server_name)("bus_index")
					// $SC_Servers($server_name).insert("bus_index", $bus+4) // incrementa bus de server para ambi rev

				    // $node_id := $node_id + 1 // incremente de 1 la variable $node_id pour le prochain node
					$SC_Servers($server_name).insert("node_id", $node_id_out + 1)
				    
				    $SC_Groups($mix_group)("aux_sub_group").add_pair($aux_name, $THISOBJ) // store thisobject in TAB of SC_Groups(mix_group)

				    $THISOBJ.mod_add($synth_collection)
						// forall $x in $synth_collection
					    // {
					    //         $THISOBJ.mod_add($x)
					    // } 
				}
				    else
					{
						print this track exist
					}
				}
			}
   }

   @fun_def mod_add($module, $action = "before_out", $target_mod = <undef>, $fade_in = 0.01)
   {
	@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod, $target_id, $mod_name, $json_file, $json_map

	$node_id_mod := $SC_Servers($server_name)("node_id") // last id

    if($target_mod.is_undef())
    {
	$target_mod := $node_id_out
    }

    $target_id := $synths_map($server_name)($mix_group)($aux_name)($target_mod)[0] // recupera $target_id

    print modules_synth1 (""+$module)

    print size ($module.size())
    // print params $params
    if ($module.dim() > 1 && $module.car().is_tab()){ // si c'est tab multi
    print MULTI_
	forall $chain in $module // s'il y a plus des modules
	{
		print chain_synth1 $chain
		$params := $chain.cdr()
		print test_syn1_params (""+$params)
			// scServer "s_new" ($chain[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			// $Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

			switch ($action)
		{
			case "before_out":
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
				case "after":
				// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
				case "before":
				// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
				case "top":
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
			}

			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($aux_name)($mix_group)($chain[0]))

			if(($synths_map($server_name)($mix_group)($aux_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($chain[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name).insert($chain[0], [$node_id_mod]) // si n'existe pas creer une MAP avec TAB
			}else 
			{
				// print ($chain[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name)($chain[0]).push_back($node_id_mod) // si existe rajouter a la TAB

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		$node_id_mod := $SC_Servers($server_name)("node_id") // set prochain id au nouveau id ligne precedente


		}
	}else{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			// print DIM 1
			// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
			$params := $module.cdr()
			$mod_name := $module.car()
			// print $params
			if($params.car() == "preset"){
				@local $params_preset, $par_init, $inc := 0

				$json_file := $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"

				$json_file := @json_read($json_file)
				// print JSON (""+$json_file($mod_name)($params[1]))
				$params_preset := $json_file($mod_name)($params[1]) // recupere la map du preset
				
				if($params_preset.is_undef())
				{
					print "this preset does not exist"
				}
				else
				{
					$par_init := $params.drop(2)

					loop 
					{
						$params_preset.add_pair($par_init[$inc], $par_init[$inc+1]) // replace parameters after 
						$inc += 2
					} until ($inc==$par_init.size())

					$params := $params_preset.map2tab() // convert map to tab
				}

			}

			// scServer "s_new" ($module[0]) $node_id_mod 2 $node_id_out in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			// $Servers($server_name).s_new([$module[0], $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

			switch ($action)
		{
			case "before_out":
			 // @set_osc_handling_tab(1) ///SuperCollider a diferencia de antescofo/sclang
				$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))  //target 2 justo despues del nodo 180 audioOut
				// print titititi (""+[$module[0], $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in, $params])
				// print params (""+$params)
				case "after":
				// $mod_after_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module[0], $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
				case "before":
				// $mod_before_id := $synths_map($server_name)($group_name)($target_mod)[0] // recupera $mod_after id
				$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))		   		
				case "top":
				$Servers($server_name).s_new([$module[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in].concat($params))
			}			   	

			// $synths_map($server_name)($mix_group)($aux_name).insert($module[0], $node_id_mod)
			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($mix_group)($aux_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name).insert($module[0], [$node_id_mod])
			}else 
			{
				// print ($module[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name)($module[0]).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			// print este
			// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// scServer "s_new" ($module) $node_id_mod 2 $node_id_out in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			// $Servers($server_name).s_new([$module, $node_id_mod, 2, $node_id_out, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
			// $synths_map($server_name)($mix_group)($aux_name).insert($module, $node_id_mod)

			switch ($action)
		{
			case "before_out":
				$Servers($server_name).s_new([$module, $node_id_mod, 2, $target_mod, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])  //target 2 justo despues del nodo 180 audioOut
				case "after":
				$Servers($server_name).s_new([$module, $node_id_mod, 3, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
				case "before":
				$Servers($server_name).s_new([$module, $node_id_mod, 2, $target_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])		   		
				case "top":
				$Servers($server_name).s_new([$module, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in])
			}

			$sc_struct($server_name)($group_id).insert(@size($sc_struct($server_name)($group_id))-2, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus
				
			if(($synths_map($server_name)($mix_group)($aux_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				// print ($module) is not member at $node_id_mod
				// ($synths_map($server_name)($mix_group)($aux_name).insert($module, [$node_id_mod])).post()
				$synths_map($server_name)($mix_group)($aux_name).insert($module, [$node_id_mod])
			}else 
			{
				// print ($module) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name)($module).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
		
	}

	
	}

	@fun_def mod_add_top($module, $fade_in_mod = 0.1)
	{
		@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod

		// $fade_in_mod := 0 // deberia ser un argumento opcional!!
		// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
		// print modulos $module
	    // print groupo $group_id
	    // print node_id $node_id
	    // print size ($module.dim())
	    // print params $params
	    if ($module.dim() > 1){ // si c'est tab multi
	    // print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
			// print params $params
				// scServer "s_new" ($chain[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($aux_name).insert($chain[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($chain[0]).push_back($node_id_mod)

				}

				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}else{ 
			if($module.is_tab()) // si c'est tab 1 dim
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// print params $params
				// scServer "s_new" ($module[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($aux_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($module[0]).push_back($node_id_mod)

				}
				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}else{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new"($module) $node_id_mod 0 $group_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 0, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($aux_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($module).push_back($node_id_mod)

				}
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}


	@fun_def mod_add_botton($module, $fade_in_mod = 0.1)
	{
		@local $addmod_index := 0, $params, $fade_in_mod, $node_id_mod

	    if ($module.dim() > 1){ // si c'est tab multi
	    // print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
			// print params $params
				// scServer "s_new" ($chain[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($aux_name).insert($chain[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($chain[0]).push_back($node_id_mod)

				}

				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}else{ 
			if($module.is_tab()) // si c'est tab 1 dim
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// print params $params
				// scServer "s_new" ($module[0]) $node_id_mod 0 $group_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($aux_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($module[0]).push_back($node_id_mod)

				}
				loop // rajoute params au dico
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}else{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new"($module) $node_id_mod 0 $group_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 1, $group_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])

				// $synths_map($server_name)($mix_group)($aux_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert(-1, $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($module).push_back($node_id_mod)

				}
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
		}
	}

	@fun_def mod_after($module, $mod_after)
	{
		@local $addmod_index := 0, $params, $fade_in_mod, $mod_after_id, $node_id_mod

		$fade_in_mod := 1 // deberia ser un argumento opcional!!
		// $node_id_mod := $SC_Servers($server_name)("node_id") // last id

	    $mod_after_id := $synths_map($server_name)($mix_group)($aux_name)($mod_after)[0] // recupera $mod_after id

	    "post".post()
		$node_id_mod.post()
		$mod_after_id.post()
		"post".post()

	    if ($module.dim() > 1){ // si c'est tab multi
	    print MULTI_
		forall $chain in $module // s'il y a plus des modules
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// print $chain
			$params := $chain.cdr()
				// scServer "s_new" ($chain[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$chain[0], $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				// print params ($synths_map($server_name)($mix_group)($aux_name)($chain[0]))

				if(($synths_map($server_name)($mix_group)($aux_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($chain[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($chain[0], [$node_id_mod])
				}else 
				{
					// print ($chain[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($chain[0]).push_back($node_id_mod)

				}
			   
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
		}
		else
		{
			if($module.is_tab()) // si c'est tab 1 dim
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				$params := $module.cdr()
				// scServer "s_new" ($module[0]) $node_id_mod 3 $mod_after_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module[0], $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])
				// $synths_map($server_name)($mix_group)($aux_name).insert($module[0], $node_id_mod)
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module[0]) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($module[0], [$node_id_mod])
				}else 
				{
					// print ($module[0]) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($module[0]).push_back($node_id_mod)

				}
				loop 
				{
					$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
					$addmod_index := $addmod_index + 2
				} while ($addmod_index+2 <= @size($params))
				
				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

			}
			else
			{
				$node_id_mod := $SC_Servers($server_name)("node_id") // last id
				// scServer "s_new" ($module) $node_id_mod 3 $mod_after_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
				$Servers($server_name).s_new([$module, $node_id_mod, 3, $mod_after_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
				// $synths_map($server_name)($mix_group)($aux_name).insert($module, $node_id_mod)
				$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_after_id), $node_id_mod) // root tree 0
				$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
				$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

				if(($synths_map($server_name)($mix_group)($aux_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
				{
					// print ($module) is not member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name).insert($module, [$node_id_mod])
				}else 
				{
					// print ($module) is member at $node_id_mod
					$synths_map($server_name)($mix_group)($aux_name)($module).push_back($node_id_mod)

				}

				$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
			}
				
		}
	}

	@fun_def mod_before($module, $mod_before)
	{
	@local $addmod_index := 0, $params, $fade_in_mod, $mod_before_id, $node_id_mod
	$fade_in_mod := 1 // deberia ser un argumento opcional!!
	// $node_id_mod := $SC_Servers($server_name)("node_id") // last id
    $mod_before_id := $synths_map($server_name)($mix_group)($aux_name)($mod_before)[0] // recupera $mod_after id
    // print (""+$synths_map($server_name)($mix_group)($aux_name))
    // print size ($module.dim())
    // print params $params
    if ($module.dim() > 1){ // si c'est tab multi
    // print MULTI_
	forall $chain in $module // s'il y a plus des modules
	{
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		// print $chain
		$params := $chain.cdr()
			// scServer "s_new" ($chain[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$chain[0], $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $chain[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			// print params ($synths_map($server_name)($mix_group)($aux_name)($chain[0]))

			if(($synths_map($server_name)($mix_group)($aux_name)($chain[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($chain[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name).insert($chain[0], [$node_id_mod])
			}else 
			{
				print ($chain[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name)($chain[0]).push_back($node_id_mod)

			}
		   
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
	}
	else
	{
		if($module.is_tab()) // si c'est tab 1 dim
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			$params := $module.cdr()
			// scServer "s_new" ($module[0]) $node_id_mod 2 $mod_before_id in $bus out $bus $params matrix_ramp $fade_in_mod  //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$module[0], $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, $params, "matrix_ramp", $fade_in_mod])
			// $synths_map($server_name)($mix_group)($aux_name).insert($module[0], $node_id_mod)
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module[0]), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus

			if(($synths_map($server_name)($mix_group)($aux_name)($module[0])).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($module[0]) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name).insert($module[0], [$node_id_mod])
			}else 
			{
				print ($module[0]) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name)($module[0]).push_back($node_id_mod)

			}
			loop 
			{
				$sc_struct($server_name)($node_id_mod).add_pair($params[$addmod_index], $params[$addmod_index+1])
				$addmod_index := $addmod_index + 2
			} while ($addmod_index+2 <= @size($params))
			
			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)

		}
		else
		{
			$node_id_mod := $SC_Servers($server_name)("node_id") // last id
			// scServer "s_new"($module) $node_id_mod 2 $mod_before_id in $bus out $bus matrix_ramp $fade_in_mod //$params   //target 2 justo despues del nodo 180 audioOut
			$Servers($server_name).s_new([$module, $node_id_mod, 2, $mod_before_id, "in", $bus, "out", $bus, "matrix_ramp", $fade_in_mod])
			// $synths_map($server_name)($mix_group)($aux_name).insert($module, $node_id_mod)
			$sc_struct($server_name)($group_id).insert($sc_struct($server_name)($group_id).occurs($mod_before_id)-1, $node_id_mod) // root tree 0
			$sc_struct($server_name).add_pair($node_id_mod, map{("_synth", $module), ("in", $bus), ("out", $bus)}) // crea MAP para nombre_synth + parametros
			$track_proc($server_name)($mix_group)($aux_name).insert($node_id_mod, map{}) // dictionaire pour les processus
			
			if(($synths_map($server_name)($mix_group)($aux_name)($module)).is_undef()) // si la synth existe déjà creer une tab de nodes
			{
				print ($module) is not member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name).insert($module, [$node_id_mod]) // tab dans le cas de plusieurs instances du même module
			}else 
			{
				print ($module) is member at $node_id_mod
				$synths_map($server_name)($mix_group)($aux_name)($module).push_back($node_id_mod)

			}

			$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
		}
			
	}
	}


	@proc_def mod_remove($module, $time_off = 0.1)
	{
		print remove (""+($synths_map($server_name)($mix_group)($aux_name)($module)))
		forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
		{			
			// scServer "n_set" $node matrix_ramp $time_off free 0
			$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])
			$sc_struct($server_name).remove($node)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
			if($track_proc($server_name)($mix_group)($aux_name)($node).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($node) // parcours le dico de proc
				{
					abort $proc 
				}
			}
			// ($time_off+0.01) $track_proc($server_name)($mix_group)($aux_name).remove($node)
		}
		_ := $synths_map($server_name)($mix_group)($aux_name).remove($module)
	}

	@proc_def mod_remove_id($nodes, $time_off = 0.1)
	{
		if($nodes.is_tab())
		{
			forall $x in $nodes
			{
				// scServer "n_set" $x matrix_ramp $time_off free 0
				$Servers($server_name).n_set($x, ["matrix_ramp", $time_off, "free", 0])
				_ := $synths_map($server_name)($mix_group)($aux_name).remove($sc_struct($server_name)($group_id)($x)("_synth"))
				$sc_struct($server_name)($server_name).remove($x)
				_ := $sc_struct($server_name)($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($x))
				if($track_proc($server_name)($mix_group)($aux_name)($x).size() != 0) // abort proc des modules
				{	
					$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($x) // parcours le dico de proc
					{
						abort $proc 
					}
				}	
			}
		}
		else
		{
			// scServer "n_set" $nodes matrix_ramp $time_off free 0
			$Servers($server_name).n_set($nodes, ["matrix_ramp", $time_off, "free", 0])
			_ := $synths_map($server_name)($mix_group)($aux_name).remove($sc_struct($server_name)($group_id)($nodes)("_synth"))
			$sc_struct($server_name).remove($nodes)
			$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($nodes))
			if($track_proc($server_name)($mix_group)($aux_name)($nodes).size() != 0) // abort proc des modules
			{	
				$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($nodes) // parcours le dico de proc
				{
					abort $proc 
				}
			}
		}	
	}

	@proc_def mod_remove_single($module, $num, $time_off = 0.1) // quand il y a plusieurs instances d'un même module, sinon utiliser la methode mod_remove
	{
		@local $node
		$node := $synths_map($server_name)($mix_group)($aux_name)($module)[$num]
		// scServer "n_set" $node matrix_ramp $time_off free 0
		$Servers($server_name).n_set($node, ["matrix_ramp", $time_off, "free", 0])

		$sc_struct($server_name).remove($node)
		$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		_ := $synths_map($server_name)($mix_group)($aux_name)($module).remove($synths_map($server_name)($mix_group)($aux_name)($module).occurs($node))
		
		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($node) // parcours le dico de proc
		{
			abort $proc 
		}
	_ := $synths_map($server_name)($mix_group)($aux_name).remove($node)	
	}

	@fun_def mod_replace($module_old, $module_new, $cross_fade = 1)
	{
		$THISOBJ.mod_remove($module_old, $cross_fade)
		$THISOBJ.mod_add($module_new, fade_in = $cross_fade)
	}

	@proc_def mod_move_before($module, $mod_mov_before)
	{
		// n_before ($synths_map($server_name)($mix_group)($aux_name)($module)) ($synths_map($server_name)($mix_group)($aux_name)($mod_mov_before)[0])

		print n_before ($synths_map($server_name)($mix_group)($aux_name)($module)) ($synths_map($server_name)($mix_group)($aux_name)($mod_mov_before)[0])

		// scServer "n_before" ($synths_map($server_name)($mix_group)($aux_name)($module)) ($synths_map($server_name)($mix_group)($aux_name)($mod_mov_before)[0])

		$Servers($server_name).n_before([$synths_map($server_name)($mix_group)($aux_name)($module), $synths_map($server_name)($mix_group)($aux_name)($mod_mov_before)[0]])


		// forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($aux_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($aux_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($aux_name).remove($module)
	}

	@proc_def mod_move_before_id($module_id, $mod_mov_before_id)
	{
		n_before $module_id $mod_mov_before_id

		print n_before $module_id $mod_mov_before_id

		// scServer "n_before" $module_id $mod_mov_before_id
		$Servers($server_name).n_before([$module_id, $mod_mov_before_id])


		// forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($aux_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($aux_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($aux_name).remove($module)
	}

	@proc_def mod_move_after($module, $mod_mov_after)
	{
		// n_after ($synths_map($server_name)($mix_group)($aux_name)($module)) ($synths_map($server_name)($mix_group)($aux_name)($mod_mov_after)[0])

		print n_after ($synths_map($server_name)($mix_group)($aux_name)($module)) ($synths_map($server_name)($mix_group)($aux_name)($mod_mov_after)[0])

		// scServer "n_after" ($synths_map($server_name)($mix_group)($aux_name)($module)) ($synths_map($server_name)($mix_group)($aux_name)($mod_mov_after)[0])
		$Servers($server_name).n_after([$synths_map($server_name)($mix_group)($aux_name)($module), $synths_map($server_name)($mix_group)($aux_name)($mod_mov_after)[0]])


		// forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($aux_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($aux_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($aux_name).remove($module)
	}

	@proc_def mod_move_after_id($module_id, $mod_mov_after_id)
	{
		// n_after $module_id $mod_mov_after_id

		print n_after $module_id $mod_mov_after_id

		// scServer "n_after" $module_id $mod_mov_after_id

		$Servers($server_name).n_after([$module_id, $mod_mov_after_id])

		// forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
		// {
		// 	scServer "n_set" $node matrix_ramp $time_off free 0
		// 	$sc_struct($server_name).remove($node)
		// 	$sc_struct($server_name)($group_id).remove($sc_struct($server_name)($group_id).occurs($node))
		// 	if($track_proc($server_name)($mix_group)($aux_name)($node).size != 0) // abort proc des modules
		// 	{	
		// 		$time_off forall $k, $proc in $track_proc($server_name)($mix_group)($aux_name)($node) // parcours le dico de proc
		// 		{
		// 			abort $proc 
		// 		}
		// 	}
		// 	// ($time_off+0.01) $track_proc($server_name)($mix_group)($aux_name).remove($node)
		// }
		// $synths_map($server_name)($mix_group)($aux_name).remove($module)
	}

	@proc_def connect($track, $amp = 0, $fade_in = 1)
	{
		@local $id, $target_id, $track_bus_out // , $bus_aux_in
		$id := $SC_Servers($server_name)("node_id")
		$target_id := $SC_Groups($mix_group)("sub_group")($track).$node_id_out
		$track_bus_out := $SC_Groups($mix_group)("sub_group")($track).$bus
		print connect_all (""+$SC_Groups($mix_group)("sub_group"))
		// $bus_aux_in := $bus
		if($aux_track_map.is_defined($track))
		{
			print "this track is already connceted"
		}
		else
		{ 
			$aux_track_map.add_pair($track, $id)
			$Servers($server_name).s_new(["AudioInAux2", $id, 3, $target_id, "in", $track_bus_out, "out", $bus, "in_ramp", $fade_in, "amp", $amp])
			$SC_Servers($server_name).add_pair("node_id", $id + 1)			
		}
	}

	@proc_def disconnect($track, $fade_out = 0.1)
	{
		if($track=="all")
		{
			forall $k, $n_id in $aux_track_map
			{
				// print nodes_ids $n_id
				$Servers($server_name).n_set($n_id, ["out_ramp", @dur2sec($fade_out), "gatee", 0])
				$aux_track_map.remove($k)
			}
		}
		else
		{
			$Servers($server_name).n_set($aux_track_map($track), ["out_ramp", @dur2sec($fade_out), "gatee", 0])
			$aux_track_map.remove($track)
		}
	}	

	@fun_def source_pol_traj($duree, $radio, $theta, $start_pos, $end_pos, $period, $type, $loop = 0, $dir = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($aux_name).is_defined("source_lin_traj")) // si ça existe abort et refait
	{
		print abort_rand
		abort $track_proc($server_name)($mix_group)($aux_name)("source_lin_traj") 
	}
		$track_proc($server_name)($mix_group)($aux_name).add_pair("source_lin_traj", ::source_pol_traj($server_name, $node_id_out, $mix_group, $dir, $duree, $radio, $theta, $start_pos, $end_pos, $period, $type, $loop)) // instantie un le processus dans le dico
	}

	@fun_def source_elevation_traj($duree, $radio, $phi, $start_pos, $end_pos, $period, $type, $loop = 0, $dir = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($aux_name).is_defined("source_lin_traj")) // si ça existe abort et refait
	{
		print abort_rand
		abort $track_proc($server_name)($mix_group)($aux_name)("source_lin_traj") 
	}
		$track_proc($server_name)($mix_group)($aux_name).add_pair("source_lin_traj", ::source_elevation_traj($server_name, $node_id_out, $mix_group, $dir, $duree, $radio, $phi, $start_pos, $end_pos, $period, $type, $loop)) // instantie un le processus dans le dico
	}

	@fun_def source_comete($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $loop = 0, $dir = 1) 
	{ 
		if($track_proc($server_name)($mix_group)($aux_name).is_defined("source_lin_traj")) // si ça existe abort et refait
	{
		print abort_rand
		abort $track_proc($server_name)($mix_group)($aux_name)("source_lin_traj") 
	}
		$track_proc($server_name)($mix_group)($aux_name).add_pair("source_lin_traj", ::source_comete($server_name, $node_id_out, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id)) // instantie un le processus dans le dico
	}


	@fun_def set($module, $params)
	{
		// print scServer "n_set" $module $params
		// print scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module)) $params

		forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module))
		{
			// scServer "n_set" $x $params
			$Servers($server_name).n_set($x, $params)
		}
		// scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module)) 
		// $sc_struct($server_name)($synths_map($server_name)($mix_group)($aux_name)($module))("modfreq") := 100
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($aux_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($aux_name)($module)))
	}

	@fun_def set_multi($module, $params)
	{
		forall $x in $params
		{
			print (""+$params)
		}
		// forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)).size
		// {
		// 	scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module))[$x]
		// }
	}

	@fun_def set_single ($module, $num, $params)
	{
		// scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module)[$num]) $params
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($aux_name)($module)[$num], $params)
	}

	@fun_def preset($module, $preset)
	{
		@local $json_file, $params, $i := 0, $node_id
		$node_id := ($synths_map($server_name)($mix_group)($aux_name)($module))
		 // @set_osc_handling_tab(true) ///SuperCollider a diferencia de antescofo/sclang

		// print prestsss
		// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

						// $home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$mod_name+".json"
		// print ($json_file.post())

		$params := $json_file($module)($preset).map2tab() // recupere les donnees du present json
		// print params (""+$params)
		forall $id in $node_id // pour toute les instances du Module
		{
			loop
			{
				// print (""+[$params[$i], $params[$i+1]])
				// print toto
				if(($params[$i+1].is_tab()))
				{
					// scServer "n_setn" $id ($params[$i]) @size($params[$i+1]) ($params[$i+1]) // if tab
					$Servers($server_name).n_setn($id, [$params[$i], @size($params[$i+1]), $params[$i+1]]) // if tab
				}else{
					// scServer "n_set" $id ($params[$i]) ($params[$i+1])
					$Servers($server_name).n_set($id, [$params[$i], $params[$i+1]].flatten())
				}

				// print ($synths_map($server_name)($mix_group)($aux_name)($module)) ($params[$i]) ($params[$i+1])
				$i := $i + 2
			} while ($i < @size($params))
		}


		// forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // pour toute les instances du Module
		// {
		// 	// scServer "n_set" $x $params
		// 	print toto $x (""+$params)
		// 	s_server $x $params
		// }
		// @set_osc_handling_tab(false) ///SuperCollider a diferencia de antescofo/sclang

	}

	@fun_def preset_single($module, $num, $preset)
	{
		@local $json_file, $params
		print prestsss
		// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")


		$params := $json_file($module)($preset).map2tab() // recupere les donnees du present json
		print (""+$params)
		// scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module)[$num]) $params
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($aux_name)($module)[$num], $params)


	}

	@proc_def preset_interpol($module, $preset1, $preset2, $dur)
	{
		@local $json_file, $params, $params1, $params2, $nim, $val //, $id
		// print prestsss
		// $nim := @build_nim_from_bpf($bpf)
		// $id := ($synths_map($server_name)($mix_group)($aux_name)($module))

		
		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		// $json_file := @json_read("~/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")


		// $params1 := $json_file($module)($preset1).map2tab // recupere les donnees du present json
		// $params2 := $json_file($module)($preset2).map2tab // recupere les donnees du present json

		$params := $json_file($module)($preset2).domain() // recupere les keys des presets

		$preset1 := $json_file($module)($preset1).range() // recupere les donnees du present json
		$preset2 := $json_file($module)($preset2).range() // recupere les donnees du present json

		
	   Curve 	@Grain := 0.01,
			@Action {
					forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
					{
						// scServer "n_set" $node ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2))
						print $node (""+([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2)))
					}
				} 
	   { $val 	{            
					{0} 
			 $dur  	{1}
			} 
	   }

	   // Curve   @Grain := 0.01,  
	   //         @Action {

	   //             scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2))
	   //         }            
	   //         { $val : $nim }

	}

	@proc_def preset_interpol_tab($module, $presets_durs_tab)
	{
		@local $dur, $json_file, $params, $preset1, $preset2, $nim, $inc := 0, $curve := 0, $type := "linear" //, $id
		// print prestsss
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

		$params := $json_file($module)($presets_durs_tab[0]).domain() // recupere les keys des presets

		// $preset1 := $presets_durs_tab[$inc]
		// $preset2 := $presets_durs_tab[$inc+2]
		$dur := $presets_durs_tab[$inc+1]

		$preset2 := $json_file($module)($presets_durs_tab[$inc]).range() // recupere les donnees du present json
		// $preset2 := $json_file($module)($preset2).range // recupere les donnees du present json

		// print preset1_1 $preset2
		// // print preset2_1 $preset2
		// print params_1 $params
		// print inc_1 $inc
		print dur_1 $dur

		$inc := $inc + 1 // start from dur

		Loop $dur
		{	
			@local $val
			print durloop $dur
			$preset1 := $preset2 
			// if($inc <= @size($presets_durs_tab)-2)
			// {
				if ($presets_durs_tab[$inc+2].is_string())
			    {
				   $type := $presets_durs_tab[$inc+1]
				   // $preset2 := 
				   $preset2 := $json_file($module)($presets_durs_tab[$inc+2]).range() // recupere les donnees du present json
				   $dur := $presets_durs_tab[$inc]

				   $inc := $inc + 3;
			    }
			    else
			    {
				   $type := "linear"
				   // $preset2 := 
				   $preset2 := $json_file($module)($presets_durs_tab[$inc+1]).range() // recupere les donnees du present json
				   $dur := $presets_durs_tab[$inc]
				   $inc := $inc + 2;
			    }
			// }
		  //   	print preset1 $preset1
				// print preset2 $preset2
				// print params $params
				// print inc $inc


			abort $curve
		   $curve := {

		   Curve 	@Grain := 0.01,
					@Action {
						
							forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
							{
								// scServer "n_set" $node ([$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size()*2))
								$Servers($server_name).n_set($node , [$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size()*2))

								// print $node ([$params, ($preset2*$val)+($preset1*(1-$val))].lace($params.size*2))
							}
						} 
					{ $val 	{            
							{0} @type $type
					 $dur  	{1}
					} 
			  }
		   }
	

	}while ($inc < @size($presets_durs_tab)) //($inc < (@size($presets_durs_tab)-2))
	}

	// preset_interpol_tab("TestSynth3", ["preset1", 3, "", "preset2", 2, "preset3", 3.4, "preset4"])

	@proc_def preset_interpol_bpf($module, $preset1, $preset2, $bpf)
	{
		@local $json_file, $params, $params1, $params2, $nim, $val, $id
		// print prestsss
		$nim := @build_nim_from_bpf($bpf)
		$id := ($synths_map($server_name)($mix_group)($aux_name)($module))

		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")

		
		$params1 := $json_file($module)($preset1).map2tab() // recupere les donnees du present json
		$params2 := $json_file($module)($preset2).map2tab() // recupere les donnees du present json

		$params := $json_file($module)($preset2).domain() // recupere les keys des presets

		$preset1 := $json_file($module)($preset1).range() // recupere les duonnees du present json
		$preset2 := $json_file($module)($preset2).range() // recupere les donnees du present json

		// $params := $json_file($module)($preset).map2tab // recupere les donnees du present json
		// print $params1
		// print $params2
		// print $params
		// print $preset1
		// print $preset2

		print ([$params, $preset2].lace($params.size()*2))
		

	   Curve   @Grain := 0.01,  
			 @Action 
			 {
				// scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))  
				$Servers($server_name).n_set($id, [$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size()*2))             
			 }          

			 { $val : $nim }

	}

	@proc_def preset_interpol_vector($module, $preset_list) // interpol par boule
	{
		@local $json_file, $params, $params_name, $params1, $params2, $nim, $val, $id, $result, $temp
		// print prestsss
		$params := []
		// $nim := @build_nim_from_bpf($bpf)
		$id := ($synths_map($server_name)($mix_group)($aux_name)($module))


		// $json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$json_file := @json_read($home + "/Library/Application\ Support/SuperCollider/TSupport/fxPresets/"+$module+".json")
		$params_name := $json_file($module)($preset_list[0]).domain() // recupere les keys des presets


		forall $prst in $preset_list
		{
			// $temp := $json_file($module)($prst).map2tab
			// $temp := 
			$params.push_back($json_file($module)($prst).range())
		}

		whenever ($from_nodes == $from_nodes) // from_nodes viene de Max gmm static posture recognition 
		{
			if (@size($from_nodes) != @size($params))
			{
				print ERROR SIZE
				print $from_nodes
			}
			else
			{
				$result := $from_nodes * $params
				// interpol @reduce(@+, $result)
				// print from_nodes $from_nodes
				// print params (""+$params)
				print params_name (""+$params_name)	
				// print json_file (""+$json_file)
				print result (""+@reduce(@+, $result))
				print (""+([$params_name, @reduce(@+, $result)].lace($params_name.size()*2)))

				// scServer "n_set" $id ([$params_name, @reduce(@+, $result)].lace($params.size()*2))
				$Servers($server_name).n_set($id, [$params_name, @reduce(@+, $result)].lace($params.size()*2))
			}
		}

		// $params1 := $json_file($module)($prst).map2tab // recupere les donnees du present json
		// $params2 := $json_file($module)($preset2).map2tab // recupere les donnees du present json

		// $params := $json_file($module)($preset2).domain // recupere les keys des presets

		// $preset1 := $json_file($module)($preset1).range // recupere les duonnees du present json
		// $preset2 := $json_file($module)($preset2).range // recupere les donnees du present json

		// print ([$params, $preset2].lace($params.size*2))
		

	   // Curve   @Grain := 0.01,  
	   //         @Action 
	   //         {
	   //             scServer "n_set" $id ([$params, ($preset1*$val)+($preset2*(1-$val))].lace($params.size*2))                    
	   //         }          

	   //         { $val : $nim }

	}


	// @fun_def amp($group_amp)
	// {
	// 		// {msg[2] == \amp} {~synth[msg[1]].outsynth.set(\amp, msg[3])}
	// 	// scServer "n_set" $node_id_out amp $group_amp
	// 	$Servers($server_name).n_set($node_id_out, ["amp", $group_amp])
	// }
	// @proc_def amp($amp)
	// {
	// 	@local $nim, $lamp
	// 	abort $last_bpf_amp_curve // to avoid interferences

	// 	if($amp.is_tab()) // if $val is bpf
	// 	{
	// 		$nim := @build_nim_from_bpf($amp)
	// 		// .CheckParam($module, $param, $MYSELF)
	// 		$lamp := $amp[0]
	// 		$last_bpf_amp_curve := { curve @grain := 0.01, 
	// 			@action 
	// 			{
	// 				$Servers($server_name).n_set($node_id_out, ["amp", $lamp])	
	// 			} 
	// 			{ $lamp : $nim }
	// 		}
	// 	}
	// 	else
	// 	{
	// 		$Servers($server_name).n_set($node_id_out, ["amp", $amp])
	// 	}
	// }

	@proc_def amp($amp)
	{
		@local $nim, $lamp, $last_bpf_amp_curve

		if($track_proc($server_name)($mix_group).is_defined("amp"))
		{
			abort $track_proc($server_name)($mix_group)("amp") // to avoid interferences
		}		
		// abort $last_bpf_amp_curve // to avoid interferences

		if($amp.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($amp)
			// .CheckParam($module, $param, $MYSELF)
			$lamp := $amp[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					$Servers($server_name).n_set($node_id_out, ["amp", $lamp])	
				} 
				{ $lamp : $nim }
			}
		$track_proc($server_name)($mix_group).add_pair("amp", $last_bpf_amp_curve) // store curve in map to avoid interference between different groups
		}
		else
		{
			$Servers($server_name).n_set($node_id_out, ["amp", $amp])
		}
	}

	// @fun_def HOABeamDirac2Hoa() // add BeamDirac2Hoa HOA FILTER
	// {
	// 	@local $node_id_mod

	// 	$node_id_mod := $SC_Servers($server_name)("node_id") // last id

	// 	scServer "s_new" ("HOA_Filter_HOABeamDirac2Hoa"+$order) $node_id_mod 3 $node_id_out in $bus out $bus

	// 	$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1) // increment node_i
	// }


	@fun_def ambi_xyz($pos_xyz)
	{
		// scServer "n_set" $node_id_out x ($pos_xyz[0]) y ($pos_xyz[1]) z ($pos_xyz[2])
		$Servers($server_name).n_set($node_id_out, ["x", ($pos_xyz[0]), "y", ($pos_xyz[1]), "z", ($pos_xyz[2])])
	}

	@fun_def ambi_x($pos_x)
	{
		// scServer "n_set" $node_id_out x $pos_x
		$Servers($server_name).n_set($node_id_out,  ["x", $pos_x])
		// print ("n_set"+$server_name) $node_id_out x $pos_x
	}

	@fun_def ambi_y($pos_y)
	{
		// scServer "n_set" $node_id_out y $pos_y
		$Servers($server_name).n_set($node_id_out,  ["y", $pos_y])
		// print ("n_set"+$server_name) $node_id_out y $pos_y
	}
		
	@fun_def ambi_z($pos_z)
	{
		// scServer "n_set" $node_id_out z $pos_z
		$Servers($server_name).n_set($node_id_out,  ["z", $pos_z])
		// print ("n_set"+$server_name) $node_id_out z $pos_z
	}

	@fun_def pitch($pitch)
	{
		// scServer "n_set" $node_id_out pitch @ang2rad($pitch)
		$Servers($server_name).n_set($node_id_out,  ["pitch", @ang2rad($pitch)])
		// print ("n_set"+$server_name) $node_id_out x $pos_x
	}

	@fun_def roll($roll)
	{
		// scServer "n_set" $node_id_out roll @ang2rad($roll)
		$Servers($server_name).n_set($node_id_out, ["roll", @ang2rad($roll)])
		// print ("n_set"+$server_name) $node_id_out y $pos_y
	}
		
	@fun_def yaw($yaw)
	{
		// scServer "n_set" $node_id_out yaw @ang2rad($yaw)
		$Servers($server_name).n_set($node_id_out, ["yaw", @ang2rad($yaw)])


		// print ("n_set"+$server_name) $node_id_out z $pos_z
	}

	@fun_def doppler($dop)
	{
		// scServer "n_set" $node_id_out dopon $dop
		$Servers($server_name).n_set($node_id_out, ["dopon", $dop])
	}

	@fun_def doppler_lev($dop_lev)
	{
		// scServer "n_set" $node_id_out dopamnt $dop_lev
		$Servers($server_name).n_set($node_id_out, ["dopamnt", $dop_lev])
	}

	/// HOA TRANSFORM

	@fun_def HOA_mirror($front_back = 1, $left_right = 1, $up_down = 0)
	{
		@local $mirror_node
		$mirror_node := $SC_Servers($server_name)("node_id") // last id

		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$Servers($server_name).s_new(["HOA_Global_Mirror_ord"+$order, $mirror_node, 1, $group_id, "in", $hoa_bus, "out", $hoa_bus, "front_back", $front_back, "left_right", $left_right, "up_down", $up_down])
		
		$SC_Servers($server_name).add_pair("node_id", $mirror_node + 1) // increment node_i

	}  	

	@fun_def HOA_mirror_front_back($front_back)
	{
		$Servers($server_name).n_set($mirror_node, ["front_back", $front_back])
	}

	@fun_def HOA_mirror_left_right($left_right)
	{
		$Servers($server_name).n_set($mirror_node, ["left_right", $left_right])
	}

	@fun_def HOA_mirror_up_down($up_down)
	{
		$Servers($server_name).n_set($mirror_node, ["up_down", $up_down])
	}

	@fun_def HOA_mirror_free($fade_out)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_remove($mirror_node, $fade_out)		
	}


	@fun_def HOA_az_rotator($az)
	{
		@local $az_rotator
		$az_rotator := $SC_Servers($server_name)("node_id") // last id

		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$Servers($server_name).s_new(["HOA_Global_Rot_azi_ord"+$order, $az_rotator, 1, $group_id, "in", $hoa_bus, "out", $hoa_bus, "az", @ang2rad($az)])
		
		$SC_Servers($server_name).add_pair("node_id", $az_rotator + 1) // increment node_i
	}

	@fun_def HOA_az_rotator_AZ($az)
	{
		$Servers($server_name).n_set($az_rotator, ["az", @ang2rad($az)])
	}

	@fun_def HOA_az_rotator_AZ_free($fade_out)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_remove($az_rotator, $fade_out)		
	}

	@fun_def HOA_xyz_rotator()
	{
		// @local $xyz_rotator
		$xyz_rotator := $SC_Servers($server_name)("node_id") // last id

		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$Servers($server_name).s_new(["HOA_Global_Rot_xyz_ord"+$order, $xyz_rotator, 1, $group_id, "in", $hoa_bus, "out", $hoa_bus])

		$SC_Servers($server_name).add_pair("node_id", $xyz_rotator + 1) // increment node_i
	}

	@fun_def HOA_xyz_rotator_pitch($pitch)
	{
		$Servers($server_name).n_set($xyz_rotator, ["pitch", @ang2rad($pitch)])
	}

	@fun_def HOA_xyz_rotator_roll($roll)
	{
		$Servers($server_name).n_set($xyz_rotator, ["roll", @ang2rad($roll)])
	}

	@fun_def HOA_xyz_rotator_yaw($yaw)
	{
		$Servers($server_name).n_set($xyz_rotator, ["yaw", @ang2rad($yaw)])
	}

	@fun_def HOA_xyz_rotator_pitchrollyaw($pitch, $roll, $yaw)
	{
		$Servers($server_name).n_set($xyz_rotator, ["pitch", @ang2rad($pitch), "roll", @ang2rad($roll), "yaw", @ang2rad($yaw)])
	}	

	@fun_def HOA_xyz_rotator_free($fade_out)
	{
		// $THISOBJ.mod_add(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "out", $channel], "top")
		$THISOBJ.mod_remove($xyz_rotator, $fade_out)		
	}

// ::ambi_orbit($track_id, $angle, $grain)

	// $proc_rand_theta := $sc_track_hoa1.ambi_rand_lfo_sphere($radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period) 
	
	@fun_def ambi_orbit($angle, $grain) 
	{ 
		// forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // parcours la liste de node de la même synth
		// {
			if($track_proc($server_name)($mix_group)($aux_name).is_defined($node_id_out+"_rambi_orbit")) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($aux_name)($node_id_out+"_rambi_orbit") 
		}
			// ::ambi_orbit($server_name, $node_id_out, $node_id_out, $angle, $grain)
			$track_proc($server_name)($mix_group)($aux_name).add_pair(($node_id_out+"_rambi_orbit"), ::ambi_orbit($server_name, $node_id_out, $angle, $grain)) // instantie un le processus dans le dico
			print track_proc (""+$track_proc($server_name)($mix_group))
		// }
	}

	@fun_def ambi_rand_lfo_sphere2($radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id = 0, $host = "192.168.1.12", $port = 9999) 
	{ 
	    if($track_proc($server_name)($mix_group)($aux_name).is_defined("source_lin_traj")) // si ça existe abort et refait
	    {
		   print abort_rand
		   abort $track_proc($server_name)($mix_group)($aux_name)("source_lin_traj") 
	    }
	    $track_proc($server_name)($mix_group)($aux_name).add_pair("source_lin_traj", ::ambi_rand_lfo_sphere2($server_name, $node_id_out, $mix_group, $radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id, $host, $port)) // instantie un le processus dans le dico
	}

	@fun_def ambi_rand_lfo_sphere_abort() 
	{
		abort $track_proc($server_name)($mix_group)($aux_name)("source_lin_traj")
	}




	// hacer para todos los lfos



	@fun_def mod_kill($module, $fade_out) // kill module
	{
		// scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module)) matrix_ramp $fade_out free 0
		$Servers($server_name).n_set($synths_map($server_name)($mix_group)($aux_name)($module), ["matrix_ramp", $fade_out, "free", 0])
		//remove synth
		//$sc_struct($server_name)
		// print (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($aux_name)($module))("modfreq"))
		// print node_add_pair (""+$sc_struct($server_name)($synths_map($server_name)($mix_group)($aux_name)($module)))
	}

	@fun_def pause($time)
	{
		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 0
		$Servers($server_name).n_set($group_id, ["matrix_ramp", @dur2sec($time), "gate", 0])
		// @dur2sec($time) scServer "n_set" $group_id gate 0
	}

	@fun_def resume($time)
	{	
		// scServer "n_run" $group_id 1
		$Servers($server_name).n_run($group_id, 1)

		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 1
		$Servers($server_name).n_set($group_id, ["matrix_ramp", @dur2sec($time), "gate", 1])

		forall $x in $sc_struct($server_name)($group_id) //
		{
			// scServer "n_run" $x 1
			$Servers($server_name).n_run($x, 1)
		}	
	}


	@fun_def mod_size($module)
	{
		return (($synths_map($server_name)($mix_group)($aux_name)($module)).size())
	}

///// track

	@proc_def track_amp_bpf($bpf)  // [-6, 7.5, "circ", 3, 4.5, -118]
    {
		@local $nim, $lamp
		// abort $last_bpf_amp_curve //evita interferencias
		$nim := @build_nim_from_bpf($bpf)
		// print $nim
		$lamp := $bpf[0]
		$last_bpf_amp_curve := { curve @grain := 0.01, @action {
			// scServer "n_set" $node_id_out amp $lamp
			$Servers($server_name).n_set($node_id_out, ["amp", $lamp])
		} 
			{ $lamp : $nim }
	    }
	}

    @proc_def track_line_amp($lmin1, $lmax1, $dur1, $type) 
    {
	   @local $lamp
	// .CheckParam($module, $param, $MYSELF)
	   Curve
	   @grain := 0.01,
	   @action {
    //     		forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module))
				// {
				// 	scServer "n_set" $x $params
				// }
			// scServer "n_set" $node_id_out amp $lamp
			$Servers($server_name).n_set($node_id_out, ["amp", $lamp])

	   // print scServer "n_set" $node_id_out amp $lamp
	} 
	   { $lamp {            
				    {$lmin1} @type := $type
			 $dur1   {$lmax1}} 
	   }
    }

    // hacer para los otros lfos (sin,brown,etc)

    

   @fun_def rand_lfo_basic_s_track($param, $min, $max, $init_val, $type, $tpo)
	{ 
		if($track_proc($server_name)($mix_group)($aux_name).is_defined("rand_lfo")) // si ça existe abort et refait
	{
		print abort_rand_track
		abort $track_proc($server_name)($mix_group)($aux_name)("rand_lfo_basic_s_track") 
	}
		$track_proc($server_name)($mix_group)($aux_name).add_pair("rand_lfo_basic_s_track", ::rand_lfo_basic_s_track($server_name, $node_id_out, $param, $min, $max, $init_val, $type, $tpo)) // instantie un le processus dans le dico
	}




///// track


    @proc_def line_param($module, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
				{
					// scServer "n_set" $node $param $lparam1
					$Servers($server_name).n_set($node, ["param", $lparam1])
				}
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}} 
		  }

    }

    @proc_def line_param_single($module, $num, $param, $lmin1, $lmax1, $dur1) 
    {
		  @local $lparam1
	// .CheckParam($module, $param, $MYSELF)
		  Curve
		  @grain := 0.01,
		  @action 
		  {
				// scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module)[$num]) $param $lparam1
				$Servers($server_name).n_set($synths_map($server_name)($mix_group)($aux_name)($module)[$num], [$param, $lparam1])
			} 
		  { $lparam1 {            
					   {$lmin1} 
				$dur1   {$lmax1}}
		  }
    }

    @proc_def bpf_param($module, $param, $bpf) 
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			forall $node in ($synths_map($server_name)($mix_group)($aux_name)($module))
			{
				// scServer "n_set" $node $param $lpar 
				$Servers($server_name).n_set($node, [$param ,$lpar])
			}
		} 
		{ $lpar : $nim }
    }

    @proc_def bpf_param_single($module, $num, $param, $bpf) // seulement quand une un track a plusieurs instances du même module
    {
		@local $nim, $lpar
		$nim := @build_nim_from_bpf($bpf)
		// .CheckParam($module, $param, $MYSELF)
		// print $nim
		$lpar := $bpf[0]
		curve @grain := 0.01, 
		@action 
		{
			// scServer "n_set" ($synths_map($server_name)($mix_group)($aux_name)($module)[$num]) $param $lpar
			$Servers($server_name).n_set($synths_map($server_name)($mix_group)($aux_name)($module)[$num], [$param, $lpar])
		} 
		{ $lpar : $nim }
    }



	@fun_def sin_lfo($module, $param, $r_low, $r_hi, $t) 
    {
	forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($mix_group)($aux_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_sin
			abort $track_proc($server_name)($mix_group)($aux_name)($x)($module+$param) 
		} 
		   $track_proc($server_name)($mix_group)($aux_name)($x).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t))                	
	   }
	}

	@fun_def sin_lfo_single($module, $num, $param, $r_low, $r_hi, $t) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($aux_name)($module)[$num])

	if($track_proc($server_name)($mix_group)($aux_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($mix_group)($aux_name)($node_num)($module+$param) 
	} 
	   $track_proc($server_name)($mix_group)($aux_name)($node_num).insert(($module+$param), ::sin_lfo_proc_s($server_name, $group_id, $node_num, $param, $r_low, $r_hi, $t))                	
	}


//($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo)
	@fun_def brown_lfo($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // parcours la liste de node de la même synth
		{
		if($track_proc($server_name)($mix_group)($aux_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_brown
			abort $track_proc($server_name)($mix_group)($aux_name)($x)($module+$param) 
		} 
		   $track_proc($server_name)($mix_group)($aux_name)($x).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $x, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	   }
	}

	@fun_def brown_lfo_single($module, $num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
    {
	@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($aux_name)($module)[$num])

	if($track_proc($server_name)($mix_group)($aux_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_sin_s
		abort $track_proc($server_name)($mix_group)($aux_name)($module+$param) 
	} 
	   $track_proc($server_name)($mix_group)($aux_name)($node_num).insert(($module+$param), ::brown_lfo_proc_s($server_name, $group_id, $node_num, $param, $min, $max, $drunk_step, $init_val, $type, $tpo))                	
	}


	@fun_def rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo) 
	{ 
		forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($aux_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_rand
			abort $track_proc($server_name)($mix_group)($aux_name)($x)($module+$param) 
		}
			$track_proc($server_name)($mix_group)($aux_name)($x).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $x, $param, $min, $max, $init_val, $type, $tpo, $gui)) // instantie un le processus dans le dico

		}
	}


	@fun_def rand_lfo_single($module, $num, $param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($aux_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($aux_name)($module))
		if($track_proc($server_name)($mix_group)($aux_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($aux_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($aux_name)($node_num).add_pair(($module+$param), ::rand_lfo_basic_s($server_name, $group_id, $node_num, $param, $min, $max, $init_val, $type, $tpo))		
	}


	@fun_def tri_lfo($module, $param, $r_low, $r_hi, $t, $type1, $type2) 
	{ 
		forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($aux_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_lfo_tri
			abort $track_proc($server_name)($mix_group)($aux_name)($x)($module+$param) 
		}
			$track_proc($server_name)($mix_group)($aux_name)($x).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2)) // instantie un le processus dans le dico

		}
	}


	@fun_def tri_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $type1, $type2) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($aux_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($aux_name)($module))
		if($track_proc($server_name)($mix_group)($aux_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($aux_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($aux_name)($node_num).add_pair(($module+$param), ::lfo_tri_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $type1, $type2))		
	}



	@fun_def saw_lfo($module, $param, $r_low, $r_hi, $t, $dir, $type) 
	{ 
		forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // parcours la liste de node de la même synth
		{
			if($track_proc($server_name)($mix_group)($aux_name)($x).is_defined($module+$param)) // si ça existe abort et refait
		{
			print abort_lfo_tri
			abort $track_proc($server_name)($mix_group)($aux_name)($x)($module+$param) 
		}
			$track_proc($server_name)($mix_group)($aux_name)($x).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type)) // instantie un le processus dans le dico

		}
	}


	@fun_def saw_lfo_single($module, $num, $param, $r_low, $r_hi, $t, $dir, $type) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($aux_name)($module)[$num])
		// print modulo_id2 ($synths_map($server_name)($mix_group)($aux_name)($module))
		if($track_proc($server_name)($mix_group)($aux_name)($node_num).is_defined($module+$param)) // si ça existe abort et refait
	{
		print abort_rand_s
		abort $track_proc($server_name)($mix_group)($aux_name)($node_num)($module+$param) 
	}
		$track_proc($server_name)($mix_group)($aux_name)($node_num).add_pair(($module+$param), ::saw_lfo_proc_s($server_name, $group_id, $x, $param, $r_low, $r_hi, $t, $dir, $type))		
	}

	@fun_def lfo_abort($module, $param)
	{
		forall $x in ($synths_map($server_name)($mix_group)($aux_name)($module)) // parcours la liste de node de la même synth
		{
			abort $track_proc($server_name)($mix_group)($aux_name)($x)($module+$param) 
		}
	}

	@fun_def lfo_abort_single($module, $num, $param)
	{
		@local $node_num
		$node_num := ($synths_map($server_name)($mix_group)($aux_name)($module)[$num])

		abort $track_proc($server_name)($mix_group)($aux_name)($node_num)($module+$param) 
	}

///////// rythms prob

	@proc_def ryth_prob_rand($mod_params, $prob, $rmin, $rmax, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$aux_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				// print mod_params (""+$x)
				$node_params.push_back($synths_map($server_name)($mix_group)($aux_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($aux_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		// print node_params (""+$node_params)

		if($track_proc($server_name)($mix_group)($aux_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($aux_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($aux_name).add_pair($proc_name, ::ryth_prob_rand($server_name, $node_params, $prob, $rmin, $rmax, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($aux_name))
	}

	@proc_def ryth_prob($mod_params, $prob, $rit, $tpo)
	{
		@local $node_params := [], $proc_name := "prob"+$aux_name

		if($mod_params.dim()>1)
		{
			forall $x in $mod_params
			{
				// print mod_params (""+$x)
				$node_params.push_back($synths_map($server_name)($mix_group)($aux_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
			}
		}
		else
		{
				$node_params.push_back($synths_map($server_name)($mix_group)($aux_name)($mod_params.car()).concat($mod_params.cdr())) // reconstruit liste avec nodes_id			
		}
		print node_params_ryth_prob (""+$node_params)

		if($track_proc($server_name)($mix_group)($aux_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($aux_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($aux_name).add_pair($proc_name, ::ryth_prob($server_name, $node_params, $prob, $rit, $tpo))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($aux_name))
	}


	@proc_def change_prob($val)
	{
		@local $nim, $lpar, $proc_name := "prob"+$aux_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			// .CheckParam($module, $param, $MYSELF)
			// print $nim
			// [2000, 5, "exp", 20, 3, 3000, 10, "exp_out", 20]
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
				let ($track_proc($server_name)($mix_group)($aux_name)($proc_name)).$prob := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($aux_name)($proc_name)).$prob := $val

		}
	}

	@proc_def change_proc_tempo($val) 
	{
		@local $nim, $lpar, $proc_name := "prob"+$aux_name

		if($val.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($val)
			// .CheckParam($module, $param, $MYSELF)
			// print $nim
			// [2000, 5, "exp", 20, 3, 3000, 10, "exp_out", 20]
			$lpar := $val[0]
			curve @grain := 0.01, 
			@action 
			{
				let ($track_proc($server_name)($mix_group)($aux_name)($proc_name)).$tpo := $lpar
			} 
			{ $lpar : $nim }
		}
		else
		{
			let ($track_proc($server_name)($mix_group)($aux_name)($proc_name)).$tpo := $val

		}
	}

	@proc_def track_rand_lfo_global_send($proc_name, $rand_lfo_instance, $modules_params) // $modules_params -> module, params, min, max
	{
		@local $node_params := [] //, $proc_name := "toto"

		forall $x in $modules_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($aux_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		// print (""+$node_params)

		if($track_proc($server_name)($mix_group)($aux_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($aux_name)($proc_name) 
	}
		_ := $track_proc($server_name)($mix_group)($aux_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, $node_params))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($aux_name))
	}

	@broadcast track_rand_lfo_global_send_all($proc_name, $rand_lfo_instance, $modules_params) // $modules_params -> module, params, min, max
	{
		@local $node_params := [] //, $proc_name := "toto"
		
		forall $x in $modules_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($aux_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		// print (""+$node_params)

		if($track_proc($server_name)($mix_group)($aux_name).is_defined($proc_name)) // si ça existe abort et refait
	{
		// print abort_rand_s
		abort $track_proc($server_name)($mix_group)($aux_name)($proc_name) 
	}
		$track_proc($server_name)($mix_group)($aux_name).add_pair($proc_name, obj::rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, $node_params))		
		// print proc_map (""+$track_proc($server_name)($mix_group)($aux_name))
	}	

	@broadcast track_change_param_all($mod_params) //change pour toutes les instances de l'objet
	{
		@local $node_params := []
		
		forall $x in $mod_params // reconstruction de la liste avec Nodes_id
		{
			// print mod_params (""+$x)
			$node_params.push_back($synths_map($server_name)($mix_group)($aux_name)($x.car()).concat($x.cdr())) // reconstruit liste avec nodes_id
		}

		forall $y in $node_params // 
		{
			
			$Servers($server_name).n_set($node_params.car(), $node_params.cdr())		
		}		
		// $THISOBJ.change_param($module, $param, $lin) // change parametres pour toutes les objets play_Ingran_rand_paramA
		// $THISOBJ.change_tempo($lin_t)
	}

	@fun_def gui()
	{
		@local $addsynth := [], $tab_ids
		$tab_ids := $sc_struct($server_name)($group_id).drop(-1)
		$gui := true
		// TTracks8.new(aux_name.asString, nil, group, bus, outsynth);
		print $tab_ids

		forall $x in $tab_ids
		{
			// print (""+($sc_struct($server_name)($group_id)($x)))
			// print (""+($sc_struct($server_name)($x)))
			$addsynth.push_back($x)
			$addsynth.push_back($sc_struct($server_name)($x)("_synth"))
			// $addsynth.push_back($sc_struct($server_name)($group_id)($x))
		}
		gui_antes $server_name $aux_name $group_id $bus $node_id_out $addsynth

		// forall $k, $v in $track_proc($server_name)($mix_group)($aux_name) // active envoie OSC vers GUI
		// {
		// 	if($v.size > 0) // si la valeur contiens deja un proc avant creation GUI
		// 	{
		// 		$v.$gui := true // alors activer l'envoie par l'argument $gui (variable locale) 
		// 	}
		// }
	}



	// @proc_def ryth_prob($module, $param, $val, $prob, $tmpo) // @proc_def parce qu'il y a un delay pour arrter les proc
	// {
	// 	@local $noterest := 0, $node_id

	// 	$node_id := ($synths_map($server_name)($mix_group)($aux_name)($module))

	// 	loop $rit @tempo := $tmpo
	//                 {
 //                        $noterest := ((@rand(1.) < $prob)? 1: 0)
 //                        if ($noterest == 1)
 //                        {

 //                                // crea_track8 $track set 01_TGranInterpExt t_trig 1
 //                                scServer "n_set" $node_id $module $param $val
 //                                $t_trig := 1
 //                                // if($rand_spat_pos)
 //                                // {
 //                                //         crea_track8 $track set 02_TPan8 pos @choose($tpan_hp_tab)

 //                                // }
 //                        }
	//                     $rit := @rand_range($rmin, $rmax)
	//                 }
 //    }

	// @proc_def ryth_prob($module, $param, $val, $prob, $tmpo) // @proc_def parce qu'il y a un delay pour arrter les proc
	// {
	// 	@local $noterest := 0, $node_id

	// 	$node_id := ($synths_map($server_name)($mix_group)($aux_name)($module))

	// 	loop $rit @tempo := $tmpo
	//                 {
	//                         $noterest := ((@rand(1.) < $prob)? 1: 0)
	//                         if ($noterest == 1)
	//                         {

	//                                 // crea_track8 $track set 01_TGranInterpExt t_trig 1
	//                                 scServer "n_set" $node_id $module $param $val
	//                                 $t_trig := 1
	//                                 // if($rand_spat_pos)
	//                                 // {
	//                                 //         crea_track8 $track set 02_TPan8 pos @choose($tpan_hp_tab)
	
	//                                 // }
	//                         }
	//                 }
 //    }



	@fun_def play_sample($sample, $ampli, $loop)
	{
		$THISOBJ.mod_add_top(["TPlaybuf2", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop])
	}

	@fun_def play_sample_stop($sample, $fade_out) // hacer map con samplers tocados para stop
	{
		$THISOBJ.set("TPlaybuf2", ["matrix_ramp", $fade_out, "free", 0])
	}

	@fun_def play_sample16($sample, $ampli, $loop)
	{
		$THISOBJ.mod_add_top(["TPlaybuf16", "buf", $SF_map($server_name)($sample), "amp", $ampli, "loop", $loop])
	}	

	@fun_def play_sample16_stop($sample, $fade_out) // hacer map con samplers tocados para stop
	{
		$THISOBJ.set("TPlaybuf16", ["matrix_ramp", $fade_out, "free", 0])
	}

	@proc_def play_sample_gesture_pos_trig($list_samples) // interpol par boule
	{
		@local $last_val := 0
		whenever ($likelihood == $likelihood) // likelihood viene de Max gmm static posture recognition index
		{					               
				 if ($likelihood != $last_val) { //change dans Max
					$last_val := $likelihood
					print likelihood $likelihood
					// HOA_sample_xyz($buf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder) 
			  ::HOA_sample_xyz($SF_map($server_name)($list_samples[$likelihood-1]), 1, 1, 0, @rand_range(1, -1), @rand_range(1, -1), 0, 0, $mix_group)
				// $THISOBJ.mod_add_top(["TPlaybuf2", "buf", $SF_map($list_samples[$likelihood-1]), "amp", 0, "loop", 0])
		}
		}
	}

	@fun_def map_gesture($gest, $module, $param, $min, $max) // ($L_incli_lateral, "TMFxShift2", "modfreq", 1, 60)
	{
		$THISOBJ.set("TPlaybuf16", ["matrix_ramp", $fade_out, "free", 0])
	}


	@proc_def free($time) // @proc_def parce qu'il y a un delay pour arrter les proc
	{
		// print track_proc_integral (""+$track_proc)
		// scServer "n_set" $node_id_out out_ramp @dur2sec($time) gatee 0 // free group in $time
		$Servers($server_name).n_set($node_id_out, ["out_ramp", @dur2sec($time), "gatee", 0])


		// ("abort track "+ $THISOBJ).post()
		// ("server_name "+ $server_name).post()
		// ("mix_group "+ $mix_group).post()
		// ("aux_name "+ $aux_name).post()
		// ($track_proc($server_name)($mix_group)($aux_name)).post()
		if(($track_proc($server_name)($mix_group)($aux_name)).is_undef())
		{
			$track_proc($server_name)($mix_group).remove($aux_name) // delete track_proc from map
			$SC_Groups($mix_group)("sub_group").remove($aux_name) // delete sub_group objects

			
		}
		else
		{
						// $track_proc($server_name)($mix_group)($aux_name).add_pair(($index+"_rambi_orbit"), ::ambi_orbit($server_name, $index, $node_id_out, $angle, $grain)) // instantie un le processus dans le dico

			($time-0.01) forall $k, $v in $track_proc($server_name)($mix_group)($aux_name) // parcours liste de nodes
			{
				// print track_proc (""+$v)
				if($v.is_map()) // si map abort proc modules
				{
				forall $proc_name, $proc in $v // parcours liste de proc en route
					{
						// ("abort proc_name " + $proc_name).post()
						// ("abort proc " + $proc_name).post()
						abort $proc

					}
				}
				else // si proc solo proc de HOA (orbit, ...)
				{
					abort $v
				}
			}
			group  // free aux connections 
			{
				forall $k, $n_id in $aux_track_map
				{
					print nodes_ids $n_id
					$Servers($server_name).n_free($n_id)
				}
			}
			$track_proc($server_name)($mix_group).remove($aux_name) // delete track_proc from map
			$SC_Groups($mix_group)("sub_group").remove($aux_name) // delete sub_group objects
		}
		$sc_struct($server_name).remove($group_id) // enleve group key de la MAP $sc_struct 
		$synths_map($server_name)($mix_group).remove($aux_name) // delete synths_map from map
		$aux.remove($aux_name)
	}

	@abort
	{
	    $THISOBJ.free(0.01) // 
	 //    forall $k, $v in $track_proc($server_name)($aux_name) // abort processus
		// {
		// 	abort $v
		// }
	}
}

//// Groups of tracks for trajectories

@obj_def tracks_group($tracks_tab) //create objet/buffer with parameters
{
	@init 
    {
	    @local $tracks_map, $global_xyz_rand_lfo_proc := 0, $list_track, $tracks_xyz_list, $tracks_amp_list, $tracks_param_list, $global_xyz_rand_dist, $set_list_dist
	    $tracks_map := @tab2map($tracks_tab)
	}
/*	@proc_def amp($ampli)
	{
		@local $nim, $lamp, $last_bpf_amp_curve := 0, $amp_retrieve_list := $THISOBJ.retrieve_amp()
	
		abort $last_bpf_amp_curve // to avoid interferences
		print amp_retrieve_list $amp_retrieve_list
		if($ampli.is_tab()) // if $val is bpf
		{
			$nim := @build_nim_from_bpf($ampli)
			$lamp := $ampli[0]
			$last_bpf_amp_curve := { curve @grain := 0.01, 
				@action 
				{
					forall $i in $tracks_tab.size()
					{
						$tracks($tracks_tab[$i]).amp($amp_retrieve_list[$i]+$lamp)
					}
				} 
				{ $lamp : $nim }
				
			}
		}
		else
		{
			forall $t in $tracks_tab
			{
				$tracks($t).amp($amp_retrieve_list[$i]+$amp)
			}
		}
	}*/
	@fun_def size() 
	{
		return $tracks_tab.size()
	}		
	@fun_def amp($ampli) 
	{
		forall $t in $tracks_tab
		{
			$tracks($t).amp($ampli)
		}
	}	
	@fun_def amp_add($ampli) // relative amp
	{
		forall $t in $tracks_tab
		{
			$tracks($t).amp_add($ampli)
		}
	}	
	@fun_def set($module, $params) 
	{
		forall $t in $tracks_tab
		{
			$tracks($t).set($module, $params)
		}
	}
	@fun_def set_list($module, $param, $params_list) 
	{
		forall $i in $tracks_tab.size()
		{
			$tracks($tracks_tab[$i]).set($module, [$param, $params_list[$i]])
		}
	}	
	@proc_def set_list_interp($module, $param, $params_list0, $params_list1, $time, $type = "linear") 
	{
		curve  @grain := 0.01,  
		@action
		{ // interpolation
			$THISOBJ.set_list($module, $param, ($params_list1*$y)+($params_list0*(1-$y)))
		}
        {
        $y
            {
				 {0.} @type := $type
            $time {1.} 
            }
        }		
	}	
	
	@fun_def set_xyz($xyz_tab) // xyz for each track 
	{
		forall $i in $tracks_tab.size()
		{
			$tracks($tracks_tab[$i]).xyz($xyz_tab[$i])
		}
	}	
	@fun_def reset_xyz($xyz_reset = [0, 0, 0]) // xyz for all tracks
	{
		forall $t in $tracks_tab
		{
			$tracks($t).xyz($xyz_reset)
		}
	}	
	@fun_def HOA_global_track_xyz($xyz)
	{
		forall $t in $tracks_tab
		{
			$tracks($t).HOA_global_track_xyz($xyz)
		}
	}
	@proc_def global_xyz_rand_lfo($range, $tpo = 60, $type = "linear")
	{
		@local $xyz_retrieve_list := $THISOBJ.retrieve_xyz()

		forall $i in $tracks_tab.size() // create new $range list from last position (retrieve_xyz())
		{
			$range[2] := $xyz_retrieve_list[$i][0]
			$range[5] := $xyz_retrieve_list[$i][1]
			$range[8] := $xyz_retrieve_list[$i][2]
		}
		abort $global_xyz_rand_lfo_proc // if exist before abort to avoid interferences
		$global_xyz_rand_lfo_proc := ::global_xyz_rand_lfo($THISOBJ, $range, $tpo, $type)
		$list_track := $global_xyz_rand_lfo_proc.$tracks_list
	}
	@fun_def global_xyz_rand_lfo_abort()
	{
		abort $global_xyz_rand_lfo_proc
	}	
	@fun_def global_xyz_rand_dist($pos)
	{
		// print global_xyz_rand_dist $pos
		// print distance3D @distance3D([0, 0, 0], $pos)
		$global_xyz_rand_dist := @distance3D([0, 0, 0], $pos)
	}		

	@proc_def set_list_dist($module, $param, $params_list, $scale = [0.5, 4.5, 0.5, 4.5]) 
	{
		abort $set_list_dist
		$set_list_dist := {
			whenever ($global_xyz_rand_dist == $global_xyz_rand_dist)
			{
				print distance3D_fun $global_xyz_rand_dist
				// set_list($module, $param, $params_list) 
				$THISOBJ.set_list($module, $param, $params_list * @scale($global_xyz_rand_dist, $scale[0], $scale[1], $scale[2], $scale[3], 1))

			}
		}
	}	
	@fun_def set_list_dist_abort()
	{
		abort $set_list_dist
	}			
	@fun_def global_xyz_rand_lfo_print()
	{
		print global_xyz_rand_lfo_proc (""+$global_xyz_rand_lfo_proc)
		print tracks_list (""+$global_xyz_rand_lfo_proc.$tracks_list)
		print tracks_map (""+$tracks_map)
		print member (""+$global_xyz_rand_lfo_proc.$tracks_list.member($free_track))
		($global_xyz_rand_lfo_proc.$tracks_list).remove($tracks_map($free_track))
		print remove (""+$global_xyz_rand_lfo_proc.$tracks_list)
	}

	@fun_def xyz_rand_lfo($range, $tpo = 60, $type = "linear")
	{
		@local $xyz_retrieve_list
		$xyz_retrieve_list := $THISOBJ.retrieve_xyz()

		forall $i in $tracks_tab.size()
		{
			$range[2] := $xyz_retrieve_list[$i][0]
			$range[5] := $xyz_retrieve_list[$i][1]
			$range[8] := $xyz_retrieve_list[$i][2]
			print new_range (""+$range)
			$tracks($tracks_tab[$i]).xyz_rand_lfo($range, $tpo, $type)
		}
	}
	@fun_def xyz_rand_lfo_abort()
	{
		forall $t in $tracks_tab
		{
			$tracks($t).xyz_rand_lfo_abort()
		}
	}	

	@fun_def dae_rand_lfo($range, $tpo = 60, $type = "linear") // [min0,max0,init_val0, min1,max1,init_val1, min_n,max_n,init_val_n], tempo, type_interpol
	{
		// @local $xyz_retrieve_list
		// $xyz_retrieve_list := $THISOBJ.retrieve_xyz()
		forall $i in $tracks_tab.size()
		{
			$tracks($tracks_tab[$i]).dae_rand_lfo($range[$i], $tpo, $type)
		}
	}

	@fun_def d_factor($d_fac)
	{
		forall $i in $tracks_tab.size()
		{
			$tracks($tracks_tab[$i]).d_factor($d_fac)
		}
	}

	@fun_def d_factor_interp($start_dist, $end_dist, $dur, $type = "linear")
	{
		forall $i in $tracks_tab.size()
		{
			$tracks($tracks_tab[$i]).d_factor_interp($start_dist, $end_dist, $dur, $type)
		}
	}	
	// @proc_def rand_lfo_amp_param_dfactor($mod_params_min_max1, $mod_params_min_max2, $amp_min_max_tab, $d_factor_min_max, $tpo= 60, $type = "linear") 
	@fun_def rand_lfo_amp_param_dfactor($mod_params_min_max1, $mod_params_min_max2, $amp_min_max_tab, $d_factor_min_max, $tpo = 60, $type = "linear")
	{
		forall $i in $tracks_tab.size()
		{
			$tracks($tracks_tab[$i]).rand_lfo_amp_param_dfactor($mod_params_min_max1, $mod_params_min_max2, $amp_min_max_tab, $d_factor_min_max, $tpo, $type)
		}
	}	

	@fun_def rand_lfo_amp_param_dfactor_abort()
	{
		forall $t in $tracks_tab
		{
			$tracks($t).rand_lfo_amp_param_dfactor_abort()
		}
	}
	@fun_def dae_rand_lfo_abort()
	{
		forall $t in $tracks_tab
		{
			$tracks($t).dae_rand_lfo_abort()
		}
	}

	@fun_def HOA_xyz_factor($xyz_factor)
	{
		forall $t in $tracks_tab
		{
			$tracks($t).HOA_xyz_factor($xyz_factor)
		}
	}
	@fun_def rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo)
	{
		forall $t in $tracks_tab
		{
			$tracks($t).rand_lfo($module, $param, $min, $max, $init_val, $type, $tpo)
		}
	}
	@fun_def rand_lfo_dyn_bpf($module, $param, $min, $bpf_end_val, $type, $tpo)
	{
		forall $t in $tracks_tab
		{
			$tracks($t).rand_lfo_dyn_bpf($module, $param, $min, $bpf_end_val, $type, $tpo)
		}
	}	
	@fun_def lfo_abort($module, $param)
	{
		forall $t in $tracks_tab
		{
			$tracks($t).lfo_abort($module, $param)
		}
	}	
	@fun_def traj_circ2($start_coords, $clockwise, $tpo = 60)
	{
		forall $t in $tracks_tab
		{
			$tracks($t).traj_circ2($start_coords, $clockwise, $tpo)
		}
	}

	@fun_def traj_abort()
	{
		forall $t in $tracks_tab
		{
			$tracks($t).traj_abort()
		}
	}		
	@fun_def traj_radio_fac_interp($start_radio, $end_radio, $dur, $type = "linear")
	{
		forall $t in $tracks_tab
		{
			$tracks($t).traj_radio_fac_interp($start_radio, $end_radio, $dur, $type)
		}
	}
	@fun_def retrieve_xyz()
	{
		$tracks_xyz_list := [] // clear list before
		forall $t in $tracks_tab
		{
			$tracks_xyz_list.push_back($tracks($t).xyz_list()) // create list from last xyz
		}
		return $tracks_xyz_list
	}	
	@fun_def retrieve_amp()
	{
		$tracks_amp_list := [] // clear list before
		forall $t in $tracks_tab
		{
			$tracks_amp_list.push_back($tracks($t).get_amp()) // create list from last xyz
		}
		return $tracks_amp_list
	}	
	@fun_def retrieve_param($module, $param)
	{
		$tracks_param_list := [] // clear list before
		forall $t in $tracks_tab
		{
			$tracks_param_list.push_back($tracks($t).get($module, $param)) // create list from last param
		}
		return $tracks_param_list
	}	
	@proc_def xyz_interpol2point($dest_xyz, $time, $type = "linear")
	{
		@local $dest_xyz_list, $xyz_retrieve_list := $THISOBJ.retrieve_xyz()
		$dest_xyz_list := [ $dest_xyz | ($tracks_tab.size()) ] // create list dest points
		curve  @grain := 0.01,  
		@action
		{ // interpolation
			$THISOBJ.set_xyz(($dest_xyz_list*$y)+($xyz_retrieve_list*(1-$y)))
		}
        {
        $y
            {
				 {0.} @type := $type
            $time {1.} 
            }
        }
	}	
	@proc_def xyz_interpol2list($dest_xyz_list, $time = 1, $type = "linear")
	{
		@local $xyz_retrieve_list := $THISOBJ.retrieve_xyz()
		curve  @grain := 0.01,  
		@action
		{ // interpolation
			$THISOBJ.set_xyz(($dest_xyz_list*$y)+($xyz_retrieve_list*(1-$y)))
		}
        {
        $y
            {
				 {0.} @type := $type
            $time {1.} 
            }
        }
	}	
	@proc_def free($time = 1)
	{
		forall $t in $tracks_tab
		{
			$tracks($t).free($time)
		}
		0.1 abort $THISOBJ

	}	
	@react ($free_track == $free_track) // receive free track 
	{
		if ($tracks_tab.member($free_track)) // filter reac from others instances
		{
			print receive free track $free_track
			if($global_xyz_rand_lfo_proc.$tracks_list.member($free_track))
			{
				// print global_xyz_rand_lfo_proc_lista (""+$global_xyz_rand_lfo_proc.$tracks_list)
				// print (""+$tracks_group_inst1.$global_xyz_rand_lfo_proc.$tracks_list.remove(0))
				_ := $global_xyz_rand_lfo_proc.$tracks_list.remove($tracks_map($free_track))
				$tracks_map.remove($free_track)
				$tracks_tab.remove($tracks_map($free_track))
			}
		}

	}
	@abort
	{
		abort $global_xyz_rand_lfo_proc
	}
}


//// buffer objets

@global $buffers @persistent
if (@is_undef($buffers)) { $buffers := map{} }


@obj_def buffer($server_name, $buf_name) //create objet/buffer with parameters
{
	@init 
    {
	    @local $buff_id, $sync := @rand_int(50000), $num_frames, $num_chnls, $buf_sampling_rate, $list_get_state := 0, $frame_list := [], $get_state := 0, $b_get

		if ($buffers($server_name).is_undef())
		{
			$buffers.add_pair($server_name, map{})
		}
		if($buffers($server_name)($buf_name).is_undef())
		{
			$buff_id := $SC_Servers($server_name)("buffer_id")
			// $Servers($server_name).b_alloc($buff_id, $size, 1) // $buffer_id variable globale de incrementation de buffers
			$buffers($server_name).add_pair($buf_name, $buff_id) // associe l'index/env_key
			$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
			// $Servers($server_name).sync($sync) // sync with server
			// whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
			// {
			// 	print buffer $buf_name allocated
			// 	$buf_alloc($server_name).add_pair($buf_name, $buff_id) // associe l'index/env_key
			// }		
		}			
		else
		{
			$buff_id := $buffers($server_name)($buf_name)			
			print this buffer exist 
		}
			

   	}
   	@fun_def alloc($size = $sampling_rate, $num_ch = 1)
   	{
   		// $num_frames := $size
   		// $num_chnls := $num_ch
		$Servers($server_name).b_alloc($buff_id, $size, $num_ch) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).sync($buff_id) // sync with server	
   	}   
   	@fun_def allocRead($path, $starting_frame_file = 0, $numb_frames_read = 0)
   	{
		$Servers($server_name).b_allocRead($buff_id, [$path, $starting_frame_file, $numb_frames_read]) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).sync($buff_id) // sync with server	
   	}	
   	@fun_def allocReadChannel($path, $starting_frame_file = 0, $numb_frames_read = 0, $channel_index = 0)
   	{
		$Servers($server_name).b_allocReadChannel($buff_id, [$path, $starting_frame_file, $numb_frames_read, $channel_index]) // $buffer_id variable globale de incrementation de buffers
		$Servers($server_name).sync($buff_id) // sync with server	
   	}	   	   	
   	@fun_def read($path, $starting_frame_file = 0, $numb_frames = -1, $starting_frame_buf = 0, $leave_file_open = 0)
   	{
   		$Servers($server_name).b_read($buff_id, [$path, $starting_frame_file, $numb_frames, $starting_frame_buf, $leave_file_open]) // $buffer_id variable globale de incrementation de buffers
   		$Servers($server_name).sync($buff_id) // sync with server
   	}
   	@fun_def readChannel($path, $starting_frame_file = 0, $numb_frames_read = -1, $starting_frame_buf = 0, $leave_file_open = 0, $channel_index = 0)
   	{
		$Servers($server_name).b_readChannel($buff_id, [$path, $starting_frame_file, $numb_frames_read, $starting_frame_buf, $leave_file_open, $channel_index]) // $buffer_id variable globale de incrementation de buffers
   		$Servers($server_name).sync($buff_id) // sync with server
   	}	   	
   	@fun_def b_setn($vect)
   	{
   		if($vect.size()== $size)
   		{
   	   		$Servers($server_name).b_setn([$buff_id, 0, $size, $vect].flatten())		
   		}
   		else
   		{
   			print vector_size must be $size
   		}

   	}
   	@whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $buff_id)) // sync buf_id id
   	{	

   		$list_get_state := 1
   		$Servers($server_name).b_query($buff_id)
		$Servers($server_name).sync($sync)	
		// print $sync_inc
   	}
	@whenever (($list_get_state) && ($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
	{
		if($buf_info[0] == $server_name)
		{
			$list_get_state := 0
			$num_frames := $buf_info[3]
			$num_chnls := $buf_info[4]
			$buf_sampling_rate := $buf_info[5]
			// $sync := -1 //stop sending whenever
			print buffer_obj $buf_info
			$Servers($server_name).b_getn($buff_id, 0, $num_frames)
		}
	}
   	@whenever (($list_get_state) && ($buf_setn[1] == $buff_id)) //print: buf_set_replay /b_set 1 18 132608.
   	{	
   		// $frame_list.push_back($buf_set[3])
   		print frame_list (""+$buf_setn.drop(4))
   		$frame_list := $buf_setn.drop(4)
   	}
   	@whenever (($get_state) && ($buf_set[1] == $buff_id) && ($server_sync[1] == $sync)) //print: buf_set_replay /b_set 1 18 132608.
   	{	
   		$b_get := $buf_set[3]
   		print b_get_antescollider $b_get
   		$get_state := 0
   	}
   	@fun_def id()
   	{
   		return $buff_id
   	}
   	@fun_def num_frames()
   	{
   		return $num_frames
   	}
   	@fun_def num_chnls()
   	{
   		return $num_chnls
   	}  
   	@fun_def buf_sampling_rate()
   	{
   		return $buf_sampling_rate
   	}     	 	
   	@fun_def query()
   	{
   		$list_get_state := 1
   		$Servers($server_name).b_query($buff_id)
   		$Servers($server_name).sync($sync)
   	}
   	@fun_def b_get($index)
   	{
   		$get_state := 1
   		$Servers($server_name).b_get($buff_id, $index)
   		$Servers($server_name).sync($sync)
   	}    	
   	@fun_def b_getn($min = 0, $max = 30)
   	{
   		$list_get_state := 1
   		$Servers($server_name).b_getn($buff_id, $min, $max)
   	}   	
   	@fun_def b_getlist()
   	{
   		$list_get_state := 1
   		// $frame_list := []
  //  		forall $x in $num_frames
		// {
		// 	$Servers($server_name).b_get($buff_id, $x)
		// }
		$Servers($server_name).b_getn($buff_id, 0, $num_frames)
		$list_get_state := 0
		// print (""+$frame_list)
		return $frame_list
		// }
   	}      	
   	@fun_def write($path = $path_rec+$buf_name+".aif", $headerFormat = "aiff", $sampleFormat = "int32", $num_frames = -1, $start_frame = 0, $leave_file_open = 0)
   	{
   		$Servers($server_name).b_write($buff_id, $path, $headerFormat, $sampleFormat, $num_frames, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open
   	}   
   	@fun_def free()
   	{
   		print free
   		$Servers($server_name).n_free($group_id)
		$buf_alloc($server_name).remove($buf_name)			

   	}
}


@obj_def rec_buf($server_name, $duree = 1, $rec_bus = false) //create objet/buffer with parameters
{
	@init 
    {
	    @local $buf_frames, $buff_id, $group_id, $node_id, $node_id2, $node_id3_amp, $target_id, $bus, $dur, $sync, $rec_pos, $buf_amps, $when_receive := 0, $median_amp

	    $sync := @rand_int(1000)
	    $dur := @dur2sec($duree)
	    $buf_frames := $dur*$sampling_rate

	    print buffer_dur $dur
	    print buf_frames $buf_frames

		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  


	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs
		// if(! $rec_bus)
		// {
		// 	$node_id := $SC_Servers($server_name)("node_id")
  //  			$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus])  //target 2 justo despues del nodo 180 audioOut
		// 	$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain
		// }
		// else
		// {
		// 	print rec from bus
		// }
		if ($buffers($server_name).is_undef())
		{
			$buffers.add_pair($server_name, map{})
		}
		// if($buffers($server_name)($buf_name).is_undef())
		// {
		$buff_id := $SC_Servers($server_name)("buffer_id")
	    $Servers($server_name).b_alloc($buff_id, $buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
		$buffers($server_name).add_pair($buff_id, $buff_id) // store buf_index in map $buffers
		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs		
		// }			
		// else
		// {
		// 	$buff_id := $buffers($server_name)($buf_name)	
		// 	$Servers($server_name).b_zero($buff_id)	// reset all buf values to zero
		// 	print this buffer exist 
		// }		
	    // $buff_id := $SC_Servers($server_name)("buffer_id")
	    // $Servers($server_name).b_alloc($buff_id, $buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
	    // $SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
	    

		$Servers($server_name).sync($sync) // sync with server

		$node_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus, amp, -120])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain

		$node_id2 := $SC_Servers($server_name)("node_id")
		$SC_Servers($server_name).add_pair("node_id", $node_id2 + 1) // incremente pour le prochain
		
		$node_id3_amp := $SC_Servers($server_name)("node_id")
		$SC_Servers($server_name).add_pair("node_id", $node_id3_amp + 1) // incremente pour le prochain

		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
		{
			print buffer $buff_id rec_buf allocated buf_frames $buf_frames sync $sync
		}	
   	}

   	@proc_def rec($input, $amp = 0, $fade_in = 0.01, $fade_out = 0.01, $loop = 0, $doneAction = 4, $name = "SF")
   	{
  //  		if($rec_bus)
		// {
		// 	$bus := $input
		// 	$target_id := $group_id
		// }
		// else
		// {
		// 	$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])
		// 	$target_id := $node_id
		// }
		$buf_amps := []

		$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])

		// $node_id2 := $SC_Servers($server_name)("node_id")
		// print doneAction $doneAction
		$Servers($server_name).s_new(["TRecBuf", $node_id2, 3, $node_id, "in", $bus, "rec_dur", $dur, "buf", $buff_id, "loop", $loop, "doneAction", $doneAction, "fade_in",  $fade_in, "fade_out", $fade_out, in_gain, 0])  //target 2 justo despues del modulo anterior 
		// $SC_Servers($server_name).add_pair("node_id", $node_id2 + 1) // incremente pour le prochain
		
		// $node_id3_amp := $SC_Servers($server_name)("node_id")
		// $Servers($server_name).s_new(["Amplitude_Replay", $node_id3_amp, 3, $node_id2, "in", $bus, "id", $buff_id])  //target 2 justo despues del modulo anterior 
		// $SC_Servers($server_name).add_pair("node_id", $node_id3_amp + 1) // incremente pour le prochain

		// whenever ($descriptors_receives == $descriptors_receives) 
		// {
		// 	print descriptors_receives (""+$descriptors_receives)
		// }
		// abort $when_receive
		// $when_receive := { 
		// 	whenever (($descriptors_receives[0] == $server_name) && ($descriptors_receives[1][0] == "/amplitude") && ($descriptors_receives[1][2] == $buff_id)) 
		// 	{
		// 		print amplitude2 ($descriptors_receives[1][3])
		// 		$buf_amps.push_back($descriptors_receives[1][3])
		// 	}
		// }
	
		if($loop == 0)
		{
			// ($dur) $Servers($server_name).n_set($node_id2, [gate, 0])
			($dur) $Servers($server_name).n_set($node_id, [amp, -120])
		}
		curve
		   // @tempo := $tpo
		   @Grain := 5 ms //0.01s 
		   // @action :=  { print $rec_pos }

		   { $rec_pos {
				  		{0}
			  $duree 	{1} 
			  }
		   }
		// ==> print moyenne @median($buf_amps)
		// $median_amp := @median($buf_amps)
   	}
   	@fun_def stop_record($fade_out = 0.01) // no funciona fade out
   	{
   		$Servers($server_name).n_set($node_id2, [gate, 0]) //
   	}   	
   	@fun_def rec_loop($rec_loop)
   	{
   		$Servers($server_name).n_set($node_id2, ["loop", $rec_loop])
   	}   	
   	@fun_def id()
   	{
   		return $buff_id
   	}
   	@fun_def dur()
   	{
   		return $duree
   	}
   	@fun_def abs_dur()
   	{
   		return $dur
   	}    
   	@fun_def median_amp()
   	{
   		return $median_amp
   	}    		
   	@fun_def query()
   	{
   		$Servers($server_name).b_query($buff_id)
   	}
   	@fun_def getn()
   	{
   		$Servers($server_name).b_getn($buff_id, 10, 20) // for tests
   	}
   	@fun_def clear()
   	{
   		$Servers($server_name).b_zero($buff_id)
   	}  
   	@fun_def read($path, $starting_frame_file = 0, $numb_frames = -1, $starting_frame_buf = 0, $leave_file_open = 0)
   	{
   		$Servers($server_name).b_read($buff_id, [$path, $starting_frame_file, $numb_frames, $starting_frame_buf, $leave_file_open]) // $buffer_id variable globale de incrementation de buffers
   		$Servers($server_name).sync($sync) // sync with server
   	}   	
   	//path, headerFormat: "aiff", sampleFormat: "int24", numFrames: -1, startFrame: 0, leaveOpen: false
   	@fun_def write($name, $headerFormat = "aiff", $sampleFormat = "int24", $numFrames = -1, $startFrame = 0, $leaveOpen = 0)
   	{
   		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, $numFrames, $startFrame, $leaveOpen) // create an output file for this buffer, leave it open

   	}   	
   	@fun_def free()
   	{
   		print free
   		$Servers($server_name).n_free($group_id) // free node
   		$Servers($server_name).b_free($buff_id) // free buffer
   		$buffers($server_name).remove($buff_id) // remove buf_index from map $buffers

   	}
}

@obj_def rec_buf_onset($server_name, $duree) //create objet/buffer with parameters
{
	@init 
    {
	    @local $buf_frames, $buff_id, $group_id, $node_id, $node_id2, $node_id3_amp, $target_id, $bus, $dur, $sync, $rec_pos, $buf_amps, $when_receive := 0, $median_amp, $last_date, $dates := [], $whenever_rec_buf := 0

	    $sync := @rand_int(1000)
	    $dur := @dur2sec($duree)
	    $buf_frames := $dur*$sampling_rate

		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  


	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs
		// if(! $rec_bus)
		// {
		// 	$node_id := $SC_Servers($server_name)("node_id")
  //  			$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus])  //target 2 justo despues del nodo 180 audioOut
		// 	$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain
		// }
		// else
		// {
		// 	print rec from bus
		// }
		if ($buffers($server_name).is_undef())
		{
			$buffers.add_pair($server_name, map{})
		}
		// if($buffers($server_name)($buf_name).is_undef())
		// {
		$buff_id := $SC_Servers($server_name)("buffer_id")
	    $Servers($server_name).b_alloc($buff_id, $buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
		$buffers($server_name).add_pair($buff_id, $buff_id) // store buf_index in map $buffers
		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs		
		// }			
		// else
		// {
		// 	$buff_id := $buffers($server_name)($buf_name)	
		// 	$Servers($server_name).b_zero($buff_id)	// reset all buf values to zero
		// 	print this buffer exist 
		// }		
	    // $buff_id := $SC_Servers($server_name)("buffer_id")
	    // $Servers($server_name).b_alloc($buff_id, $buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
	    // $SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
	    

		$Servers($server_name).sync($sync) // sync with server

		$node_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus, amp, -120])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain

		$node_id2 := $SC_Servers($server_name)("node_id")
		$SC_Servers($server_name).add_pair("node_id", $node_id2 + 1) // incremente pour le prochain
		
		$node_id3_amp := $SC_Servers($server_name)("node_id")
		$SC_Servers($server_name).add_pair("node_id", $node_id3_amp + 1) // incremente pour le prochain

		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
		{
			print buffer $buff_id rec_buf allocated buf_frames $buf_frames sync $sync
		}	
   	}

   	@proc_def rec($input, $amp = 0, $fade_in = 0.01, $fade_out = 0.01, $loop = 0, $doneAction = 4, $name = "SF")
   	{
  //  		if($rec_bus)
		// {
		// 	$bus := $input
		// 	$target_id := $group_id
		// }
		// else
		// {
		// 	$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])
		// 	$target_id := $node_id
		// }
		$buf_amps := []

		$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])

		// $node_id2 := $SC_Servers($server_name)("node_id")
		// print doneAction $doneAction
		$Servers($server_name).s_new(["TRecBuf", $node_id2, 3, $node_id, "in", $bus, "rec_dur", $dur, "buf", $buff_id, "loop", $loop, "doneAction", $doneAction, "fade_in",  $fade_in, "fade_out", $fade_out, in_gain, 0])  //target 2 justo despues del modulo anterior 
		// $SC_Servers($server_name).add_pair("node_id", $node_id2 + 1) // incremente pour le prochain
		
		// $node_id3_amp := $SC_Servers($server_name)("node_id")
		// $Servers($server_name).s_new(["Amplitude_Replay", $node_id3_amp, 3, $node_id2, "in", $bus, "id", $buff_id])  //target 2 justo despues del modulo anterior 
		// $SC_Servers($server_name).add_pair("node_id", $node_id3_amp + 1) // incremente pour le prochain

		// whenever ($descriptors_receives == $descriptors_receives) 
		// {
		// 	print descriptors_receives (""+$descriptors_receives)
		// }
		// abort $when_receive
		// $when_receive := { 
		// 	whenever (($descriptors_receives[0] == $server_name) && ($descriptors_receives[1][0] == "/amplitude") && ($descriptors_receives[1][2] == $buff_id)) 
		// 	{
		// 		print amplitude2 ($descriptors_receives[1][3])
		// 		$buf_amps.push_back($descriptors_receives[1][3])
		// 	}
		// }
		$last_date := $NOW
		$whenever_rec_buf := {
			// whenever  (($onsetdetect[1] == $input))
			whenever (($ampgatedetect[0] == "server5") && ($ampgatedetect[1] == $input))
			{
				print onset
				$dates.push_back($NOW - $last_date)

			}
		}

		if($loop == 0)
		{
			($duree) $Servers($server_name).n_set($node_id2, [gate, 0])
			$Servers($server_name).n_set($node_id, [amp, -120])
			curve
		    // @tempo := $tpo
			@Grain := 5 ms //0.01s 
			// @action :=  { print $rec_pos }

			{ $rec_pos {
					  	{0}
				$duree 	{1} 
				}
			}
			==> abort $whenever_rec_buf // stop 	
		}
		else
		{
			// hacer loop rec 1
		}

		//print moyenne @median($buf_amps)
		// $median_amp := @median($buf_amps)
   	}
   	@fun_def stop_record($fade_out = 0.01) // no funciona fade out
   	{
   		$Servers($server_name).n_set($node_id2, [gate, 0]) //
   	}   	
   	@fun_def rec_loop($rec_loop)
   	{
   		$Servers($server_name).n_set($node_id2, ["loop", $rec_loop])
   	}   	
   	@fun_def id()
   	{
   		return $buff_id
   	}
   	@fun_def dur()
   	{
   		return $duree
   	}
   	@fun_def abs_dur()
   	{
   		return $dur
   	}    
   	@fun_def dates()
   	{
   		return $dates
   	}   	
   	@fun_def median_amp()
   	{
   		return $median_amp
   	}    		
   	@fun_def query()
   	{
   		$Servers($server_name).b_query($buff_id)
   	}
   	@fun_def getn()
   	{
   		$Servers($server_name).b_getn($buff_id, 10, 20) // for tests
   	}
   	@fun_def clear()
   	{
   		$Servers($server_name).b_zero($buff_id)
   	}   	  
   	@fun_def write($name, $headerFormat = "aiff", $sampleFormat = "int32", $num_frames = -1, $start_frame = 0, $leave_file_open = 0)
   	{
   		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, $num_frames, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open
   	}     		
   	@fun_def free()
   	{
   		print free
   		$Servers($server_name).n_free($group_id) // free node
   		$Servers($server_name).b_free($buff_id) // free buffer
   		$buffers($server_name).remove($buff_id) // remove buf_index from map $buffers

   	}
}

@obj_def rec_buf_pvoc($server_name, $duree = 1, $hop_size = 0.25, $FftSize = 2048, $rec_bus = false, $name = "SF") //create objet/buffer with parameters
{
	@init 
    {
	    @local $pvoc_buf_frames, $buff_id, $group_id, $node_id, $node_id2, $target_id, $bus, $dur, $sync, $rec_pos

	    $sync := @rand_int(1000)
	    $dur := @dur2sec($duree)
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

		if ($buffers($server_name).is_undef())
		{
			$buffers.add_pair($server_name, map{})
		}

	    $pvoc_buf_frames := (@calcPVRecSize_compiled($dur, $FftSize, $hop_size)) // fft buffer size calculation
	    $buff_id := $SC_Servers($server_name)("buffer_id")
	    $Servers($server_name).b_alloc($buff_id, $pvoc_buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
		$buffers($server_name).add_pair($buff_id, $buff_id) // store buf_index in map $buffers	    
	    $SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
	    
	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs
		if(! $rec_bus)
		{
			$node_id := $SC_Servers($server_name)("node_id")
   			$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus])  //target 2 justo despues del nodo 180 audioOut
			$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain
		}
		else
		{
			print rec from bus
		}
		$Servers($server_name).sync($sync) // sync with server

		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
		{
			print buffer $buff_id rec_buf_pvoc allocated sync $sync
		}	
   	}

   	@proc_def rec($input, $amp = 0, $fade_in = 0.01, $fade_out = 0.01, $loop = 0)
   	{
   		if($rec_bus)
		{
			$bus := $input
			$target_id := $group_id
		}
		else
		{
			$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])
			$target_id := $node_id
		}
		$node_id2 := $SC_Servers($server_name)("node_id")
		$Servers($server_name).s_new(["TRecPvocBuf", $node_id2, 3, $target_id, "in", $bus, "rec_dur", $dur, "buf", $buff_id, "hop", $hop_size, "fftSize", $FftSize, "loop", $loop, "fade_in",  $fade_in, "fade_out", $fade_out, in_gain, 0])  //target 2 justo despues del modulo anterior 
		$SC_Servers($server_name).add_pair("node_id", $node_id2 + 1) // incremente pour le prochain

		curve
		   // @tempo := $tpo
		   @Grain := 5 ms //0.01s 
		   // @action :=  { print $rec_pos }

		   { $rec_pos {
				  		{0}
			  $duree 	{1} 
			  }
		   }		    	   	
   	}
   	@fun_def stop_record($fade_out = 0.01) // no funciona fade out
   	{
   		$Servers($server_name).n_set($node_id2, [in_gain, -120]) //
   	}   	
   	@fun_def id()
   	{
   		return $buff_id
   	}
   	@fun_def dur()
   	{
   		return $duree
   	}
   	@fun_def abs_dur()
   	{
   		return $dur
   	}   	
   	@fun_def query()
   	{
   		$Servers($server_name).b_query($buff_id)
   	}
   	@fun_def write($name, $header_format = "aiff", $sample_format = "int32", $num_frames = -1, $start_frame = 0, $leave_file_open = 0)
   	{
   		$Servers($server_name).b_write($buff_id, $path_rec+$name+".aif", $headerFormat, $sampleFormat, 0, $start_frame, $leave_file_open) // create an output file for this buffer, leave it open

   	} 
   	@fun_def clear()
   	{
   		$Servers($server_name).b_zero($buff_id)
   	}     	   	
   	@fun_def free()
   	{
   		print free
   		$Servers($server_name).n_free($group_id)
   		$Servers($server_name).b_free($buff_id)
   		$buffers($server_name).remove($buff_id) // remove buf_index from map $buffers

   	}
}

@obj_def rec_buf_hybrid($server_name, $duree = 1, $hop_size = 0.25, $FftSize = 4096, $rec_bus = false) //create objet/buffer with parameters
{
	@init 
    {
	    @local $buf_frames, $pvoc_buf_frames, $buff_id, $buff_id_fft, $group_id, $node_id, $node_id2, $target_id, $bus, $dur, $sync, $rec_pos

	    $sync := @rand_int(1000)
	    $dur := @dur2sec($duree)
	    

		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs

	    $pvoc_buf_frames := (@calcPVRecSize_compiled($dur, $FftSize, $hop_size)) // fft buffer size calculation
	    $buff_id_fft := $SC_Servers($server_name)("buffer_id")
	    $Servers($server_name).b_alloc($buff_id_fft, $pvoc_buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
	    $SC_Servers($server_name).add_pair("buffer_id", $buff_id_fft + 1) // incremente le node_id dans le dico des serveurs
	    
	    $buf_frames := $dur*$sampling_rate
	    $buff_id := $SC_Servers($server_name)("buffer_id")
	    $Servers($server_name).b_alloc($buff_id, $buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
	    $SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs

		// $Servers($server_name).sync($sync) // sync with server

		$node_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus, amp, -120])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain


	 //    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		// $Servers($server_name).g_new($group_id, 0, 1) // create group
		// $SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs
		// if(! $rec_bus)
		// {
		// 	$node_id := $SC_Servers($server_name)("node_id")
  //  			$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus])  //target 2 justo despues del nodo 180 audioOut
		// 	$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain
		// }
		// else
		// {
		// 	print rec from bus
		// }
		$Servers($server_name).sync($sync) // sync with server

		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
		{
			print buffer $buff_id_fft and $buff_id rec_buf_pvoc allocated sync $sync
		}	
   	}

   	@proc_def rec($input, $amp = 0, $fade_in = 0.01, $fade_out = 0.01, $loop = 0, $doneAction = 2)
   	{
  //  		if($rec_bus)
		// {
		// 	$bus := $input 
		// 	$target_id := $group_id
		// }
		// else
		// {
		// 	$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])
		// 	$target_id := $node_id
		// }
		$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])

		$node_id2 := $SC_Servers($server_name)("node_id")
		$Servers($server_name).s_new(["RecHybrid", $node_id2, 3, $node_id, "in", $bus, "rec_dur", $dur, "buf", $buff_id, "buf_fft", $buff_id_fft, "loop", $loop, "doneAction", $doneAction, "fade_in",  $fade_in, "fade_out", $fade_out, in_gain, 0])  //target 2 justo despues del modulo anterior 
		$SC_Servers($server_name).add_pair("node_id", $node_id2 + 1) // incremente pour le prochain

	
		if($loop == 0)
		{
			($dur) $Servers($server_name).n_set($node_id2, [gate, 0])
			$Servers($server_name).n_set($node_id, [amp, -120])
		}
		curve
		   // @tempo := $tpo
		   @Grain := 5 ms //0.01s 
		   // @action :=  { print $rec_pos }

		   { $rec_pos {
				  		{0}
			  $duree 	{1} 
			  }
		   }	
	    	   	
   	}
   	@fun_def stop_record($fade_out = 0.01) // no funciona fade out
   	{
   		$Servers($server_name).n_set($node_id2, [in_gain, -120]) //
   	}   	
   	@fun_def id()
   	{
   		return $buff_id
   	}
   	@fun_def id_fft()
   	{
   		return $buff_id_fft
   	}  
   	@fun_def clear()
   	{
   		$Servers($server_name).b_zero($buff_id)
   		$Servers($server_name).b_zero($buff_id_fft)
   	}  
   	@fun_def dur()
   	{
   		return $duree
   	}
   	@fun_def query()
   	{
   		$Servers($server_name).b_query($buff_id)
   		$Servers($server_name).b_query($buff_id_fft)
   	}
    @fun_def b_getn($min = 0, $max = 30)
   	{
   		$Servers($server_name).b_getn($buff_id, $min, $max)
   	}   
    @fun_def b_getn_fft($min = 0, $max = 30)
   	{
   		$Servers($server_name).b_getn($buff_id_fft, $min, $max)
   	}     		
   	@fun_def free()
   	{
   		print free
   		$Servers($server_name).n_free($group_id)
   		$Servers($server_name).b_free($buff_id)
   		$Servers($server_name).b_free($buff_id_fft)
   	}
}


@global $buf_alloc @persistent
if (@is_undef($buf_alloc)) { $buf_alloc := map{} }



@obj_def alloc_buffer($server_name, $buf_name, $size = 256, $num_chnls = 1) //create objet/buffer with parameters
{
	@init 
    {
	    @local $buff_id, $sync := @rand_int(1000), $res_tab := []

		if ($buf_alloc($server_name).is_undef())
		{
			$buf_alloc.add_pair($server_name, map{})
		}
		if($buf_alloc($server_name)($buf_name).is_undef())
		{
			$buff_id := $SC_Servers($server_name)("buffer_id")
			$Servers($server_name).b_alloc($buff_id, $size, 1) // $buffer_id variable globale de incrementation de buffers
			$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
			$Servers($server_name).sync($sync) // sync with server

			whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync)) // wait for server syc
			{
				print buffer $buf_name allocated
				$buf_alloc($server_name).add_pair($buf_name, $buff_id) // associe l'index/env_key
			}		
		}			
		else
		{
			$buff_id := $buf_alloc($server_name)($buf_name)			
			print this buffer exist 
		}
			

   	}
   	@fun_def b_setn($vect)
   	{
   		if($vect.size()== $size)
   		{
   	   		$Servers($server_name).b_setn([$buff_id, 0, $size, $vect].flatten())		
   		}
   		else
   		{
   			print vector_size must be $size
   		}

   	}
   	@fun_def id()
   	{
   		return $buff_id
   	}
   	@fun_def interpol($tab1, $tab2, $i_val)
   	{
   		$res_tab := ($tab2*$i_val)+($tab1*(1-$i_val))
   		// $Servers($server_name).b_setn([$buff_id, 0, $size, $res_tab].flatten())
   		$THISOBJ.b_setn($res_tab)
   		// print (""+[$buff_id, 0, $size, $res_tab].flatten())
   		// print server_name $server_name
   		// print (""+$res_tab)
   		// buf_interpol $res_tab
   		// print size $size
   	}
   	@fun_def query()
   	{
   		$Servers($server_name).b_query($buff_id)
   	}
   	@fun_def b_getn($min = 0, $max = 30)
   	{
   		$Servers($server_name).b_getn($buff_id, $min, $max)
   	}   
   	@fun_def clear()
   	{
   		$Servers($server_name).b_zero($buff_id)
   	}     		
   	@fun_def free()
   	{
   		print free
   		$Servers($server_name).n_free($group_id)
		$buf_alloc($server_name).remove($buf_name)			

   	}
}

// create fft_buffer from sound file for VBPVoc UGEN
@obj_def VBPVoc_load_anal($server_name, $sound_file, $fft_size)
{
	@init 
    {
	    @local $buff_id, $buff_fft := 0, $sync1, $sync2 := -1, $sync3 := -1, $overlap := 4, $hopsize := $fft_size/$overlap, $fftframes, $outframes, $sf_dur := 0, $sound_path
	    
	    $buff_id := $SC_Servers($server_name)("buffer_id")	    
	    $sync1  := (@rand_int(1000)+1)

	    
	    print sync1 $sync1
	    // print sync2 $sync2
	    // print sync3 $sync3

	    $sound_path := $SF_path($sound_file)

		$Servers($server_name).b_allocRead($buff_id, $sound_path) // load buffer in sc_server
		$SC_Servers($server_name).add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
		$Servers($server_name).sync($sync1)
		// $sync1 := -1

		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync1)) // wait for server syc
		{
			
			$sync2 := (@rand_int(1000)+1)
			print sync1 $sync1
			print sync2 $sync2
			$sync1 := -1
			$Servers($server_name).b_query($buff_id)
			$Servers($server_name).sync($sync2)		  	 	 
		}

		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync2)) // wait for server syc
		{
			$sync3 := (@rand_int(1000)+1)
			
			print sync2 $sync2
			print sync3 $sync3
			$sync2 := -1
			print buf_info $buf_info
			print buf_frames ($buf_info[3])
			print buf_num_chnls ($buf_info[4])
			$sf_dur := $buf_info[3]/$sampling_rate
			$buff_fft := $SC_Servers($server_name)("buffer_id")
			$fftframes := (($buf_info[3] - $fft_size) / $hopsize + 2).ceil()
			$outframes := ($fft_size/2) * $fftframes
			print ("fftframes: "+$fftframes)
			$Servers($server_name).b_alloc($buff_fft, $outframes, $buf_info[4]*2) //$buf_info[4] = numChannels
			$Servers($server_name).sync($sync3)
			// $sync3 := -1
			$SC_Servers($server_name).add_pair("buffer_id", $buff_fft + 1) // incremente le node_id dans le dico des serveurs

		}
		whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync3)) // wait for server syc
		{
			
			print s3 sync2 $sync2
			print s3 sync3 $sync3
			$sync3 := -1
			$THISOBJ.pvocAnal()

		}
	}

	@fun_def pvocAnal()
	{
		//		server.listSendMsg(["/b_gen", bufnum, "PVocAnal", buf.bufnum, fftsize, completionMessage.value(this)]);
		$Servers($server_name).b_gen($buff_fft, "PVocAnal", $buff_id, $fft_size) //
	}
	@fun_def dur()
	{
		return $sf_dur
	}	
	@fun_def VBPVoc_buf()
	{
		return $buff_fft
	}

}
// $rec_buf_pvoc10 := obj::rec_buf_pvoc($server, $hop_size, $FftSize, $dur) //create objet/buffer with parameters
// $rec_buf_pvoc10.id() //buffer id
// $rec_buf_pvoc10.rec($input) //buffer id

// $hop_size := 0.25
// $FftSize := 2048

// $pvoc_buf_frames := (@calcPVRecSize(10, $FftSize, $hop_size)) // 1 second fft buffer size calculation
// print $pvoc_buf_frames

// $buff_id := $SC_Servers("server1")("buffer_id")
// $Servers("server1").b_alloc($buff_id, $pvoc_buf_frames, 1) // $buffer_id variable globale de incrementation de buffers
// $SC_Servers("server1").add_pair("buffer_id", $buff_id + 1) // incremente le node_id dans le dico des serveurs
// $Servers("server1").b_query($buff_id)
// $Servers("server1").b_getn($buff_id, 1000, 1100)
// $Servers("server1").b_get($buff_id, 48000)

// print $buff_id
// $tracks("gran_htb").free(1)
// $Servers("server1").g_dumpTree(0, 1)
// obj::crea_track("gran_htb", "group_mono_rec1", fade_in = 0.001, amp = 0, [["AudioInput", "input", $fl], ["TRecPvocBuf", "rec_dur", 10, "buf", $buff_id, "hop", $hop_size, "fftSize", $FftSize]]) 

$rt_analyse := []

@obj_def rt_analyse($server_name, $analyse) 
{
	@init 
    {
	    @local $group_id, $node_id, $node_id2, $target_id, $bus

		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  


	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs

		$node_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $node_id, 1, $group_id, "out", $bus, amp, -120])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $node_id + 1) // incremente pour le prochain

		$node_id2 := $SC_Servers($server_name)("node_id")
		$SC_Servers($server_name).add_pair("node_id", $node_id2 + 1) // incremente pour le prochain

   	}

   	@proc_def analyse($input, $amp = 0, $fade_in = 0.01, $fade_out = 0.01, $loop = 0, $doneAction = 4)
   	{

		$Servers($server_name).n_set($node_id, ["input", $input, "amp", $amp])

		$Servers($server_name).s_new([$analyse, $node_id2, 3, $node_id, "in", $bus, id, $node_id2, doneAction, $doneAction])  
   	}
   	@fun_def stop_analyse($fade_out = 0.01) // no funciona fade out
   	{
   		$Servers($server_name).n_set($node_id2, [gate, 0]) //
   	}   	 	
   	@fun_def id() // send_replay id
   	{
   		return $node_id2
   	} 	
   	@fun_def trig_ana() // send_replay id
   	{
   		$Servers($server_name).n_set($node_id2, [t_trig, 1]) 
   	}    	
   	@whenever (($descriptors_receives[0] == $server_name) && ($descriptors_receives[1][0] == "/topnfreq") && ($descriptors_receives[1][2] == $node_id2))
	{
		print (""+$descriptors_receives)
			// $onsetdetect := [$server_name, $id] // send to whenever
			// $actif := 0
			// let $descriptors_receives[1][2] := -1 // avoid whenever loop
			// ($antirebond) $actif := 1 //antirebond
			$rt_analyse := [$server_name, $node_id2, @drop($descriptors_receives[1], 3)]
	}
   	@fun_def free()
   	{
   		print free
   		$Servers($server_name).n_free($group_id)
   	}
}

/////////////////////////// processus

/// Play automation from prerecorded NIM

@proc_def ::play_automation($server_name, $track_id, $auto_name, $dur_final = false)
@abort
{
	$trajs.remove($proc_index)
}
{
	@local $xyz2, $xyz := [0, 0, 0], $proc_index, $nim_rec, $min, $max, $dur, $res_xyz


	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	// $x := 0
	// $nim_rec := @loadvalue("/Users/josephfernandez/Library/Application\ Support/SuperCollider/automation/test1")
	$nim_rec := @loadvalue($path_automation + $auto_name)
	// print nim_rec (""+$nim_rec)
	$min := @min_key($nim_rec)[0]
	$max := @max_key($nim_rec)[0]

	if($dur_final)
	{
		$dur := $dur_final
	}
	else
	{
		$dur := $max
	}
	// print max $max 

	curve slider @Grain := 0.01s, @Action :=  {
		$res_xyz := $nim_rec($xyz2)
		// print xyz (""+$nim_rec($xyz2))
		// print cartopol3D_tab (@cartopol3D_ambi_tab($nim_rec($xyz2)))
		$xyz[0] := $res_xyz[0]
		$xyz[1] := $res_xyz[1]
		$xyz[2] := $res_xyz[2]		
		$Servers($server_name).n_set($track_id, ["coords", @cartopol3D_ambi_tab($nim_rec($xyz2))])	
		// $xyz := $x            
	}
		{ $xyz2 { 		{	($min)	} 
			($dur)  {	($max)	} } }
		+=>  $trajs.remove($proc_index)

}


@proc_def sin_lfo_proc($group, $module, $param, $r_low, $r_hi, $t) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
    @local $x, $val, $amp, $offset, $sin_proc, $grain, $period 
    $amp := ($r_hi - $r_low)/2
    $offset := $r_hi - $amp
    $sin_proc := 0
    $grain := 0.01
    $period := (1/$t)
    loop $period // @tempo := $t
    {
		  abort $sin_proc
		  $sin_proc := {
				curve
				@grain := 0.01 //($grain * $period/60.)
				@action := {
					   $val := (@sin($x) * $amp + $offset)  //+ $offset
					   // n_set $module $param $val 
					   $Servers($server_name).n_set($module, [$param, $val])
					   gui_data $group $module $param $val
				}                       
				   { $x{    { 0  }
						$period { (2* 3.141516 )}  }  // NON Pi = 3.1415926... d'où 3.1416 pas 3.141516 ????
					   }
	   }

    }
}

@proc_def sin_lfo_proc_s($server_name, $group, $module, $param, $r_low, $r_hi, $t) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
    @local $x, $val, $amp, $offset, $sin_proc, $grain, $period 
    $amp := ($r_hi - $r_low)/2
    $offset := $r_hi - $amp
    $sin_proc := 0
    $grain := 0.01
    $period := (1/$t)
    loop $period // @tempo := $t
    {
		  abort $sin_proc	
		  $sin_proc := {
				curve
				@grain := 0.01 //($grain * $period/60.)
				@action := {
					   $val := (@sin($x) * $amp + $offset)  //+ $offset
					   // scServer "n_set" $module $param $val
					   $Servers($server_name).n_set($module, [$param, $val])
					   // n_set $module $param $val
					   // print ("n_set"+$server_name) $module $param $val $r_low $r_hi $t 
					   // print $x $amp $period
					   gui_data $server_name $group $module $param $val
				}                       
				   { $x {    { 0  }
						$period { (2* 3.141516 )}  }  // NON Pi = 3.1415926... d'où 3.1416 pas 3.141516 ????
					   }
	   }

    }
}

@proc_def sin_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
    @local $x, $val, $amp, $offset, $sin_proc, $grain, $period, $vst_param_index
    $amp := ($r_hi - $r_low)/2
    $offset := $r_hi - $amp
    $sin_proc := 0
    $grain := 0.01
    $period := (1/$t)

    if($vst_all_map($vst_name)("parameters").is_defined($param))
	{
		$vst_param_index := $vst_all_map($vst_name)("parameters")($param)

	    loop $period // @tempo := $t
	    {
	   abort $sin_proc	
	   $sin_proc := {
		  curve
		  @grain := 0.01 //($grain * $period/60.)
		  @action := {
				$val := (@sin($x) * $amp + $offset)  //+ $offset
				// $Servers($server_name).n_set($module, [$param, $val])
				 $Servers($server_name).u_cmd([$vst_nodeID, 6, "/set", $vst_param_index, @to_char($val)]) // 6 = UGen id inside Synthdef
		  }                       
				{ $x {    { 0  }
			   $period { (2* 3.141516 )}  }  // NON Pi = 3.1415926... d'où 3.1416 pas 3.141516 ????
			 }
		   }
	    }
	}
}

// Global obj to control different track methods
@obj_def sin_lfo_glob($r_low, $r_hi, $t)
{
   @local $suscriber := MAP{}, $x, $receive, $amp, $offset, $grain, $period, $sin_proc := 0
		@init 
		{
		    $amp := ($r_hi - $r_low)/2
		    $offset := $r_hi - $amp
		    $grain := 0.01
		    $period := (1/$t)

			// abort $curve_int_proc
			$THISOBJ.diffuse()
		}
		@fun_def add_suscriber($x, $f)
	   	{
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name, $params, $method

			$method := @extract_method(""+$f)


			if ($method == "set")
			{
				// print es set 
				$params := @extract_command(""+$f)
				// @slice(""+$f, 12, 15)
				// print commande $params
				$int_name := $x.$track_name+$method+($params[0])+($params[1])

			}
			else
			{
				// print $method
				$int_name := $x.$track_name+$method

			}
			// print int_name $int_name
			$suscriber.add_pair($int_name, [$x, $f])

	  	}
		@fun_def tpo($temp)
	  	{
			$period := (1/$temp)
	  	}	  
		@fun_def minmax($mi, $ma)
	  	{
			$r_low := $mi
			$r_hi := $ma
	  	}		  		
		@fun_def unsuscribe($x, $n, $n1 = "module", $n2 = "param")
	  	{
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name := $x.$track_name+$n
			if($n == "set")
			{
				$int_name := $x.$track_name+$n+""+$n1+""+$n2
			}
			else
			{
				$int_name := $x.$track_name+$n
			}
			$suscriber.remove($int_name)
	  	}	  	 
		@proc_def diffuse()
		{
			// $curve_int_proc := { 

		    loop $period // @tempo := $t
		    {
				  abort $sin_proc	
				  $sin_proc := {
						curve
						@grain := 0.01 //($grain * $period/60.)
						@action := {
							   $receive := (@sin($x) * $amp + $offset)  //+ $offset
							   // print sin_ $receive
							   forall $k, $v in $suscriber { _ := ($v[1])($v[0], $receive) }
						}                       
						   { $x {    { 0  }
								$period { (2* $pi )}  }  // NON Pi = 3.1415926... d'où 3.1416 pas 3.141516 ????
							}
			   }

		    }

			// }
   	}
	@abort
	{
	 @clear($suscriber)
	}
}


@proc_def saw_lfo_proc($group, $module, $param, $r_low, $r_hi, $t, $dir) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
    @local $x, $val, $amp, $offset, $sin_proc, $grain, $period, $init, $end
    $amp := ($r_hi - $r_low)/2
    $offset := $r_hi - $amp
    $sin_proc := 0
    $grain := 0.01
    if ($dir == 1)
    {
	$init := 0
	$end := 1
    }
    else
    {
	$init := 1
		$end := 0
    }
    $period := (1/$t)
    loop $period // @tempo := $t
    {
		  abort $sin_proc
		  $sin_proc := {
				curve
				@grain := 0.01 //($grain * $period/60.)
				@action := {
					  
					   // n_set $module $param $val 
					   $Servers($server_name).n_set($module, [$param, $val])
					   gui_data $group $module $param $val
				}                       
					{ $val 	{ 	{ $init }
					   $period { $end }  } 
					   }
	   }

    }
}


@proc_def saw_lfo_proc_s($server_name, $group, $module, $param, $r_low, $r_hi, $t, $dir, $type) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
    @local $x, $val, $amp, $offset, $sin_proc := 0, $grain, $period, $init, $end, $resulta
    $amp := ($r_hi - $r_low)
    $offset := $r_hi - $amp
    $sin_proc := 0
    $grain := 0.01
    if ($dir == 1)
    {
	$init := 0
	$end := 1
    }
    else
    {
	$init := 1
		$end := 0
    }
    $period := (1/$t)
    loop $period // @tempo := $t
    {
	   abort $sin_proc
	   $sin_proc := {
			 curve
			 @grain := 0.01 //($grain * $period/60.)
			 @action := {
				   $resulta := ($val*$amp)+$offset
				    // n_set $module $param $val 
				    // @command("n_set"+$server_name) $module $param $resulta

				    $Servers($server_name).n_set($module, [$param, $resulta])

				    gui_data $server_name $group $module $param $resulta
			 }                       
				{ $val 	{ 	{ $init } @type := $type
				    $period { $end }  } 
				    }
	}
    }
}

@proc_def saw_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t, $dir, $type) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
    @local $x, $val, $amp, $offset, $sin_proc := 0, $grain, $period, $init, $end, $resulta, $vst_param_index
    $amp := ($r_hi - $r_low)
    $offset := $r_hi - $amp
    $sin_proc := 0
    $grain := 0.01
    if ($dir == 1)
    {
	$init := 0
	$end := 1
    }
    else
    {
	$init := 1
		$end := 0
    }
    $period := (1/$t)

	if($vst_all_map($vst_name)("parameters").is_defined($param))
	{
		$vst_param_index := $vst_all_map($vst_name)("parameters")($param)
	    loop $period // @tempo := $t
	    {
			  abort $sin_proc
			  $sin_proc := {
					curve
					@grain := 0.01 //($grain * $period/60.)
					@action := {
						  $resulta := ($val*$amp)+$offset
						   // n_set $module $param $val 
						   // @command("n_set"+$server_name) $module $param $resulta

						   // $Servers($server_name).n_set($module, [$param, $resulta])
							 $Servers($server_name).u_cmd([$vst_nodeID, 6, "/set", $vst_param_index, @to_char($resulta)]) // 6 = UGen id inside Synthdef

						   // gui_data $server_name $group $module $param $resulta
					}                       
						{ $val 	{ 	{ $init } @type := $type
						   $period { $end }  } 
						   }
		   }
	    }
	}
}

@obj_def saw_lfo_glob($r_low, $r_hi, $t, $dir) 
{
    @local $suscriber := MAP{}, $receive, $amp, $offset, $sin_proc, $grain, $period, $init, $end
    	@init 
		{
		    $amp := ($r_hi - $r_low)/2
		    $offset := $r_hi - $amp
		    $sin_proc := 0
		    $grain := 0.01
		    if ($dir == 1)
		    {
			$init := 0
			$end := 1
		    }
		    else
		    {
			$init := 1
				$end := 0
		    }
		    $period := (1/$t)
		    $THISOBJ.diffuse()
		}
		@fun_def add_suscriber($x, $f)
	    {
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name, $params, $method

			$method := @extract_method(""+$f)


			if ($method == "set")
			{
				// print es set 
				$params := @extract_command(""+$f)
				// @slice(""+$f, 12, 15)
				// print commande $params
				$int_name := $x.$track_name+$method+($params[0])+($params[1])

			}
			else
			{
				// print $method
				$int_name := $x.$track_name+$method

			}
			// print int_name $int_name
			$suscriber.add_pair($int_name, [$x, $f])

	  	}		
	  	@fun_def tpo($temp)
	  	{
			$period := (1/$temp)
	  	}	
		@fun_def minmax($mi, $ma)
	  	{
			$r_low := $mi
			$r_hi := $ma
	  	}	
	  	@fun_def unsuscribe($x, $n, $n1 = "module", $n2 = "param")
	  	{
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name := $x.$track_name+$n
			if($n == "set")
			{
				$int_name := $x.$track_name+$n+$n1+$n2
			}
			else
			{
				$int_name := $x.$track_name+$n
			}
			$suscriber.remove($int_name)
	  	}
	  	@proc_def diffuse()
		{
		    loop $period // @tempo := $t
		    {
				  abort $sin_proc
				  $sin_proc := {
						curve
						@grain := 0.01 //($grain * $period/60.)
						@action := {
							  
							forall $k, $v in $suscriber { _ := ($v[1])($v[0], $receive) }

						}                       
							{ $receive 	{ 	{ $init }
							   $period { $end }  } 
							}
			   }

		    }
		}
	@abort
	{
	 @clear($suscriber)
	}
}

@proc_def lfo_tri($group, $module, $param, $r_low, $r_hi, $t) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $val, $period, $sin_proc
	$period := (1/$t)

	loop $period
	{
		abort $sin_proc
		  $sin_proc := {
			curve @Grain := 0.005s, 
			@Action := {

				// n_set $module $param $val 
				$Servers($server_name).n_set($module, [$param, $val])
				gui_data $group $module $param $val

				}
			{
				$val
				{
								{ $r_low } /*@type "exp"*/
				$period * 0.5 	{ $r_hi  } 
				$period * 0.5 	{ $r_low }

				}
			}
		}
	}
}


@proc_def lfo_tri_s($server_name, $group, $module, $param, $r_low, $r_hi, $t, $type_in, $type_out) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $val, $period, $sin_proc := 0
	$period := (1/$t)

	loop $period
	{
		abort $sin_proc
		  $sin_proc := {
			curve @Grain := 0.005s, 
			@Action := {
				// @command($command) $x
						// @command("n_set"+$server_name) $module $param $val
						$Servers($server_name).n_set($module, [$param, $val])

						gui_data $server_name $group $module $param $val
				}
			{
				$val
				{
								{ $r_low } @type := $type_in
				$period * 0.5 	{ $r_hi  } @type := $type_out
				$period * 0.5 	{ $r_low }

				}
			}
		}
	}
}


@proc_def lfo_tri_vst($server_name, $vst_name, $vst_nodeID, $param, $r_low, $r_hi, $t, $type_in, $type_out) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $val, $period, $sin_proc := 0, $vst_param_index
	$period := (1/$t)

	if($vst_all_map($vst_name)("parameters").is_defined($param))
	{
		$vst_param_index := $vst_all_map($vst_name)("parameters")($param)
		loop $period
		{
			abort $sin_proc
			  $sin_proc := {
				curve @Grain := 0.005s, 
				@Action := {
					// @command($command) $x
							// @command("n_set"+$server_name) $module $param $val
							// $Servers($server_name).n_set($module, [$param, $val])
						  $Servers($server_name).u_cmd([$vst_nodeID, 6, "/set", $vst_param_index, @to_char($val)]) // 6 = UGen id inside Synthdef
							// gui_data $server_name $group $module $param $val
					}
				{
					$val
					{
									{ $r_low } @type := $type_in
					$period * 0.5 	{ $r_hi  } @type := $type_out
					$period * 0.5 	{ $r_low }

					}
				}
			}
		}
	}
}


@obj_def lfo_tri_glob($r_low, $r_hi, $t) 
{
	@local $suscriber := MAP{}, $receive, $period, $sin_proc
		@init 
		{
			$period := (1/$t)
			$THISOBJ.diffuse()
		}
		@fun_def add_suscriber($x, $f)
	    {
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name, $params, $method

			$method := @extract_method(""+$f)


			if ($method == "set")
			{
				// print es set 
				$params := @extract_command(""+$f)
				// @slice(""+$f, 12, 15)
				// print commande $params
				$int_name := $x.$track_name+$method+($params[0])+($params[1])

			}
			else
			{
				// print $method
				$int_name := $x.$track_name+$method

			}
			// print int_name $int_name
			$suscriber.add_pair($int_name, [$x, $f])

	  	}
	  	@fun_def tpo($temp)
	  	{
			$period := (1/$temp)
	  	}	
		@fun_def minmax($mi, $ma)
	  	{
			$r_low := $mi
			$r_hi := $ma
	  	}		 
		@fun_def unsuscribe($x, $n, $n1 = "module", $n2 = "param")
	  	{
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name := $x.$track_name+$n
			if($n == "set")
			{
				$int_name := $x.$track_name+$n+$n1+$n2
			}
			else
			{
				$int_name := $x.$track_name+$n
			}
			$suscriber.remove($int_name)
	  	}
		@proc_def diffuse()
		{	  		  	 	
			loop $period
			{
				// abort $sin_proc
				  $sin_proc := {
					curve @Grain := 0.005s, 
					@Action := {

							   forall $k, $v in $suscriber { _ := ($v[1])($v[0], $receive) }
						}
					{
						$receive
						{
										{ $r_low } /*@type "exp"*/
						$period * 0.5 	{ $r_hi  } 
						$period * 0.5 	{ $r_low }

						}
					}
				}
			}
		}
		@abort
		{
		 @clear($suscriber)
		}		
}


@proc_def ::brown_lfo_proc($module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print toto
}
{
	@local $v1, $v2, $duree, $curve_proc, $val, $curve_int_proc, $drunk_val, $delay

	$v1 := $init_val
	$v2 := @drunk($init_val, $min, $max, $drunk_step)
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5
	// $drunk_val := @drunk($drunk_val, -0.062, 1.813, $drunk_step)

	group @tempo := $tpo
	{
	Loop $delay @exclusive //@tempo := $tpo
	{
		abort $curve_int_proc

		$v1 := $v2
		$v2 := @drunk($v1, $min, $max, $drunk_step) //@rand_range($min, $max) // @rand($max-$min)+$min
		$delay := @rand(1.) + 0.5
		$duree := $delay

		$curve_int_proc := {  
			curve
			   // @tempo := $tpo
			   @Grain := 0.01 //0.01s 
			   @action :=  { 
				// print localsynthset $module $param $val 
					 // n_set $module $param $val 
					 $Servers($server_name).n_set($module, [$param, $val])
					 gui_data $group $module $param $val  
					 // brown_lfo $val
				    }

			   { $val {
					  {$v1} @type := $type
				  $duree {$v2} 
				  }
			   }
		    }
		}
	}
}

		  

@proc_def ::brown_lfo_proc_s($server_name, $group, $module, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $curve_proc, $val, $curve_int_proc, $drunk_val, $delay

	$v1 := $init_val
	$v2 := @drunk($init_val, $min, $max, $drunk_step)
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5
	// $drunk_val := @drunk($drunk_val, -0.062, 1.813, $drunk_step)

	group @tempo := $tpo
	{
	Loop $delay @exclusive //@tempo := $tpo
	{
		abort $curve_int_proc

		$v1 := $v2
		$v2 := @drunk($v1, $min, $max, $drunk_step) //@rand_range($min, $max) // @rand($max-$min)+$min
		$delay := @rand(1.) + 0.5
		$duree := $delay

		$curve_int_proc := {  
			curve
			   // @tempo := $tpo
			   @Grain := 0.01 //0.01s 
			   @action :=  { 
				// print localsynthset $module $param $val 
					 // n_set $module $param $val 
					 // @command("n_set"+$server_name) $module $param $val
					 $Servers($server_name).n_set($module, [$param, $val])
					 // if($gui)
					 // {
						gui_data $server_name $group $module $param $val
					// }
					  // print $server_name $group $module $param $val
				    }

			   { $val {
					  {$v1} @type := $type
				  $duree {$v2} 
				  }
			   }
		    }
		}
	}
}

@proc_def ::brown_lfo_proc_vst($server_name, $vst_name, $vst_nodeID, $param, $min, $max, $drunk_step, $init_val, $type, $tpo) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $curve_proc, $val, $curve_int_proc, $drunk_val, $delay

	$v1 := $init_val
	$v2 := @drunk($init_val, $min, $max, $drunk_step)
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5
	// $drunk_val := @drunk($drunk_val, -0.062, 1.813, $drunk_step)

	group @tempo := $tpo
	{
	Loop $delay @exclusive //@tempo := $tpo
	{
		abort $curve_int_proc

		$v1 := $v2
		$v2 := @drunk($v1, $min, $max, $drunk_step) //@rand_range($min, $max) // @rand($max-$min)+$min
		$delay := @rand(1.) + 0.5
		$duree := $delay

		$curve_int_proc := {  
			curve
			   // @tempo := $tpo
			   @Grain := 0.01 //0.01s 
			   @action :=  { 
				// print localsynthset $module $param $val 
					 // n_set $module $param $val 
					 // @command("n_set"+$server_name) $module $param $val
					 // $Servers($server_name).n_set($module, [$param, $val])
					 $Servers($server_name).u_cmd([$vst_nodeID, 6, "/set", $vst_param_index, @to_char($val)]) // 6 = UGen id inside Synthdef

					 // if($gui)
					 // {
						// gui_data $server_name $group $module $param $val
					// }
					  // print $server_name $group $module $param $val
				    }

			   { $val {
					  {$v1} @type := $type
				  $duree {$v2} 
				  }
			   }
		    }
		}
	}
}
// $toto := 6.6742e-11
// print (""+$toto)

@obj_def brown_lfo_glob($min, $max, $drunk_step, $init_val, $type, $tpo) 
{
	@local $suscriber := MAP{}, $receive, $v1, $v2, $duree, $curve_proc, $curve_int_proc, $drunk_val, $delay
	@init 
	{
		$v1 := $init_val
		$v2 := @drunk($init_val, $min, $max, $drunk_step)
		$curve_int_proc := 0

		$delay := @rand(1.) + 0.5
		// $drunk_val := @drunk($drunk_val, -0.062, 1.813, $drunk_step)
		$THISOBJ.diffuse()
	}
	@fun_def add_suscriber($x, $f)
    {
		// $suscriber := @cons([$x, $f], $suscriber)
		@local $int_name, $params, $method

		$method := @extract_method(""+$f)


		if ($method == "set")
		{
			// print es set 
			$params := @extract_command(""+$f)
			// @slice(""+$f, 12, 15)
			// print commande $params
			$int_name := $x.$track_name+$method+($params[0])+($params[1])

		}
		else
		{
			// print $method
			$int_name := $x.$track_name+$method

		}
		// print int_name $int_name
		$suscriber.add_pair($int_name, [$x, $f])

  	}	
	@fun_def tpo($temp)
  	{
		$tpo := $temp
  	}	  	
	@fun_def minmax($mi, $ma)
  	{
		$min := $mi
		$max := $ma
  	}	  	
	@fun_def unsuscribe($x, $n, $n1 = "module", $n2 = "param")
  	{
		// $suscriber := @cons([$x, $f], $suscriber)
		@local $int_name := $x.$track_name+$n
		if($n == "set")
		{
			$int_name := $x.$track_name+$n+$n1+$n2
		}
		else
		{
			$int_name := $x.$track_name+$n
		}
		$suscriber.remove($int_name)
  	}  	
	@proc_def diffuse()
	{  	
		group @tempo := $tpo
		{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @drunk($v1, $min, $max, $drunk_step) //@rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  
				curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 

							forall $k, $v in $suscriber { _ := ($v[1])($v[0], $receive) }

					    }

				   { $receive {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
			}
		}
	}
	@abort
	{
	 @clear($suscriber)
	}
}

@proc_def rand_lfo_basic($group, $module, $param, $min, $max, $init_val, $type, $tpo, $gui) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $val, $curve_int_proc, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.005 //0.01s 
				   @action :=  { 
					// print localsynthset $module $param $val 
						 // n_set $module $param $val 

							$Servers($server_name).n_set($module, [$param, $val])

						 gui_data $group $module $param $val
						 // if($gui) 
						 // {
						 // 	gui_data $group $module $param $val 
						 // }
					    }

				   { $val {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}

@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $val, $curve_int_proc, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay // @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.005 //0.01s 
				   @action :=  { 
					// print localsynthset $module $param $val 
						 // n_set $module $param $val 
						 // gui_data $group $module $param $val
						 // $param:= $val
						 $param($val) 
						 // print paramss (""+$param)

						 // print titi
						 // if($gui) 
						 // {
						 // 	gui_data $group $module $param $val 
						 // }
					    }

				   { $val {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}

@proc_def rand_lfo_basic_obj_v2($param, $min, $max, $init_val, $type, $tpo) 
@abort
{
	//TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $val, $curve_int_proc, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min

			$duree := $delay
			$delay := @rand(1.) + 0.5

			curve
			   // @tempo := $tpo
			   @Grain := 0.005 //0.01s 
			   @action :=  { 
				// print localsynthset $module $param $val 
					 // n_set $module $param $val 
					 // gui_data $group $module $param $val
					 // $param:= $val
					 $param($val) 
					 // print paramss (""+$param)

					 // print titi
					 // if($gui) 
					 // {
					 // 	gui_data $group $module $param $val 
					 // }
				    }

			   { $val {
					  {$v1} @type := $type
				  $duree {$v2} 
				  }
			   }
		}
	}
}


@global $jlg_count_rand := 0

@proc_def rand_lfo_basic_s($server_name, $group, $module, $param, $min, $max, $init_val, $type, $tpo, $min_interval = 0, $gui = false) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	$sc_struct($server_name)($module).add_pair($param, $val) 

	$jlg_count_rand -= 1
	print "--> reste " $jlg_count_rand
	abort $curve_int_proc
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $val, $curve_int_proc, $speedlim_actif := true, $speedlim_time := 0.1, $delay

	$jlg_count_rand += 1
	print "--> active rand " $jlg_count_rand


	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			if (@abs($v1 - $v2)< $min_interval) 
			{
				$v2 := $v2+$min_interval
			}
			$duree := $delay
			$delay := @rand(1.) + 0.5
			
						 // print v1 $v1
						 // print v2 $v2
						 // print duree_del $duree $delay
			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
					// print localsynthset $module $param $val 
						 // n_set $module $param $val 
						 // @command("n_set"+$server_name) $module $param $val
						 // scServer "n_set" $module $param $val
						 $Servers($server_name).n_set($module, [$param, $val])

						 // print rand_lfo_val $val

						 ///
						 if($gui)
						 {
						 	gui_data $server_name $group $module $param $val
						 }
						 

						 // if ($speedlim_actif) { //change dans Max
							
			    //  			$speedlim_actif := false
			    //  			($speedlim_time)s $speedlim_actif := true //speedlim                    
							// } 			           
						 // if($gui) 
						 // {
						 // 	gui_data $group $module $param $val 
						 // }
					    }

				   { $val {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
		+=>  print "curve"
	}
}


@proc_def rand_lfo_multi($res, $index, $min, $max, $init_val, $type, $tpo) 
{
   @local $v1, $v2, $duree, $val, $curve_int_proc, $delay

   $v1 := $init_val
   $v2 := $init_val
   $curve_int_proc := 0

   $delay := @rand(1.) + 0.5

   group @tempo := $tpo
   {
   Loop $delay @exclusive
   {
   abort $curve_int_proc

   $v1 := $v2
   $v2 := @rand_range($min, $max) // @rand($max-$min)+$min
   $delay := @rand(1.) + 0.5
   $duree := $delay

   $curve_int_proc := {  curve
      // @tempo := $tpo
      @Grain := 5 ms //0.01s 
      @action :=  { 
            $res[$index] := $val
         }

                  { $val {
                 {$v1} @type := $type
                 $duree {$v2} 
               }
            }
         }
      }
   }
}

@proc_def rand_lfo_multi($res, $index, $min, $max, $init_val, $type, $tpo) 
{
   @local $v1, $v2, $duree, $val, $curve_int_proc, $delay

   $v1 := $init_val
   $v2 := $init_val
   $curve_int_proc := 0

   $delay := @rand(1.) + 0.5

   group @tempo := $tpo
   {
   Loop $delay @exclusive
   {
   abort $curve_int_proc

   $v1 := $v2
   $v2 := @rand_range($min, $max) // @rand($max-$min)+$min
   $delay := @rand(1.) + 0.5
   $duree := $delay

   $curve_int_proc := {  curve
      // @tempo := $tpo
      @Grain := 5 ms //0.01s 
      @action :=  { 
            $res[$index] := $val
         }

                  { $val {
                 {$v1} @type := $type
                 $duree {$v2} 
               }
            }
         }
      }
   }
}
// for pvoc UGENS, avoid play buf after record position


@proc_def rand_lfo_dyn($server_name, $module, $param, $init_val, $type, $tpo, $ref_obj)
@abort
{
	abort $curve_int_proc
} 
{
   @local $v1, $v2, $duree, $val, $curve_int_proc, $min := 0.0, $pos, $delay

   $v1 := $init_val
   $pos := $ref_obj.$rec_pos
   $v2 := @rand_range_compiled($min, $pos)
   $curve_int_proc := 0

   $delay := 0.001
   $duree := $delay

   group @tempo := $tpo
   {
   Loop $delay @exclusive
   {
   abort $curve_int_proc
   	// print delay $delay
   	// print duree $duree
	$pos := $ref_obj.$rec_pos
	   $v1 := $v2
	   $v2 := @rand_range_compiled($min, $ref_obj.$rec_pos) // @rand($max-$min)+$min
	   if($pos == 0.0)
	   {
	   	   		$delay := 0.001
	   			$duree := $delay 
	   }
	   else
	   {
	   		$delay := @rand_range_compiled(0.8, 1.2)*$ref_obj.$rec_pos
	   		$duree := $delay 
	   }
   
            // print v1 $v1
            // print v2 $v2
            // print pos $pos
   $curve_int_proc := {  curve
      // @tempo := $tpo
      @Grain := 5 ms //0.01s 
      @action :=  { 
            // $res[$index] := $val

            // print val $val
            // print rec_pos ($ref_obj.$rec_pos)
            $Servers($server_name).n_set($module, [$param, $val])
         }

                  { $val {
                 		{$v1} @type := $type
                 $duree {$v2} 
               }
            }
         }

           
      }
   }
}
// @proc_def rand_lfo_basic($group, $module, $param, $min, $max, $init_val, $type, $tpo, $gui) 

@proc_def rand_lfo_dyn_bpf($server_name, $module, $param, $init_val, $bpf_end_val, $type, $tpo)
@abort
{
	abort $curve_int_proc
} 
{
   @local $v1, $v2, $duree, $val, $curve_int_proc, $min := 0.0, $pos, $delay, $nim, $x_interpol

	$nim := @build_nim_from_bpf($bpf_end_val)
	$end_val_interpol := $bpf_end_val[0]
	$last_bpf_amp_curve := { curve @grain := 0.01, 
		@action 
		{
			$pos := $end_val_interpol-$init_val
		} 
		{ $end_val_interpol : $nim }
		
	}

   $v1 := $init_val
   // $pos := $ref_obj.$rec_pos
   $v2 := @rand_range_compiled($min, $end_val_interpol)
   $curve_int_proc := 0

   $delay := 0.001
   $duree := $delay

   group @tempo := $tpo
   {
   Loop $delay @exclusive
   {
   abort $curve_int_proc
   	// print delay $delay
   	// print duree $duree
	// $pos := $ref_obj.$rec_pos
	   $v1 := $v2
	   $v2 := @rand_range_compiled($min, $end_val_interpol ) // @rand($max-$min)+$min
	   if($pos == 0.0)
	   {
	   	   		$delay := 0.001
	   			$duree := $delay 
	   }
	   else
	   {
	   		$delay := @rand_range_compiled(0.8, 1.2)*$pos
	   		$duree := $delay 
	   }
   
            // print v1 $v1
            // print v2 $v2
            // print pos $pos
   $curve_int_proc := {  curve
      // @tempo := $tpo
      @Grain := 5 ms //0.01s 
      @action :=  { 
            // $res[$index] := $val

            // print val $val
            // print rec_pos ($ref_obj.$rec_pos)
            $Servers($server_name).n_set($module, [$param, $val])
         }

                  { $val {
                 		{$v1} @type := $type
                 $duree {$v2} 
               }
            }
         }

           
      }
   }
}

@proc_def rand_lfo_vst($server_name, $vst_name, $vst_nodeID, $param, $min, $max, $init_val, $type, $tpo) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $val, $curve_int_proc, $vst_param_index, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5


	if($vst_all_map($vst_name)("parameters").is_defined($param))
	{
		$vst_param_index := $vst_all_map($vst_name)("parameters")($param)
		group @tempo := $tpo
		{
			Loop $delay @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$v1 := $v2
				$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
				$delay := @rand(1.) + 0.5
				$duree := $delay

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.01 //0.01s 
					   @action :=  { 
							 // $Servers($server_name).n_set($module, [$param, $val])
							 
							 $Servers($server_name).u_cmd([$vst_nodeID, 6, "/set", $vst_param_index, @to_char($val)]) // 6 = UGen id inside Synthdef

						    }

					   { $val {
							  {$v1} @type := $type
						  $duree {$v2} 
						  }
					   }
				    }
			}
		}
	}
	else
	{
		print the parameter $param doesn't exist in this pluging
	}
}

@proc_def rand_lfo_basic_pos_x($server_name, $group_id, $group_name, $min, $max, $init_val, $tpo, $type = "linear") 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $lpos, $curve_int_proc, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
						 $Servers($server_name).n_set($group_id, ["xoffset", $lpos]) // send directly to SCServer group
							let $space_group($server_name)($group_name)("xyz_offset")[0] := $lpos // store xyz position in map for oFx visualization
					    }

				   { $lpos {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}

@proc_def rand_lfo_basic_pos_y($server_name, $group_id, $group_name, $min, $max, $init_val, $tpo, $type = "linear") 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $lpos, $curve_int_proc, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
						 $Servers($server_name).n_set($group_id, ["yoffset", $lpos]) // send directly to SCServer group
							let $space_group($server_name)($group_name)("xyz_offset")[1] := $lpos // store xyz position in map for oFx visualization
					    }

				   { $lpos {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}


@proc_def rand_lfo_basic_pos_z($server_name, $group_id, $group_name, $min, $max, $init_val, $tpo, $type = "linear") 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $lpos, $curve_int_proc, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
						 $Servers($server_name).n_set($group_id, ["zoffset", $lpos]) // send directly to SCServer group
							let $space_group($server_name)($group_name)("xyz_offset")[2] := $lpos // store xyz position in map for oFx visualization
					    }

				   { $lpos {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}



@proc_def rand_lfo_basic_track_pos_x($server_name, $track_name, $mix_group, $min, $max, $init_val, $tpo, $type = "linear") 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $lpos, $curve_int_proc, $track_id, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	$track_id := $tracks($track_name).$node_id_out

	// $space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
						 $Servers($server_name).n_set($track_id, ["x", $lpos]) // send directly to SCServer group
							// let $space_group($server_name)($group_name)("xyz_offset")[0] := $lpos // store xyz position in map for oFx visualization
					    }

				   { $lpos {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}

@proc_def rand_lfo_basic_track_pos_y($server_name, $track_name, $mix_group, $min, $max, $init_val, $tpo, $type = "linear") 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $lpos, $curve_int_proc, $track_id, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5
	$track_id := $tracks($track_name).$node_id_out

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
						 $Servers($server_name).n_set($track_id, ["y", $lpos]) // send directly to SCServer group
							// let $space_group($server_name)($group_name)("xyz_offset")[1] := $lpos // store xyz position in map for oFx visualization
					    }

				   { $lpos {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}


@proc_def rand_lfo_basic_track_pos_z($server_name, $track_name, $mix_group, $min, $max, $init_val, $tpo, $type = "linear") 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $lpos, $curve_int_proc, $track_id, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5
	$track_id := $tracks($track_name).$node_id_out

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
						 $Servers($server_name).n_set($track_id, ["z", $lpos]) // send directly to SCServer group
							// let $space_group($server_name)($group_name)("xyz_offset")[2] := $lpos // store xyz position in map for oFx visualization
					    }

				   { $lpos {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}

@global $jlg_count_xyz := 0

@proc_def rand_lfo_track_pos_xyz($server_name, $track_name, $mix_group, $min_x, $max_x, $init_val_x, $min_y, $max_y, $init_val_y, $min_z, $max_z, $init_val_z, $tpo, $type = "linear") 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	$trajs.remove($proc_index)
	$jlg_count_xyz -= 1
	print "--> reste xyz " $jlg_count_xyz
}
{
	@local $v1_x, $v2_x, $v1_y, $v2_y, $v1_z, $v2_z, $pos_x, $pos_y, $pos_z, $duree, $current, $curve_proc, $lpos, $curve_int_proc, $track_id, $xyz := [0, 0, 0], $proc_index, $delay

	$jlg_count_xyz += 1
	print "--> xyz actif " $jlg_count_xyz


	$v1_x := $init_val_x
	$v2_x := $init_val_x
	$v1_y := $init_val_y
	$v2_y := $init_val_y
	$v1_z := $init_val_z
	$v2_z := $init_val_z	

	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5
	$track_id := $tracks($track_name).$node_id_out


	// oF visual
	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1_x := $v2_x
			$v2_x := @rand_range($min_x, $max_x) 
			
			$v1_y := $v2_y
			$v2_y := @rand_range($min_y, $max_y)

			$v1_z := $v2_z
			$v2_z := @rand_range($min_z, $max_z)

			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 

						$xyz[0] := $pos_x
							$xyz[1] := $pos_y
							$xyz[2] := $pos_z
						 $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x, "y", $xyz[1]+$HOA_global_y, "z", $xyz[2]+$HOA_global_z])		            

							// let $space_group($server_name)($group_name)("xyz_offset")[2] := $lpos // store xyz position in map for oFx visualization
					    }

				   { $pos_x, $pos_y, $pos_z {
						  {$v1_x, $v1_y, $v1_z} @type := $type
					  $duree {$v2_x, $v2_y, $v2_z} 
					  }
				   }
			    }
		}
	}
}

@proc_def global_xyz_rand_lfo($obj, $range, $tpo = 60, $type = "linear") // [min0,max0,init_val0, min1,max1,init_val1, min_n,max_n,init_val_n], tempo, type_interpol
{
  	@local $dae_list_pol := [], $proc_index, $xyz_list, $multi_tab, $tracks_list

  	$tracks_list := $obj.$tracks_tab
 //    if($track_proc($server_name)($mix_group)($track_name).is_defined($node_id_out+"_multi_lfo_track")) // si ça existe abort et refait
	// {
	// 	$THISOBJ.dae_rand_lfo_abort()
	// }
	$xyz_list := [0 | ($range.size()/3)]
	// $track_proc($server_name)($mix_group)($track_name).add_pair($node_id_out+"_multi_lfo_track", [ ::rand_lfo_multi($xyz_list, $i/3, $range[$i], $range[$i+1], $range[$i+2], $type, $tpo)  | $i in $range.size() : 3 ]) // instantie un le processus dans le dico
	// ::rand_lfo_multi($xyz_list, 0, $range[0], $range[1], $range[2], $type, $tpo) // range -> min, max, init_val
	 $multi_tab := [ ::rand_lfo_multi($xyz_list, $i/3, $range[$i], $range[$i+1], $range[$i+2], $type, $tpo)  | $i in $range.size() : 3 ]
	// $proc_index := $trajs_index
	// $trajs.add_pair($proc_index, $xyz_list)
	// $trajs_index += 1

	$int_loop := {
		loop  10ms  
		// @abort { print "===> loop killed" $track_name }
		{ 
			// print xyz_list (""+$xyz_list)
			// $dae_list_pol := @cartopol3D_tab($xyz_list)
			forall $trk in $tracks_list
			{
				$tracks($trk).HOA_global_track_xyz($xyz_list)
				$obj.global_xyz_rand_dist($xyz_list) // send back to objet
			}
			// $Servers($server_name).n_set($node_id_out, ["coords", $dae_list_pol]) 
			// $dae_list_cart := @poltocar3D_tab($dae_list)
			// $trajs.insert($proc_index, $xyz_list)
			// print dae_list_cart $dae_list_cart
		}
	}
}	

@proc_def rand_lfo_basic_x_y_z($min, $max, $init_val, $type, $tpo) 
@abort
{
  //TODO
  // $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
  @local $v1_1, $v2_1, $v1_2, $v2_2, $v1_3, $v2_3, $duree, $current, $curve_proc, $val1, $val2, $val3, $curve_int_proc, $delay

  $v1_1 := $init_val
  $v2_1 := $init_val

  $v1_2 := $init_val
  $v2_2 := $init_val

  $v1_3 := $init_val
  $v2_3 := $init_val

  $curve_int_proc := 0

  $delay := @rand(1.) + 0.5

  group @tempo := $tpo
  {
    Loop $delay @exclusive //@tempo := $tpo
    {
	 abort $curve_int_proc

	 $v1_1 := $v2_1
	 $v2_1 := @rand_range($min, $max) // @rand($max-$min)+$min
	  $v1_2 := $v2_2
	 $v2_2 := @rand_range($min, $max) // @rand($max-$min)+$min
	  $v1_3 := $v2_3
	 $v2_3 := @rand_range($min, $max) // @rand($max-$min)+$min

	 $delay := @rand(1.) + 0.5
	 $duree := $delay

	 $curve_int_proc := {  curve
		    // @tempo := $tpo
		    @Grain := 0.005 //0.01s 
		    @action :=  { 

				  $coords[0] := $val1
				  $update := 1
				  // concat_x $val1

				}

		    { $val1 {
				   {$v1_1} @type := $type
			   $duree {$v2_1} 
			   }
		    }

		    curve
		    // @tempo := $tpo
		    @Grain := 0.005 //0.01s 
		    @action :=  { 
			 // print localsynthset $module $param $val 
				  // n_set $module $param $val 
				  $coords[1] := $val2
				  // concat_y $val2

				}

		    { $val2 {
				   {$v1_2} @type := $type
			   $duree {$v2_2} 
			   }
		    }

		    curve
		    // @tempo := $tpo
		    @Grain := 0.005 //0.01s 
		    @action :=  { 
			 // print localsynthset $module $param $val 
				  // n_set $module $param $val 
				  $coords[2] := $val3
				  // concat_z $val3
		    // $Servers($server_name).n_set($module, [$param, $val])

		    //         gui_data $group $module $param $val
				  // if($gui) 
				  // {
				  //  gui_data $group $module $param $val 
				  // }
				}

		    { $val3 {
				   {$v1_3} @type := $type
			   $duree {$v2_3} 
			   }
		    }

		}
    }
  }
}
// $rand_lfo_glob_1 := 0

// @proc_def rand_lfo_glob_1($server_name, $group, $module, $param, $min, $max, $init_val, $type, $tpo, $gui) 
// @abort
// {
// 	// TODO
// 	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
// }
// {
// 	@local $v1, $v2, $duree, $val, $curve_int_proc

// 	$v1 := $init_val
// 	$v2 := $init_val
// 	$curve_int_proc := 0

// 	$delay := @rand(1.) + 0.5

// 	group @tempo := $tpo
// 	{
// 		Loop $delay @exclusive //@tempo := $tpo
// 		{
// 			abort $curve_int_proc

// 			$v1 := $v2
// 			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
// 			$delay := @rand(1.) + 0.5
// 			$duree := $delay

// 			$curve_int_proc := {  curve
// 			        // @tempo := $tpo
// 			        @Grain := 0.01 //0.01s 
// 			        @action :=  { 
// 			                 $rand_lfo_glob_1 := $val
// 			              }

// 			        { $val {
// 			                 {$v1} @type := $type
// 			            $duree {$v2} 
// 			            }
// 			        }
// 			    }
// 		}
// 	}
// }



@obj_def rand_lfo_glob($min, $max, $init_val, $type, $tpo)
{
   @local $listener, $receive, $v1, $v2, $duree, $val, $curve_int_proc, $delay

   @init {
	  $listener := MAP{}
	  // oscrecv osc $port $prefix $receive
	 $v1 := $init_val
	 $v2 := $init_val
	 $curve_int_proc := 0

	 $delay := @rand(1.) + 0.5

	 group @tempo := $tpo
	 {
	    Loop $delay @exclusive //@tempo := $tpo
	    {
		 abort $curve_int_proc

		  $v1 := $v2
		  $v2 := @rand_range(0.0, 1.0) // @rand($max-$min)+$min
		  $delay := @rand(1.) + 0.5
		  $duree := $delay

		  $curve_int_proc := {  curve
			    // @tempo := $tpo
			    @Grain := 0.01 //0.01s 
			    { $receive {
					   {$v1} @type := $type
				   $duree {$v2} 
				   }
			    }
			}
	    }
	  }
   }
  @whenever ($receive == $receive)
  {
	    // forall $obj in $listener
	 forall $k, $obj in $listener
	 {
		$obj.rand_lfo_glob($receive)
	 }
   }   
   @fun_def suscribe($obj)
   {
	   $listener.add_pair("ob"+$obj, $obj)
   }

   @fun_def unsuscribe($obj)
   {
	 // print $listener
	  $listener.remove("ob"+$obj)
	  // print $listener
   }
   @abort
   {
	 @clear($listener)
   }
}

@obj_def rand_lfo_glob2($min, $max, $init_val, $tpo = 60, $type = "linear")
{
   @local $suscriber := MAP{}, $curve_int_proc, $receive
		@init 
		{
			// $listener := MAP{}
			// oscrecv osc $port $prefix $receive
			$v1 := $init_val
			$v2 := $init_val
			$curve_int_proc := 0

			$delay := @rand(1.) + 0.5

			abort $curve_int_proc
			$THISOBJ.diffuse()
		}
		@fun_def add_suscriber($x, $f)
	   	{
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name, $params, $method

			$method := @extract_method(""+$f)


			if ($method == "set")
			{
				print es set 
				$params := @extract_command(""+$f)
				// @slice(""+$f, 12, 15)
				print commande $params
				$int_name := $x.$track_name+$method+($params[0])+($params[1])

			}
			else
			{
				print $method
				$int_name := $x.$track_name+$method

			}
			print int_name $int_name
			$suscriber.add_pair($int_name, [$x, $f])

	  	}
		@fun_def tpo($temp)
	  	{
			$tpo := $temp
	  	}	  
		@fun_def minmax($mi, $ma)
	  	{
			$min := $mi
			$max := $ma
	  	}		  		
		@fun_def unsuscribe($x, $n, $n1 = "module", $n2 = "param")
	  	{
			// $suscriber := @cons([$x, $f], $suscriber)
			@local $int_name := $x.$track_name+$n
			if($n == "set")
			{
				$int_name := $x.$track_name+$n+$n1+$n2
			}
			else
			{
				$int_name := $x.$track_name+$n
			}
			$suscriber.remove($int_name)
	  	}	  	 
		@proc_def diffuse()
		{
			$curve_int_proc := { 
				group @tempo := $tpo
				{
				 Loop $delay @exclusive //@tempo := $tpo
				 {
				

				  $v1 := $v2
				  $v2 := @rand_range(0.0, 1.0) // @rand($max-$min)+$min
				  $delay := @rand(1.) + 0.5
				  $duree := $delay

				   curve
					    // @tempo := $tpo
					    	@Grain := 0.01 //0.01s 
					    	@action :=  { 
					    		// forall $e in $suscriber { _ := ($e[1])($e[0], $receive) }
					    		forall $k, $v in $suscriber { _ := ($v[1])($v[0], $receive) }
					    	}
					    	{ $receive {
							   {$v1} @type := $type
						   $duree {$v2} 
						   }
					   }
					}
				}
			}
   	}
   @abort
   {
	 @clear($suscriber)
   }
}


// ::rand_lfo_glob_send($rand_lfo_instance, $server_name, $node_params)
@obj_def rand_lfo_glob_obj_send($rand_lfo_instance, $server_name, $node_params)
{
  @init {
	   $rand_lfo_instance.suscribe($THISOBJ)
   }
   @fun_def rand_lfo_glob($rand_lfo)
   {
	   ; handling a new data
	   // print ($rand_lfo )//(@scale($rand_lfo, 0, 1, $min, $max, 1))
	   // print tab_dim_tiotitoto ($node_params.dim() > 1)
	   if($node_params.dim() > 1)
	    {
		  forall $mods in $node_params
		  {
			$Servers($server_name).n_set($mods[0], [$mods[1], @scale_compiled($rand_lfo, 0, 1, $mods[2], $mods[3], 1)])       
		  }
	    }
	    else
	    {
		  $Servers($server_name).n_set($node_params[0], [$node_params[1], @scale_compiled($rand_lfo, 0, 1, $node_params[2], $node_params[3], 1)])
	    }
   }
   @abort {
	 $rand_lfo_instance.unsuscribe($THISOBJ)
	 // $osc_gest.unsuscribe($THISOBJ)
   }
}

// change_proc_tempo_rand_lfo_global($rand_lfo_global_1, 3000, 60)

@obj_def change_proc_tempo_rand_lfo_global($rand_lfo_instance, $obj, $tpo_min, $tpo_max)
{
  @init {
	   $rand_lfo_instance.suscribe($THISOBJ)
   }
   @fun_def rand_lfo_glob($rand_lfo)
   {
	   ; handling a new data
	   $obj.change_proc_tempo(@scale_compiled($rand_lfo, 0, 1, $tpo_min, $tpo_max, 1))
   }
   @abort {
	 $rand_lfo_instance.unsuscribe($THISOBJ)
	 // $osc_gest.unsuscribe($THISOBJ)
   }
}



// ::rand_lfo_glob_send($rand_lfo_instance, $server_name, $node_params)
// @obj_def rand_lfo_glob_obj_send_proc($rand_lfo_instance, $proc_name)
// {
//   @init {
//         $rand_lfo_instance.suscribe($THISOBJ)
//    }
//    @fun_def rand_lfo_glob($rand_lfo)
//    {
//         ; handling a new data
//         // print ($rand_lfo )//(@scale($rand_lfo, 0, 1, $min, $max, 1))

//         if($node_params.is_tab())
//          {
//             forall $mods in $node_params
//             {
//                $Servers($server_name).n_set($mods[0], [$mods[1], @scale_compiled($rand_lfo, 0, 1, $mods[2], $mods[3], 1)])       
//             }
//          }
//          else
//          {
//             $Servers($server_name).set($node_params[0], [$node_params[1], @scale_compiled($rand_lfo, 0, 1, $node_params[2], $node_params[3], 1)])
//          }
//    }
//    @abort {
//       $rand_lfo_instance.unsuscribe($THISOBJ)
//       // $osc_gest.unsuscribe($THISOBJ)
//    }
// }



@proc_def rand_lfo_mod_temp_s($server_name, $group, $module, $param, $min, $max, $init_val, $type, $gui) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $val, $curve_int_proc, $speedlim_actif := true, $speedlim_time := 0.1, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group //@tempo := $tpo
	{
		Loop $delay //@exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
					// print localsynthset $module $param $val 
						 // n_set $module $param $val 
						 // @command("n_set"+$server_name) $module $param $val
						 // scServer "n_set" $module $param $val
						 $Servers($server_name).n_set($module, [$param, $val])

						 gui_data $server_name $group $module $param $val

						 // if ($speedlim_actif) { //change dans Max
							
			    //  			$speedlim_actif := false
			    //  			($speedlim_time)s $speedlim_actif := true //speedlim                    
							// } 			           
						 // if($gui) 
						 // {
						 // 	gui_data $group $module $param $val 
						 // }
					    }

				   { $val {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}

@proc_def rand_lfo_basic_s_track($server_name, $group, $param, $min, $max, $init_val, $type, $tpo) 
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
}
{
	@local $v1, $v2, $duree, $current, $curve_proc, $val, $curve_int_proc, $speedlim_actif := true, $speedlim_time := 0.1, $delay

	$v1 := $init_val
	$v2 := $init_val
	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($min, $max) // @rand($max-$min)+$min
			$delay := @rand(1.) + 0.5
			$duree := $delay

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 

						 // @command("n_set"+$server_name) $group $param $val
						 $Servers($server_name).n_set($group, [$param, $val])

					    }

				   { $val {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			    }
		}
	}
}




$orbits := MAP{}
$orbits_index := 0

@proc_def ::ambi_orbit($server_name, $track_id, $angle, $grain)
@abort
{
	$orbits.remove($proc_index)
}
{
	@local $result := [1400000, 750000, 0.0, 8500], $obtit_xyz := [0, 0, 0], $proc_index, $scale

	$scale := 10000 * 100
	$proc_index := $orbits_index
	$orbits.add_pair($proc_index, $obtit_xyz)
	$orbits_index += 1
	

	Loop $grain
	{
		$result := @orbit_compiled($result[0], $result[1], $result[2], $result[3])
		$obtit_xyz[0] := $result[0] / $scale
		$obtit_xyz[1] := $result[1] / $scale

		$Servers($server_name).n_set($track_id, ["x", $obtit_xyz[0]+$HOA_global_x, "y", $obtit_xyz[1]+$HOA_global_y, "z", 0.0+$HOA_global_z])		            

		// print result $result
	}
}

$space_group := MAP{}
$space_group_index := 0

@proc_def ::ambi_orbit2($server_name, $track_id, $angle, $grain)
@abort
{
	$space_group.remove($proc_index)
}
{
	@local $result := [1400000, 750000, 0.0, 8500], $obtit_xyz := [0, 0, 0], $proc_index, $scale

	$scale := 10000 * 100
	$proc_index := $space_group_index
	$space_group.add_pair($proc_index, $obtit_xyz)
	$space_group_index += 1
	

	Loop $grain
	{
		$result := @orbit_compiled($result[0], $result[1], $result[2], $result[3])
		$obtit_xyz[0] := $result[0] / $scale
		$obtit_xyz[1] := $result[1] / $scale

		$Servers($server_name).n_set($track_id, ["x", $obtit_xyz[0]+$HOA_global_x, "y", $obtit_xyz[1]+$HOA_global_y, "z", 0.0+$HOA_global_z])		            

		// print result $result
	}
}


@proc_def ::orbit_traj($server_name, $track_id, $angle, $grain)
@abort
{
	$trajs.remove($proc_index)
}
{
	@local $result := [1400000, 750000, 0.0, 8500], $obtit_xyz := [0, 0, 0], $proc_index, $scale

	$scale := 10000 * 100
	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $obtit_xyz)
	$trajs_index += 1
	

	
	Loop $grain
	{
		$result := @orbit_compiled($result[0], $result[1], $result[2], $result[3])
		$obtit_xyz[0] := $result[0] / $scale
		$obtit_xyz[1] := $result[1] / $scale

		$Servers($server_name).n_set($track_id, ["x", $obtit_xyz[0]+$HOA_global_x, "y", $obtit_xyz[1]+$HOA_global_y, "z", 0.0+$HOA_global_z])		            

		// print result $result
	}
}

@proc_def ::orbit_traj2($server_name, $track_id, $angle, $grain)
@abort
{
	$trajs.remove($proc_index)
}
{
	@local $result := [1400000, 750000, 0.0, 8500], $obtit_xyz := [0, 0, 0], $proc_index, $scale

	$scale := 10000 * 100
	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $obtit_xyz)
	$trajs_index += 1
	

	
	Loop $grain
	{
		$result := @orbit_compiled($result[0], $result[1], $result[2], $result[3])
		$obtit_xyz[0] := $result[0] / $scale
		$obtit_xyz[1] := $result[1] / $scale

		// $Servers($server_name).n_set($track_id, ["x", $obtit_xyz[0]+$HOA_global_x, "y", $obtit_xyz[1]+$HOA_global_y, "z", 0.0+$HOA_global_z])	
		$Servers($server_name).n_set($track_id, ["coords", @cartopol3D_tab($obtit_xyz)])	
       // print cartopol3D
		// print result $result
	}
}

// @proc_def ::orbit_traj_vbap($server_name, $group, $module, $angle, $ele = 0, $grain)
// @abort
// {
// 	$trajs.remove($proc_index)
// }
// {
// 	@local $result := [1400000, 750000, 0.0, 8500], $obtit_xyz := [0, 0, 0], $proc_index, $scale, $car2pol3D := [0, 0, 0]

// 	$scale := 10000 * 100
// 	$proc_index := $trajs_index
// 	$trajs.add_pair($proc_index, $obtit_xyz)
// 	$trajs_index += 1
	
// 	Loop $grain
// 	{
// 		$result := @orbit_compiled($result[0], $result[1], $result[2], $result[3])
// 		$obtit_xyz[0] := $result[0] / $scale
// 		$obtit_xyz[1] := $result[1] / $scale
// 		$car2pol := @cartopol3D ($obtit_xyz[0], $obtit_xyz[1], $ele) //$r, $theta, $phi
// 		$Servers($server_name).n_set($module, ["azi", $car2pol[1], "ele", $ele]) 

// 		$Servers($server_name).n_set($track_id, ["x", $obtit_xyz[0]+$HOA_global_x, "y", $obtit_xyz[1]+$HOA_global_y, "z", 0.0+$HOA_global_z])		            

// 		// print result $result
// 	}
// }

// 	$tracks("track_test_noise1").ambi_rand_lfo_sphere(0.3, -200, 10, 0, 360, 0, 0, "linear", 120)

@proc_def ambi_rand_lfo_sphere($server_name, $track_name, $mix_group, $radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id, $host, $port, $descripteur, $scale) // $descripteur = ["Loudness"] ["Centroid"]
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print abort
	// $space_group.remove($proc_index)
}
{
	@local $v1, $v2, $v11, $v22, $duree, $current, $curve_proc, $theta, $phi, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $descp_node_id, $desc_val := 0, $track_bus_in, $track_id, $desc_id, $elev := 1, $params, $speedlim_actif := true, $speedlim_time := 0.01, $delay

	// print ambi_rand_lfo_sphere GO
	$v1 := $init_theta
	$v2 := $init_theta
	$v11 := $init_phi
	$v22 := $init_phi

	$Servers($server_name).notify(1) // for receive descriptors info

	// oscsend osc_send_rand_lfo_sphere @global "192.168.1.12" : 9999 //"192.168.1.12" : 9999// $host : $port // $host : $port //("/"+$name)

	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	$track_id := $tracks($track_name).$node_id_out
	$track_bus_in := $tracks($track_name).$bus
    $descp_node_id := $SC_Servers($server_name)("node_id") // last id

	$desc_id := $descp_node_id
	$params := $descripteur.cdr()



    $Servers($server_name).s_new([$descripteur[0]+"_Replay", $descp_node_id, 3, $track_id, "in", $track_bus_in, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
    // $decriptors_map($name).add_pair($descripteur[0], $descp_node_id)
    $descp_node_id += 1
    $SC_Servers($server_name).add_pair("node_id", $descp_node_id)   



	// $proc_index := $space_group_index
	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

    whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
    {           
	   // $desc_val := @scale($descriptors_receives[1][3], 0, 30, 0, 1, 1)

	   // $desc_val := @scale($descriptors_receives[1][3], 0.15, 0.30, 0, 0.4, 1)
	   $desc_val := @scale($descriptors_receives[1][3], $scale[0], $scale[1], $scale[2], $scale[3], $scale[4])

	   // $desc_val := $descriptors_receives[1][3] //@scale($descriptors_receives[1][3], 0, 30, 0, 1, 1)
    }	

					// 			if ($speedlim_actif) { //change dans Max
									
									// osc_send_rand_lfo_sphere ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))
						
								 //    $speedlim_actif := false
								 //    ($speedlim_time)s $speedlim_actif := true //speedlim                    
	    //      					}
    loop video 0.1
    {
	osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))
	// print flatt $desc_val

    }			

	group @tempo := ($period*$tempo_fac)
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($theta_min, $theta_max) 
			
			$v11 := $v22
			$v22 := @rand_range($phi_min, $phi_max)

			$delay := @rand(1.) + 0.5
			$duree := $delay
			
			// print radio $radio_res

			$curve_int_proc := {  curve
			   // @tempo := $tpo
			   @Grain := 0.01 //0.01s 
			   @action :=  { 
							$radio_res := $radio * $radio_fac
							$poltocar := @poltocar3D_compiled($radio_res , $theta, $phi)

								$xyz[0] := $poltocar[0]
								$xyz[1] := $poltocar[1]
								$xyz[2] := $poltocar[2]

								$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
								// test_pos1 $xyz


								// print send_rand_lfo_sphere (""+["/spatc/"+$id+"/xyzw",  $xyz.concat([$desc_val])])

					 // @command("n_set"+$server_name) $group $param $val
				    }

			   { $theta, $phi {
				  {$v1, $v11} @type := $type
				  $duree {$v2, $v22} 
				  }
			   }
		    }
		}
	}
}


@proc_def ambi_rand_lfo_sphere2($server_name, $track_id, $mix_group, $radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id, $host, $port)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print abort
	$trajs.remove($proc_index)
}
{
	@local $v1, $v2, $v11, $v22, $duree, $current, $curve_proc, $theta, $phi, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $delay

	// print ambi_rand_lfo_sphere GO
	$v1 := $init_theta
	$v2 := $init_theta
	$v11 := $init_phi
	$v22 := $init_phi

	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	// oscsend osc_send_rand_lfo_sphere @global "192.168.1.12" : 9999// $host : $port // $host : $port //("/"+$name)


	// $proc_index := $space_group_index
	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

	group @tempo := ($period*$tempo_fac)
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($theta_min, $theta_max) 
			
			$v11 := $v22
			$v22 := @rand_range($phi_min, $phi_max)

			$delay := @rand(1.) + 0.5
			$duree := $delay
			
			// print radio $radio_res

			$curve_int_proc := {  curve
			   // @tempo := $tpo
			   @Grain := 0.01 //0.01s 
			   @action :=  { 
							$radio_res := $radio * $radio_fac
							$poltocar := @poltocar3D_compiled($radio_res , $theta, $phi)

							$xyz[0] := $poltocar[0]
								$xyz[1] := $poltocar[1]
								$xyz[2] := $poltocar[2]

								$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
								// test_pos1 $xyz
								// osc_send_rand_lfo_sphere ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))
								// print (""+("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)])))

					 // @command("n_set"+$server_name) $group $param $val
				    }

			   { $theta, $phi {
				  {$v1, $v11} @type := $type
				  $duree {$v2, $v22} 
				  }
			   }
		    }
		}
	}
}

@proc_def ambi_rand_lfo_sphere_ste($server_name, $track_id, $mix_group, $radio, $theta_min, $theta_max, $phi_min, $phi_max, $init_theta, $init_phi, $type, $period, $id, $host, $port)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print abort
	$trajs.remove($proc_index)
}
{
	@local $v1, $v2, $v11, $v22, $v1_2, $v2_2, $v11_2, $v22_2, $duree, $current, $curve_proc, $theta, $phi, $curve_int_proc, $poltocar, $poltocar_2, $proc_index, $xyz := [0, 0, 0], $xyz_2 := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $delay

	// print ambi_rand_lfo_sphere GO
	$v1 := $init_theta
	$v2 := $init_theta
	$v11 := $init_phi
	$v22 := $init_phi

	$v1_2 := $init_theta
	$v2_2 := $init_theta
	$v11_2 := $init_phi
	$v22_2 := $init_phi	

	$curve_int_proc := 0

	$delay := @rand(1.) + 0.5

	// $proc_index := $trajs_index
	// $trajs.add_pair($proc_index, $xyz)
	// $trajs_index += 1

	// oscsend osc_send_rand_lfo_sphere @global "192.168.1.12" : 9999// $host : $port // $host : $port //("/"+$name)


	// $proc_index := $space_group_index
	// $space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

	group @tempo := ($period*$tempo_fac)
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$v1 := $v2
			$v2 := @rand_range($theta_min, $theta_max) 
			$v1_2 := $v2_2
			$v2_2 := @rand_range($theta_min, $theta_max) 			
			
			$v11 := $v22
			$v22 := @rand_range($phi_min, $phi_max)
			$v11_2 := $v22_2
			$v22_2 := @rand_range($phi_min, $phi_max)			

			$delay := @rand(1.) + 0.5
			$duree := $delay
			
			// print radio $radio_res

			$curve_int_proc := {  curve
			   // @tempo := $tpo
			   @Grain := 0.01 //0.01s 
			   @action :=  { 
							$radio_res := $radio * $radio_fac
							$poltocar := @poltocar3D_compiled($radio_res , $theta, $phi)
							$poltocar_2 := @poltocar3D_compiled($radio_res , $theta_2, $phi_2)

							$xyz[0] := $poltocar[0]
							$xyz[1] := $poltocar[1]
							$xyz[2] := $poltocar[2]

							$xyz_2[0] := $poltocar_2[0]
							$xyz_2[1] := $poltocar_2[1]
							$xyz_2[2] := $poltocar_2[2]

							$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z, "x1", $xyz_2[0]+$HOA_global_x+$HOA_local_x, "y1", $xyz_2[1]+$HOA_global_y+$HOA_local_y, "z1", $xyz_2[2]+$HOA_global_z+$HOA_local_z])		            
							// test_pos1 $xyz
							// osc_send_rand_lfo_sphere ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))
							// print (""+("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)])))

					 // @command("n_set"+$server_name) $group $param $val
				    }

			   { $theta, $phi, $theta_2, $phi_2 {
				  {$v1, $v11, $v1_2, $v11_2} @type := $type
				  $duree {$v2, $v22, $v2_2, $v22_2} 
				  }
			   }
		    }
		}
	}
}


@proc_def source_pol_traj($server_name, $track_id, $mix_group, $dir, $duree, $radio, $theta, $start_pos, $end_pos, $period, $type, $loop)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print abort
	// $space_group.remove($proc_index)
}
{
	@local $v1, $v2, $v11, $v22, $current, $curve_proc, $phi, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $inc := 0

	// $v1 := $init_theta
	// $v2 := $init_theta
	// $v11 := $init_phi
	// $v22 := $init_phi
	// print new_traj

	$curve_int_proc := 0

	// $delay := @rand(1.) + 0.5


	// $proc_index := $space_group_index
	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

	group @tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			// $v1 := $v2
			// $v2 := @rand_range($theta_min, $theta_max) 
			
			// $v11 := $v22
			// $v22 := @rand_range($phi_min, $phi_max)

			// $delay := @rand(1.) + 0.5
			// $duree := $delay
			
			// print radio $radio_res

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
								$poltocar := @poltocar3D_compiled($radio_res , $theta-90, ($phi*$dir*-1-90))

								$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]

									$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
									print xyz (""+$xyz)
									test_pos1 $xyz

						 // @command("n_set"+$server_name) $group $param $val
					    }

				   { $phi {
					  {$start_pos} @type := $type
					  $duree {$end_pos} 
					  }
				   }
			    }
			$inc += 1
		} until ($inc >= $loop)
	}
}


// ::source_cart_traj($server_name, $node_id_out, $mix_group, $duree, $x, $y, $z, $type, $loop))

@proc_def source_cart_traj($server_name, $track_id, $mix_group, $duree, $x, $y, $z, $type, $loop)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort" "abort" "abort" "abort"
	// $space_group.remove($proc_index)
	$space_group($server_name)($mix_group)("val").remove($track_id)
}
{
	@local $l_x, $l_y, $l_z, $nim_x, $nim_y, $nim_z, $last_bpf_x_curve, $last_bpf_y_curve, $last_bpf_z_curve, $current, $curve_proc, $phi, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $inc := 0

	// print new_traj

	// $curve_int_proc := 0

	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)

	if($x.is_tab())
	{
		$nim_x := @build_nim_from_bpf($x)
		// .CheckParam($module, $param, $MYSELF)
		$l_x := $x[0]
		$last_bpf_x_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[0] := $l_x
				$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x])
			} 
			{ $l_x : $nim_x }
		}
	$group_proc($server_name)($mix_group).add_pair("x", $last_bpf_x_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[0] := $x
		$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x])
	}

	if($y.is_tab())
	{
		$nim_y := @build_nim_from_bpf($y)
		// .CheckParam($module, $param, $MYSELF)
		$l_y := $y[0]
		$last_bpf_y_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_y])
				$xyz[1] := $l_y
				$Servers($server_name).n_set($track_id, ["y", $xyz[1]+$HOA_global_y+$HOA_local_y])
			} 
			{ $l_y : $nim_y }
		}
	$group_proc($server_name)($mix_group).add_pair("y", $last_bpf_y_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[1] := $y
		$Servers($server_name).n_set($track_id, ["y", $xyz[0]+$HOA_global_y+$HOA_local_y])
	}	

	if($z.is_tab())
	{
		$nim_z := @build_nim_from_bpf($z)
		// .CheckParam($module, $param, $MYSELF)
		$l_z := $z[0]
		$last_bpf_z_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[2] := $l_z
				$Servers($server_name).n_set($track_id, ["z", $xyz[2]+$HOA_global_z+$HOA_local_z])
			} 
			{ $l_z : $nim_z }
		}
	$group_proc($server_name)($mix_group).add_pair("z", $last_bpf_z_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[2] := $z
		$Servers($server_name).n_set($track_id, ["z", $xyz[2]+$HOA_global_z+$HOA_local_z])
	}	

}

@proc_def source_cart_traj_xyz2($server_name, $track_id, $mix_group, $duree, $x, $y, $z, $type, $loop)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort" "abort" "abort" "abort"
	// $space_group.remove($proc_index)
	$space_group($server_name)($mix_group)("val").remove($track_id)
}
{
	@local $l_x, $l_y, $l_z, $nim_x, $nim_y, $nim_z, $last_bpf_x_curve, $last_bpf_y_curve, $last_bpf_z_curve, $current, $curve_proc, $phi, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $inc := 0

	// print new_traj

	// $curve_int_proc := 0

	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)

	if($x.is_tab())
	{
		$nim_x := @build_nim_from_bpf($x)
		// .CheckParam($module, $param, $MYSELF)
		$l_x := $x[0]
		$last_bpf_x_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[0] := $l_x
				$Servers($server_name).n_set($track_id, ["x1", $xyz[0]+$HOA_global_x+$HOA_local_x])
			} 
			{ $l_x : $nim_x }
		}
	$group_proc($server_name)($mix_group).add_pair("x1", $last_bpf_x_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[0] := $x
		$Servers($server_name).n_set($track_id, ["x1", $xyz[0]+$HOA_global_x+$HOA_local_x])
	}

	if($y.is_tab())
	{
		$nim_y := @build_nim_from_bpf($y)
		// .CheckParam($module, $param, $MYSELF)
		$l_y := $y[0]
		$last_bpf_y_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_y])
				$xyz[1] := $l_y
				$Servers($server_name).n_set($track_id, ["y1", $xyz[1]+$HOA_global_y+$HOA_local_y])
			} 
			{ $l_y : $nim_y }
		}
	$group_proc($server_name)($mix_group).add_pair("y1", $last_bpf_y_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[1] := $y
		$Servers($server_name).n_set($track_id, ["y1", $xyz[0]+$HOA_global_y+$HOA_local_y])
	}	

	if($z.is_tab())
	{
		$nim_z := @build_nim_from_bpf($z)
		// .CheckParam($module, $param, $MYSELF)
		$l_z := $z[0]
		$last_bpf_z_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[2] := $l_z
				$Servers($server_name).n_set($track_id, ["z1", $xyz[2]+$HOA_global_z+$HOA_local_z])
			} 
			{ $l_z : $nim_z }
		}
	$group_proc($server_name)($mix_group).add_pair("z1", $last_bpf_z_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[2] := $z
		$Servers($server_name).n_set($track_id, ["z1", $xyz[2]+$HOA_global_z+$HOA_local_z])
	}	

}

@proc_def source_cart_traj2($server_name, $track_id, $mix_group, $duree, $x, $y, $z, $type, $loop)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort" "abort" "abort" "abort"
	// $space_group.remove($proc_index)
	$space_group($server_name)($mix_group)("val").remove($track_id)

}
{
	@local $l_x, $l_y, $l_z, $nim_x, $nim_y, $nim_z, $last_bpf_x_curve, $last_bpf_y_curve, $last_bpf_z_curve, $current, $curve_proc, $phi, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $inc := 0

	// print new_traj

	// $curve_int_proc := 0

	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)

	if($x.is_tab())
	{
		$nim_x := @build_nim_from_bpf($x)
		// .CheckParam($module, $param, $MYSELF)
		$l_x := $x[0]
		$last_bpf_x_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[0] := $l_x
				$Servers($server_name).n_set($track_id, ["x1", $xyz[0]+$HOA_global_x+$HOA_local_x])
			} 
			{ $l_x : $nim_x }
		}
	$group_proc($server_name)($mix_group).add_pair("x1", $last_bpf_x_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[0] := $x
		$Servers($server_name).n_set($track_id, ["x1", $xyz[0]+$HOA_global_x+$HOA_local_x])
	}

	if($y.is_tab())
	{
		$nim_y := @build_nim_from_bpf($y)
		// .CheckParam($module, $param, $MYSELF)
		$l_y := $y[0]
		$last_bpf_y_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_y])
				$xyz[1] := $l_y
				$Servers($server_name).n_set($track_id, ["y1", $xyz[1]+$HOA_global_y+$HOA_local_y])
			} 
			{ $l_y : $nim_y }
		}
	$group_proc($server_name)($mix_group).add_pair("y1", $last_bpf_y_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[1] := $y
		$Servers($server_name).n_set($track_id, ["y1", $xyz[0]+$HOA_global_y+$HOA_local_y])
	}	

	if($z.is_tab())
	{
		$nim_z := @build_nim_from_bpf($z)
		// .CheckParam($module, $param, $MYSELF)
		$l_z := $z[0]
		$last_bpf_z_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[2] := $l_z
				$Servers($server_name).n_set($track_id, ["z1", $xyz[2]+$HOA_global_z+$HOA_local_z])
			} 
			{ $l_z : $nim_z }
		}
	$group_proc($server_name)($mix_group).add_pair("z1", $last_bpf_z_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[2] := $z
		$Servers($server_name).n_set($track_id, ["z1", $xyz[2]+$HOA_global_z+$HOA_local_z])
	}	

}


@proc_def pol_traj_bpf($server_name, $track_id, $mix_group, $pol_bpf) // from bach spat slot
{
	@local $nim, $nim_r, $phi, $last_bpf_pol_bpf_curve, $last_bpf_r_curve, $poltocar, $radio_res, $radio_tab, $azi_tab, $elev := 1, $theta := 1, $xyz := [0, 0, 0]

	$radio_tab := $pol_bpf[0]
	$azi_tab := $pol_bpf[1]

	if($radio_tab.is_tab())
	{
		$nim_r := @build_nim_from_bpf($radio_tab)
		// .CheckParam($module, $param, $MYSELF)
		$radio_res := $radio_tab[0]
		$last_bpf_r_curve := { curve @grain := 0.01
			
			{ $radio_res : $nim_r }
		}	
	}
	else
	{
		print "not tab"
	}

    // loop video 0.1
    // {
    // 	osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))
    // 	// print flatt $desc_val

    // }	
	if($azi_tab.is_tab()) // if $val is bpf
	{
		$nim := @build_nim_from_bpf($azi_tab)
		// .CheckParam($module, $param, $MYSELF)
		$phi := $azi_tab[0]
		$last_bpf_pol_bpf_curve := { curve @grain := 0.01, 
			@action 
			{
				$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, $phi-90)
			   $xyz[0] := $poltocar[0]
				$xyz[1] := $poltocar[1]
				$xyz[2] := $poltocar[2]

				// print $phi
				$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x, "y", $xyz[1]+$HOA_global_y, "z", $xyz[2]+$HOA_global_z])		            
			} 
			{ $phi : $nim }
		}
	}
	else
	{
		print "not tab"
	}
}

@proc_def pol_traj_bpf2($server_name, $track_name, $mix_group, $pol_bpf, $id, $descripteur = ["Loudness"]) // from bach spat slot
{
	@local $nim, $nim_r, $phi, $last_bpf_pol_bpf_curve, $last_bpf_r_curve, $poltocar, $radio_res, $radio_tab, $azi_tab, $elev := 1, $theta := 1, $xyz := [0, 0, 0], $track_id, $track_bus_in, $descp_node_id, $desc_id, $params, $desc_val := 0

	$radio_tab := $pol_bpf[0]
	$azi_tab := $pol_bpf[1]

	$Servers($server_name).notify(1)

	$track_id := $tracks($track_name).$node_id_out
	$track_bus_in := $tracks($track_name).$bus
	$descp_node_id := $SC_Servers($server_name)("node_id") // last id
	$desc_id := $descp_node_id
	$params := $descripteur.cdr()

	$Servers($server_name).s_new([$descripteur[0]+"_Replay", $descp_node_id, 3, $track_id, "in", $track_bus_in, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id

	$descp_node_id += 1
	$SC_Servers($server_name).add_pair("node_id", $descp_node_id)	

	whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
	{			
		$desc_val := @scale($descriptors_receives[1][3], 0, 30, 0, 1, 1)
		// print desc_val $desc_val
	}

	if($radio_tab.is_tab())
	{
		$nim_r := @build_nim_from_bpf($radio_tab)
		// .CheckParam($module, $param, $MYSELF)
		$radio_res := $radio_tab[0]
		$last_bpf_r_curve := { curve @grain := 0.01
			
			{ $radio_res : $nim_r }
		}	
	}
	else
	{
		print "not tab"
	}

    // loop video 0.1
    // {
    // 	osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))
    // 	// print flatt $desc_val

    // }	
	if($azi_tab.is_tab()) // if $val is bpf
	{
		$nim := @build_nim_from_bpf($azi_tab)
		// .CheckParam($module, $param, $MYSELF)
		$phi := $azi_tab[0]
		$last_bpf_pol_bpf_curve := { curve @grain := 0.01, 
			@action 
			{
				$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, $phi-90)
			   $xyz[0] := $poltocar[0]
				$xyz[1] := $poltocar[1]
				$xyz[2] := $poltocar[2]

				// print $phi
				$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x, "y", $xyz[1]+$HOA_global_y, "z", $xyz[2]+$HOA_global_z])		            

				osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))

			} 
			{ $phi : $nim }
		}
	}
	else
	{
		print "not tab"
	}
}


@proc_def source_cart_traj_bpf($server_name, $track_id, $mix_group, $x, $y, $z, $loop = 0)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort" "abort" "abort" "abort"
	// $space_group.remove($proc_index)
	$space_group($server_name)($mix_group)("val").remove($track_id)

}
{
	@local $l_x, $l_y, $l_z, $nim_x, $nim_y, $nim_z, $last_bpf_x_curve, $last_bpf_y_curve, $last_bpf_z_curve, $current, $curve_proc, $phi, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $inc := 0

	// print new_traj

	// $curve_int_proc := 0

	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)

	if($x.is_tab())
	{
		$nim_x := @build_nim_from_bpf($x)
		// .CheckParam($module, $param, $MYSELF)
		$l_x := $x[0]
		$last_bpf_x_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[0] := $l_x
				$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x])
			} 
			{ $l_x : $nim_x }
		}
	$group_proc($server_name)($mix_group).add_pair("x", $last_bpf_x_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[0] := $x
		$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x])
	}

	if($y.is_tab())
	{
		$nim_y := @build_nim_from_bpf($y)
		// .CheckParam($module, $param, $MYSELF)
		$l_y := $y[0]
		$last_bpf_y_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_y])
				$xyz[1] := $l_y
				$Servers($server_name).n_set($track_id, ["y", $xyz[1]+$HOA_global_y+$HOA_local_y])
			} 
			{ $l_y : $nim_y }
		}
	$group_proc($server_name)($mix_group).add_pair("y", $last_bpf_y_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[1] := $y
		$Servers($server_name).n_set($track_id, ["y", $xyz[1]+$HOA_global_y+$HOA_local_y])
	}	

	if($z.is_tab())
	{
		$nim_z := @build_nim_from_bpf($z)
		// .CheckParam($module, $param, $MYSELF)
		$l_z := $z[0]
		$last_bpf_z_curve := { curve @grain := 0.01, 
			@action 
			{
				// $Servers($server_name).n_set($node_id_out, ["amp", $l_x])
				$xyz[2] := $l_z
				$Servers($server_name).n_set($track_id, ["z", $xyz[2]+$HOA_global_z+$HOA_local_z])
			} 
			{ $l_z : $nim_z }
		}
	$group_proc($server_name)($mix_group).add_pair("z", $last_bpf_z_curve) // store curve in map to avoid interference between different groups
	
	}
	else
	{
		$xyz[2] := $z
		$Servers($server_name).n_set($track_id, ["z", $xyz[2]+$HOA_global_z+$HOA_local_z])
	}	

}


@proc_def source_elevation_traj($server_name, $track_id, $mix_group, $dir, $duree, $radio, $phi, $start_pos, $end_pos, $period, $type, $loop)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print abort
	// $space_group.remove($proc_index)
}
{
	@local $v1, $v2, $v11, $v22, $current, $curve_proc, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0

	// $v1 := $init_theta
	// $v2 := $init_theta
	// $v11 := $init_phi
	// $v22 := $init_phi
	// print new_traj

	$curve_int_proc := 0

	// $delay := @rand(1.) + 0.5


	// $proc_index := $space_group_index
	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

	group @tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			// $v1 := $v2
			// $v2 := @rand_range($theta_min, $theta_max) 
			
			// $v11 := $v22
			// $v22 := @rand_range($phi_min, $phi_max)

			// $delay := @rand(1.) + 0.5
			// $duree := $delay
			
			// print radio $radio_res

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
								$poltocar := @poltocar3D_compiled($radio_res, ($theta*$dir)-90, ($phi*-1)-90)

								$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]

									$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
									print xyz (""+$xyz)
									test_pos1 $xyz

						 // @command("n_set"+$server_name) $group $param $val
					    }

				   { $theta {
					  {$start_pos} @type := $type
					  $duree {$end_pos} 
					  }
				   }
			    }
			$inc += 1			    
		} until ($inc >= $loop)
	}
}

	// @fun_def hoa_pol_rotation($duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $dir = 1) 
		 // :hoa_pol_rotation($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $id)
@proc_def hoa_pol_rotation($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $id, $descripteur = ["Loudness"])
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print "abort"

	// $space_group.remove($proc_index)
}
{
	@local $phi, $theta, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $track_id, $desc_id, $elev := 1, $params

	// $v1 := $init_theta
	// $v2 := $init_theta
	// $v11 := $init_phi
	// $v22 := $init_phi
	// print new_traj

	$Servers($server_name).notify(1)

	// oscsend osc_send_descriptors @global "192.168.1.12" : 9999 // $host : $port //("/"+$name)

	$track_id := $tracks($track_name).$node_id_out

	// print track_id $track_id	


	$track_bus_in := $tracks($track_name).$bus

	// print track_bus $track_bus_in	

	$descp_node_id := $SC_Servers($server_name)("node_id") // last id

	$desc_id := $descp_node_id

	$curve_int_proc := 0
	$params := $descripteur.cdr()

	$Servers($server_name).s_new([$descripteur[0]+"_Replay", $descp_node_id, 3, $track_id, "in", $track_bus_in, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
	// $decriptors_map($name).add_pair($descripteur[0], $descp_node_id)
	$descp_node_id += 1
	$SC_Servers($server_name).add_pair("node_id", $descp_node_id)	




	// $delay := @rand(1.) + 0.5


	// $proc_index := $space_group_index
	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

	whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
	{			
		// print receive_descript (""+$descriptors_receives)
		// osc_send_descriptors ([$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor value
		// osc_send_descriptors (("/" + $name + $descriptors_receives[1][0]) + " " + $descriptors_receives[1][3]) "" // prefix includes the data = /$name, data = /descriptor values
		// osc_send_descriptors ("/" + $name + $descriptors_receives[1][0]) ($descriptors_receives[1][3]) // prefix includes the data = /$name, data = /descriptor values

		$desc_val := @scale($descriptors_receives[1][3], 0, 30, 0, 1, 1)

		// print desc_val $desc_val
	}	

	group //@tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
							 $poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

								$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]

									$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
									// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
									// test_pos1 $xyz
									osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))

									// print (""+[("/spatc/"+$id+"/xyzw"), ($xyz.concat([$desc_val]))])

						 // @command("n_set"+$server_name) $group $param $val
					    }

				   { $phi, $theta {
					  {$start_angle, $start_elev} //@type := $type
					  $duree {$end_angle, $end_elev} 
					  }
				   }
			    }
			$inc += 1			    
		} //until ($inc >= $loop)
	}
}

// no descriptor
@proc_def hoa_pol_rota($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $id)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	$trajs.remove($proc_index)
	print "abort"

	// 
}
{
	@local $phi, $theta, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $track_id, $desc_id, $elev := 1, $params

	// $v1 := $init_theta
	// $v2 := $init_theta
	// $v11 := $init_phi
	// $v22 := $init_phi
	// print new_traj

	// oF visual
	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	// oscsend osc_send_descriptors @global "192.168.1.12" : 9999 // $host : $port //("/"+$name)

	$track_id := $tracks($track_name).$node_id_out

	// print track_id $track_id	


	$track_bus_in := $tracks($track_name).$bus

	// print track_bus $track_bus_in	

	$curve_int_proc := 0

	// $delay := @rand(1.) + 0.5


	// $proc_index := $space_group_index
	// $space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1
	

	group //@tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
							 $poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

								$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]

									$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
									// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
									// test_pos1 $xyz
									// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))

									// print (""+[("/spatc/"+$id+"/xyzw"), ($xyz.concat([$desc_val]))])

						 // @command("n_set"+$server_name) $group $param $val
					    }

				   { $phi, $theta {
					  {$start_angle, $start_elev} //@type := $type
					  $duree {$end_angle, $end_elev} 
					  }
				   }
			    }
			$inc += 1			    
		} //until ($inc >= $loop)
	}
}

@proc_def source_comete($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id, $descripteur = ["Loudness"])
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print "abort"

	// $space_group.remove($proc_index)
}
{
	@local $phi, $theta, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $track_id, $desc_id, $elev := 1, $params

	// $v1 := $init_theta
	// $v2 := $init_theta
	// $v11 := $init_phi
	// $v22 := $init_phi
	// print new_traj

	$Servers($server_name).notify(1)

	// oscsend osc_send_descriptors @global "192.168.1.12" : 9999 // $host : $port //("/"+$name)

	$track_id := $tracks($track_name).$node_id_out

	// print track_id $track_id	


	$track_bus_in := $tracks($track_name).$bus

	// print track_bus $track_bus_in	

	$descp_node_id := $SC_Servers($server_name)("node_id") // last id

	$desc_id := $descp_node_id

	$curve_int_proc := 0
	$params := $descripteur.cdr()

	$Servers($server_name).s_new([$descripteur[0]+"_Replay", $descp_node_id, 3, $track_id, "in", $track_bus_in, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
	// $decriptors_map($name).add_pair($descripteur[0], $descp_node_id)
	$descp_node_id += 1
	$SC_Servers($server_name).add_pair("node_id", $descp_node_id)	




	// $delay := @rand(1.) + 0.5


	// $proc_index := $space_group_index
	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

	whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
	{			
		// print receive_descript (""+$descriptors_receives)
		// osc_send_descriptors ([$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor value
		// osc_send_descriptors (("/" + $name + $descriptors_receives[1][0]) + " " + $descriptors_receives[1][3]) "" // prefix includes the data = /$name, data = /descriptor values
		// osc_send_descriptors ("/" + $name + $descriptors_receives[1][0]) ($descriptors_receives[1][3]) // prefix includes the data = /$name, data = /descriptor values

		$desc_val := @scale($descriptors_receives[1][3], 0, 30, 0, 1, 1)

		// print desc_val $desc_val
	}	

	group @tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			// $v1 := $v2
			// $v2 := @rand_range($theta_min, $theta_max) 
			
			// $v11 := $v22
			// $v22 := @rand_range($phi_min, $phi_max)

			// $delay := @rand(1.) + 0.5
			// $duree := $delay
			
			// print radio $radio_res

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
							 $poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

								$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]

									$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
									// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
									// test_pos1 $xyz
									osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))

									// print (""+[("/spatc/"+$id+"/xyzw"), ($xyz.concat([$desc_val]))])

						 // @command("n_set"+$server_name) $group $param $val
					    }

				   { $phi, $theta {
					  {$start_angle, $start_elev} @type := $type
					  $duree {$end_angle, $end_elev} 
					  }
				   }
			    }
			$inc += 1			    
		} until ($inc >= $loop)
	}
}


@proc_def source_comete_solo($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print "abort"

	// $space_group.remove($proc_index)
}
{
	@local $phi, $theta, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $track_id, $desc_id, $elev := 1, $params

	// $v1 := $init_theta
	// $v2 := $init_theta
	// $v11 := $init_phi
	// $v22 := $init_phi
	// print new_traj

	// $Servers($server_name).notify(1)

	// oscsend osc_send_descriptors @global "192.168.1.12" : 9999 // $host : $port //("/"+$name)

	$track_id := $tracks($track_name).$node_id_out

	// print track_id $track_id	


	$track_bus_in := $tracks($track_name).$bus

	// print track_bus $track_bus_in	

	// $descp_node_id := $SC_Servers($server_name)("node_id") // last id

	// $desc_id := $descp_node_id

	$curve_int_proc := 0
	// $params := $descripteur.cdr()

	// $Servers($server_name).s_new([$descripteur[0]+"_Replay", $descp_node_id, 3, $track_id, "in", $track_bus_in, "id", $descp_node_id].concat($params)) // reuse of node_id for SendRplay id
	// // $decriptors_map($name).add_pair($descripteur[0], $descp_node_id)
	// $descp_node_id += 1
	// $SC_Servers($server_name).add_pair("node_id", $descp_node_id)	




	// $delay := @rand(1.) + 0.5


	// $proc_index := $space_group_index
	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	// $space_group_index += 1

	// whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
	// {			
	// 	// print receive_descript (""+$descriptors_receives)
	// 	// osc_send_descriptors ([$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor value
	// 	// osc_send_descriptors (("/" + $name + $descriptors_receives[1][0]) + " " + $descriptors_receives[1][3]) "" // prefix includes the data = /$name, data = /descriptor values
	// 	// osc_send_descriptors ("/" + $name + $descriptors_receives[1][0]) ($descriptors_receives[1][3]) // prefix includes the data = /$name, data = /descriptor values

	// 	$desc_val := @scale($descriptors_receives[1][3], 0, 30, 0, 1, 1)

	// 	// print desc_val $desc_val
	// }	

	group @tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			// $v1 := $v2
			// $v2 := @rand_range($theta_min, $theta_max) 
			
			// $v11 := $v22
			// $v22 := @rand_range($phi_min, $phi_max)

			// $delay := @rand(1.) + 0.5
			// $duree := $delay
			
			// print radio $radio_res

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
							 $poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

								$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]

									$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
									// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
									// print test_pos1 (""+$xyz)

									// test_pos1 $xyz
									// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))

									// print (""+[("/spatc/"+$id+"/xyzw"), ($xyz.concat([$desc_val]))])

						 // @command("n_set"+$server_name) $group $param $val
					    }

				   { $phi, $theta {
					  {$start_angle, $start_elev} @type := $type
					  $duree {$end_angle, $end_elev} 
					  }
				   }
			    }
			$inc += 1			    
		} until ($inc >= $loop)
	}
}

// $tracks($nota_name).source_comete_solo2(                          0.1, @rand_range(0, 50), @rand_range(0, 360), @rand_range(0, 90), @rand_range(0, 360), 60, "linear", 1, 1, 1)	

@proc_def source_comete_solo3($server_name, $track_name, $mix_group, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"
	abort $curve_int_proc
	$trajs.remove($proc_index)
	// $space_group.remove($proc_index)
}
{
	@local $phi, $theta, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $track_id, $desc_id, $elev := 1, $params


	$track_id := $tracks($track_name).$node_id_out
	$track_bus_in := $tracks($track_name).$bus

	$curve_int_proc := 0

	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)


	group @tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
								$Servers($server_name).n_set($track_id, ["coords", [$radio_res, $phi, $theta]])	
							 	$poltocar := @poltocar3D_compiled($radio_res, $phi, $theta) // to oFx							 		

								$xyz[0] := $poltocar[0]
								$xyz[1] := $poltocar[1]
								$xyz[2] := $poltocar[2]
					    }

				   { $phi, $theta {
					  {$start_angle, $start_elev} @type := $type
					  $duree {$end_angle, $end_elev} 
					  }
				   }
			    }
			$inc += 1			    
		} until ($inc >= $loop)
	}
}
@proc_def source_comete_solo_ste($server_name, $track_name, $mix_group, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $loop, $id)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	print "abort"

	// $space_group.remove($proc_index)
}
{
	@local $phi, $theta, $curve_int_proc, $poltocar, $poltocar1, $proc_index, $xyz := [0, 0, 0, 0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $track_id, $desc_id, $elev := 1, $params


	$track_id := $tracks($track_name).$node_id_out
	$track_bus_in := $tracks($track_name).$bus
	$curve_int_proc := 0

	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
	$space_group($server_name)($mix_group)("val2").add_pair($track_id, $xyz1)
	// $space_group_index += 1

	// whenever(($descriptors_receives[0]==$server_name) && $descriptors_receives[1][2] == $desc_id) // && $descriptors_receives[1][3] == $descp_node_id
	// {			
	// 	// print receive_descript (""+$descriptors_receives)
	// 	// osc_send_descriptors ([$descriptors_receives[1][0], $descriptors_receives[1][3]]) // prefix = /$name, data = /descriptor value
	// 	// osc_send_descriptors (("/" + $name + $descriptors_receives[1][0]) + " " + $descriptors_receives[1][3]) "" // prefix includes the data = /$name, data = /descriptor values
	// 	// osc_send_descriptors ("/" + $name + $descriptors_receives[1][0]) ($descriptors_receives[1][3]) // prefix includes the data = /$name, data = /descriptor values

	// 	$desc_val := @scale($descriptors_receives[1][3], 0, 30, 0, 1, 1)

	// 	// print desc_val $desc_val
	// }	

	group @tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
							 $poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)
							 $poltocar1 := @poltocar3D_compiled($radio_res, ($theta*$elev), ($phi*(-$dir)))

								$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]
								$xyz[3] := $poltocar1[0]
									$xyz[4] := $poltocar1[1]
									$xyz[5] := $poltocar1[2]

									// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
									$Servers($server_name).n_set($track_id, ["x", ($xyz[0]), "y", ($xyz[1]), "z", ($xyz[2]), "x1", ($xyz[3]), "y1", ($xyz[4]), "z1", ($xyz[5])])

									// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
									// print test_pos1 (""+$xyz)

									// test_pos1 $xyz
									// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([$desc_val]))

									// print (""+[("/spatc/"+$id+"/xyzw"), ($xyz.concat([$desc_val]))])

						 // @command("n_set"+$server_name) $group $param $val
					    }

				   { $phi, $theta {
					  {$start_angle, $start_elev} @type := $type
					  $duree {$end_angle, $end_elev} 
					  }
				   }
			    }
			$inc += 1			    
		} until ($inc >= $loop)
	}
}


@proc_def traj_circ($server_name, $track_id, $dir, $duree, $start_radio, $end_radio, $start_angle, $end_angle, $start_elev, $end_elev, $period, $type, $loop)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"

	// $space_group.remove($proc_index)
	abort $curve_int_proc
	$trajs.remove($proc_index)
}
{
	@local $radio, $phi, $theta, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $desc_id, $elev := 1, $params


	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	group @tempo := ($period*$tempo_fac)
	{
		Loop $duree @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
							 	$poltocar := @poltocar3D_compiled($radio_res, $phi*$dir, $theta*$elev)
							 		
									$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]
									// print dae(""+[$radio, $phi, $theta])
									$Servers($server_name).n_set($track_id, ["coords", [$radio_res, $phi*$dir, $theta]])	

					    }

				   { $radio, $phi, $theta {
					  {$start_radio, $start_angle, $start_elev} @type := $type
					  $duree {$end_radio, $end_angle, $end_elev} 
					  }
				   }
			    }
		    
			$inc += 1			

		} until ($inc >= $loop)
		+=>  $trajs.remove($proc_index)
	}
}

@proc_def traj_circ2($server_name, $track_id, $start_coords, $clockwise, $tpo) // , $clockwise = 1
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"

	// $space_group.remove($proc_index)
	abort $curve_int_proc
	$trajs.remove($proc_index)
}
{
	@local $coords, $phi, $theta, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $desc_id, $elev, $params, $angle


	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	$radio := $start_coords[0]
	$angle := $start_coords[1]
	$elev := $start_coords[2]

		abort $curve_int_proc
		$curve_int_proc := {
			Loop 0.01 @tempo := $tpo //@exclusive //@tempo := $tpo
			{
				if($clockwise == 1 && $angle > 180)
				{
					$angle := $angle - 360
				}
				else
				{
					$angle := $angle
				}
				if($clockwise == -1 && $angle < -180)
				{
					$angle := $angle + 360
				}		
				else
				{
					$angle := $angle
				}
				$radio_res := $radio*$radio_fac 
				$Servers($server_name).n_set($track_id, ["coords", [$radio_res, $angle, $elev]])	
				// print type $type
				// print radio_fac $radio_fac
			 	$poltocar := @poltocar3D_compiled($radio_res, $angle, $elev) // to oFx							 		
				$xyz[0] := $poltocar[0]
				$xyz[1] := $poltocar[1]
				$xyz[2] := $poltocar[2]
				$angle += 1*$clockwise
			} //until ($inc >= $loop)
		}

/*			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
				   				$radio_res := $radio * $radio_fac
								// print dae(""+[$radio_res, $angle, $theta])
								if($clockwise == 1 && $phi > 180)
								{
									$phi := $phi - 360
								}
								else
								{
									$phi := $phi
								}
								if($clockwise == -1 && $phi < -180)
								{
									$phi := $phi + 360
								}		
								else
								{
									$phi := $phi
								}
								// print phi $phi					
								$Servers($server_name).n_set($track_id, ["coords", [$radio_res, $phi, $theta]])	
								// print type $type

							 	$poltocar := @poltocar3D_compiled($radio_res, $phi, $theta) // to oFx							 		
								$xyz[0] := $poltocar[0]
								$xyz[1] := $poltocar[1]
								$xyz[2] := $poltocar[2]
					    }

				   { $radio, $phi, $theta {
					  {($start_coords[0]), $start_angle, ($start_coords[2])} @type := $type
					  $duree {($end_coords[0]), $end_angle, ($end_coords[2])} 
					  }
				   }
			    }*/
		    
		// 	$inc += 1			

		// } until ($inc >= $loop)
		// $duree  $trajs.remove($proc_index)
	// }
}

@proc_def traj_circ22($coords, $start_coords, $clockwise, $tpo) // , $clockwise = 1
{
	@local $phi, $theta, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $desc_id, $elev, $params, $angle


	// $proc_index := $trajs_index
	// $trajs.add_pair($proc_index, $xyz)
	// $trajs_index += 1

	$radio := $start_coords[0]
	$angle := $start_coords[1]
	$elev := $start_coords[2]

		abort $curve_int_proc
		$curve_int_proc := {
			Loop 0.01 @tempo := $tpo //@exclusive //@tempo := $tpo
			{
				if($clockwise == 1 && $angle > 180)
				{
					$angle := $angle - 360
				}
				else
				{
					$angle := $angle
				}
				if($clockwise == -1 && $angle < -180)
				{
					$angle := $angle + 360
				}		
				else
				{
					$angle := $angle
				}

				$coords[1] := $angle
				$angle += 1*$clockwise
			} 
		}
}

@proc_def traj_circ_interp($server_name, $track_id, $start_coords, $end_coords, $duree, $type) // , $clockwise = 1
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"

	// $space_group.remove($proc_index)
	abort $curve_int_proc
	$trajs.remove($proc_index)
}
{
	@local $coords, $phi, $theta, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $radio, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $desc_id, $elev := 1, $params


	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

/*	if($clockwise == -1)
	{
		if($end_coords[1]>$start_coords[1])
		{
			$end_coords[1] := (($start_coords[1]*-1) - 180) - (180 - $end_coords[1])
		}
		
		$end_coords[1] := 
	}*/
	// group @tempo := ($period*$tempo_fac)
	// {
		// Loop $duree @exclusive //@tempo := $tpo
		// {
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac
							 	$poltocar := @poltocar3D_compiled($radio_res, $phi, $theta)
							 		
									$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]
									// print dae(""+[$radio_res, $phi, $theta])
									$Servers($server_name).n_set($track_id, ["coords", [$radio_res, $phi, $theta]])	
									// print type $type
					    }

				   { $radio, $phi, $theta {
					  {($start_coords[0]), ($start_coords[1]), ($start_coords[2])} @type := $type
					  $duree {($end_coords[0]), ($end_coords[1]), ($end_coords[2])} 
					  }
				   }
			    }
		    
		// 	$inc += 1			

		// } until ($inc >= $loop)
		$duree  $trajs.remove($proc_index)
	// }
}

@proc_def traj_circ_interp2($server_name, $track_id, $start_coords, $end_coords, $duree, $clockwise, $type) // , $clockwise = 1
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"

	// $space_group.remove($proc_index)
	abort $curve_int_proc
	$trajs.remove($proc_index)
}
{
	@local $coords, $phi, $theta, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $radio, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $desc_id, $elev := 1, $params, $start_angle, $end_angle


	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1
	$start_angle := $start_coords[1]
	
	if($clockwise == 1)
	{
		if($end_coords[1]<$start_angle)
		{
			$end_angle := ((180 - $start_angle) + (180 + $end_coords[1])) + $start_angle
		}
		else
		{
			$end_angle := $end_coords[1]
		}
	}

	if($clockwise == -1)
	{
		if($end_coords[1]>$start_angle)
		{
			$end_angle := ((($start_angle*-1) - 180) + ($end_coords[1] - 180)) + $start_angle
		}
		else
		{
			$end_angle := $end_coords[1]
		}
	}
	// print start_coords $start_angle
	// print end_coords $end_angle
	// group @tempo := ($period*$tempo_fac)
	// {
		// Loop $duree @exclusive //@tempo := $tpo
		// {
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
				   				$radio_res := $radio * $radio_fac
								// print dae(""+[$radio_res, $phi, $theta])
								if($clockwise == 1 && $phi > 180)
								{
									$phi := $phi - 360
								}
								else
								{
									$phi := $phi
								}
								if($clockwise == -1 && $phi < -180)
								{
									$phi := $phi + 360
								}		
								else
								{
									$phi := $phi
								}
								// print phi $phi					
								$Servers($server_name).n_set($track_id, ["coords", [$radio_res, $phi, $theta]])	
								// print type $type

							 	$poltocar := @poltocar3D_compiled($radio_res, $phi, $theta) // to oFx							 		
								$xyz[0] := $poltocar[0]
								$xyz[1] := $poltocar[1]
								$xyz[2] := $poltocar[2]
					    }

				   { $radio, $phi, $theta {
					  {($start_coords[0]), $start_angle, ($start_coords[2])} @type := $type
					  $duree {($end_coords[0]), $end_angle, ($end_coords[2])} 
					  }
				   }
			    }
		    
		// 	$inc += 1			

		// } until ($inc >= $loop)
		$duree  $trajs.remove($proc_index)
	// }
}

@proc_def traj_linear_interp($server_name, $track_id, $start_coords, $end_coords, $duree, $type)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"

	// $space_group.remove($proc_index)
	abort $curve_int_proc
	$trajs.remove($proc_index)
}
{
	@local $x, $y, $z, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $desc_id, $elev := 1, $params, $start_coords_cart, $end_coords_cart

	$start_coords_cart := @poltocar3D_tab($start_coords)
	// print (""+$start_coords_cart) 
	$end_coords_cart := @poltocar3D_tab($end_coords)
	// print (""+$end_coords_cart) 
	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	// group @tempo := ($period*$tempo_fac)
	// {
		// Loop $duree @exclusive //@tempo := $tpo
		// {
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								// $radio_res := $radio * $radio_fac
							 	// $poltocar := @poltocar3D_compiled($radio_res, $theta-90, ($phi*-1)-90)
							 		
									$xyz[0] := $x
									$xyz[1] := $y
									$xyz[2] := $z
									// print dae(""+[$radio_res, $phi, $theta])
									$Servers($server_name).n_set($track_id, ["coords", @cartopol3D_compiled($x, $y, $z)])	
									// print type $type
					    }

				   { $x, $y, $z {
					  {($start_coords_cart[0]), ($start_coords_cart[1]), ($start_coords_cart[2])} @type := $type
					  $duree {($end_coords_cart[0]), ($end_coords_cart[1]), ($end_coords_cart[2])} 
					  }
				   }
			    }
		    
		// 	$inc += 1			

		// } until ($inc >= $loop)
		$duree  $trajs.remove($proc_index)
	// }
}

// $nim_ele2 := NIM { 0 0, 0.5 60 "linear", 0.5 0 "linear" }

// print (""+$nim_ele1(0.4999))	
// print (""+$nim_ele2(0.49))	

@proc_def traj_linear_ele_interp($server_name, $track_id, $start_coords, $end_coords, $duree = 1, $max_ele = 1, $type = "linear")
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"

	// $space_group.remove($proc_index)
	abort $curve_int_proc
	$trajs.remove($proc_index)
}
{
	@local $x, $y, $z, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0, $descp_node_id, $desc_val := 0, $track_bus_in, $desc_id, $elev := 1, $params, $start_coords_cart, $end_coords_cart, $nim_ele1

	$nim_ele1 := NIM { 0 0, 0.5 $max_ele "circ_out", 0.5 0 "circ_in" }

	$start_coords_cart := @poltocar3D_tab($start_coords)
	// print (""+$start_coords_cart) 
	$end_coords_cart := @poltocar3D_tab($end_coords)
	// print (""+$end_coords_cart) 
	// print (""+@poltocar3D_ambi_tab([1, 1, 45]))
	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	// group @tempo := ($period*$tempo_fac)
	// {
		// Loop $duree @exclusive //@tempo := $tpo
		// {
			abort $curve_int_proc

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.033 //0.01s 
				   @action :=  { 
								// $radio_res := $radio * $radio_fac
							 	// $poltocar := @poltocar3D_compiled($radio_res, $theta-90, ($phi*-1)-90)
							 		
									$xyz[0] := $x
									$xyz[1] := $y
									$xyz[2] := $nim($z)
									// print dae(""+[$radio_res, $phi, $theta])
									$Servers($server_name).n_set($track_id, ["coords", @cartopol3D_tab($xyz)])	
									// print type $type
					    }

				   { $x, $y, $z {
					  {($start_coords_cart[0]), ($start_coords_cart[1]), 0 } @type := $type
					  $duree {($end_coords_cart[0]), ($end_coords_cart[1]), 1 } 
					  }
				   }
			    }
		    
		// 	$inc += 1			

		// } until ($inc >= $loop)
		$duree  $trajs.remove($proc_index)
	// }
}

@proc_def traj_rand_circ($server_name, $track_id, $radio_min, $radio_max, $radio_init, $az_min, $az_max, $az_init, $elev_min, $elev_max, $elev_init, $tpo, $type)
@abort
{
	// TODO
	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
	// print "abort"

	// $space_group.remove($proc_index)
	abort $curve_int_proc
	$trajs.remove($proc_index)
}
{
	@local $radio1, $radio2, $az1, $az2, $elev1, $elev2, $radio, $phi, $theta, $radio_range, $angle_range, $elev_range, $curve_int_proc := 0, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $elev := 1, $duree, $delay


	$proc_index := $trajs_index
	$trajs.add_pair($proc_index, $xyz)
	$trajs_index += 1

	$radio1 := $radio_init
	$radio2 := $radio_init
	$az1 := $az_init
	$az2 := $az_init
	$elev1 := $elev_init
	$elev2 := $elev_init

	$delay := @rand(1.) + 0.5

	group @tempo := $tpo
	{
		Loop $delay @exclusive //@tempo := $tpo
		{
			abort $curve_int_proc

			$radio1 := $radio2
			$radio2 := @rand_range($radio_min, $radio_max) 
			
			$az1 := $az2
			$az2 := @rand_range($az_min, $az_max)

			$elev1 := $elev2
			$elev2 := @rand_range($elev_min, $elev_max)		

			$delay := @rand(1.) + 0.5
			$duree := $delay	

			$curve_int_proc := {  curve
				   // @tempo := $tpo
				   @Grain := 0.01 //0.01s 
				   @action :=  { 
								$radio_res := $radio * $radio_fac

							 	$poltocar := @poltocar3D_compiled($radio_res, $phi, $theta*$elev)
							 		
									$xyz[0] := $poltocar[0]
									$xyz[1] := $poltocar[1]
									$xyz[2] := $poltocar[2]
									print dae(""+[$radio_res, $phi, $theta])
									$Servers($server_name).n_set($track_id, ["coords", [$radio_res, $phi, $theta]])	
					    }

				   { $radio, $phi, $theta {
						{$radio1, $az1, $elev1} @type := $type
					  $duree {$radio1, $az2, $elev2} 
					  }
				   }
			    }
		    
			// $inc += 1			

		} // until ($inc >= $loop)
		// +=>  $trajs.remove($proc_index)
	}
}

// @proc_def ::spat_rand_circ($source, $az_min, $az_max, $az_init, $tpo)
// {
// 	@local $g, $lab, $v1, $v2

// 	$g := 0.01
// 	$lab := 0
	
// 	$v1 := $az_init
// 	$v2 := $az_init

// 	loop 1 @tempo := $tpo
// 	{
// 	abort $lab

// 	$lab := {curve @tempo := $tpo
// 	    @grain := $g
// 	    @action :=  {
// 				Spat ("/track/"+$source+"/az") (($x + $offset)*$dir)
// 			}
// 		   { $x {    { 0  }
// 	                  1 { 360}  } }
// 		}
// 	}
// }


// @proc_def source_comete_inc_horz($server_name, $track_id, $mix_group, $dir, $duree, $radio, $start_angle, $end_angle, $period, $type, $loop, $id)
// @abort
// {
// 	// TODO
// 	// $sc_struct($group)($module).add_pair($param, $val) // enregistre la dernière valeur dans la main Map
// 	print abort
// 	// $space_group.remove($proc_index)
// }
// {
// 	@local $phi, $theta, $curve_int_proc, $poltocar, $proc_index, $xyz := [0, 0, 0], $HOA_local_x := 0, $HOA_local_y := 0, $HOA_local_z := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1 , $inc := 0

// 	// $v1 := $init_theta
// 	// $v2 := $init_theta
// 	// $v11 := $init_phi
// 	// $v22 := $init_phi
// 	print new_traj

// 	oscsend osc_send_descriptors @global "192.168.1.12" : 9999 // $host : $port //("/"+$name)


// 	$curve_int_proc := 0

// 	// $delay := @rand(1.) + 0.5


// 	// $proc_index := $space_group_index
// 	$space_group($server_name)($mix_group)("val").add_pair($track_id, $xyz)
// 	// $space_group_index += 1

// 	group @tempo := ($period*$tempo_fac)
// 	{
// 		Loop $duree @exclusive //@tempo := $tpo
// 		{
// 			abort $curve_int_proc

// 			// $v1 := $v2
// 			// $v2 := @rand_range($theta_min, $theta_max) 
			
// 			// $v11 := $v22
// 			// $v22 := @rand_range($phi_min, $phi_max)

// 			// $delay := @rand(1.) + 0.5
// 			// $duree := $delay
			
// 			// print radio $radio_res

// 			$curve_int_proc := {  curve
// 			        // @tempo := $tpo
// 			        @Grain := 0.033 //0.01s 
// 			        @action :=  { 
// 			        				$radio_res := $radio * $radio_fac
// 			        				$poltocar := @poltocar3D_compiled($radio_res, ($theta*$dir)-90, ($phi*-1)-90)

// 			        				$xyz[0] := $poltocar[0]
// 									$xyz[1] := $poltocar[1]
// 									$xyz[2] := $poltocar[2]

// 									$Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
// 									print xyz (""+$xyz.concat([@rand_range(0, 1)]))
// 									// test_pos1 $xyz
// 									osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

// 			                // @command("n_set"+$server_name) $group $param $val
// 			              }

// 			        { $phi  {
// 			            {$start_angle, $start_elev} @type := $type
// 			            $duree {$end_angle, $end_elev} 
// 			            }
// 			        }
// 			    }
// 			$inc += 1		
// 			$theta += 1    
// 		} until ($inc >= $loop)
// 	}
// }


@proc_def ::gui_oF_all()
{
	if($gui_enabled)
	{
		Loop 0.05
		{
			of_traj ($orbits.range().flatten())
			// print of_traj ($orbits.range().flatten())
		}
	}
}

$trajs := MAP{}
$trajs_index := 0

@proc_def ::gui_oF_trajs()
{
	@local $gui_trajs_enabled := 1
	if($gui_trajs_enabled)
	{
		Loop 0.05
		{
			of_traj ($trajs.range().flatten())
			// print of_traj ($trajs.range().flatten())
		}
	}
}

whenever of_gui ($of_gui==$of_gui)
{
	if($of_gui ==1)
	{
		$of_gui_proc := ::gui_oF_trajs()
	}
	else
	{
		abort $of_gui_proc
	}
}


@proc_def ::gui_oF($mix_group) 
{
	@local $tab_res := [], $server_n, $xyz_offset

	$server_n := $SC_Groups($mix_group)("server_name")
	
	if($space_group($server_n)($mix_group).is_defined("xyz_offset")) // if visualization actif
	{
		print already defined "xyz_offset"
	}
	else
	{
		$space_group($server_n)($mix_group).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
	}

	if($gui_enabled)
	{
		// Loop 0.05
		// {
		// 	of_traj ($space_group.range().flatten())
		// 	// of_traj ($space_group.range().flatten())
		// 	// print of_traj ($space_group.range().flatten())
		// }
		Loop 0.05
		{
			$tab_res := [] //reset tab

			forall $k, $v in $space_group($server_n)($mix_group)("val")
			{
				// print key  $k
				// print key  $v
				$tab_res.push_back($v)

			}
			// print (""+$tab_res)
			// $tab_res := $tab_res+$xyz_offset
			$xyz_offset := $space_group($server_n)($mix_group)("xyz_offset")
			$tab_res := $tab_res+ [ $xyz_offset | ($tab_res.size()) ]

			of_traj ($tab_res.flatten())
			print of_traj (""+$tab_res.flatten())

			/////// VIDEO
			// video_xyz ($xyz_offset)
			// video_db $localhost_meter

			// print 1 (""+$HOA_Global_Rot_xyz_ordffset)
			// print server_n $server_n
			// print mix_group $mix_group
			// print res (""+$space_group($server_n)($mix_group)("xyz_offset"))
			// print (""+$space_group($server_n)($mix_group))
			// print 2 (""+($tab_res+$xyz_offset))
			// $space_group($server_name)
			// of_traj ($space_group.range().flatten())
			// print of_traj ($space_group.range().flatten())
		}		
	}
}

// $toto := ([[1,2,3], [3,4,5]]+[2,2,2])
// print (""+$toto)

@proc_def ::ryth_prob_rand($server_name, $modules, $prob, $rmin, $rmax, $tpo)
{
	@local $rit, $noterest
	$rit := @rand_range($rmin, $rmax)
	
	loop $rit @tempo := $tpo
	{
		$noterest := ((@rand(1.) < $prob)? 1: 0)
		if ($noterest == 1)
		{
			if($modules.is_tab())
			{
				forall $mods in $modules
				{
					if($mods[0] == "HOA_Encode")
					{
						$Servers($server_name).n_set($mods[1], ["x", @rand_range($mods[2], $mods[3]), "y", @rand_range($mods[4], $mods[5]), "z", @rand_range($mods[6], $mods[7])] )
						// print coord_prob (""+["x", @rand_range(-1, 1), $y, @rand_range(-1, 1), $z, @rand_range(-1, 1)])
					}
					else
					{
						$Servers($server_name).n_set($mods.car(), $mods.cdr())	
					// print list (""+[$modules.car(), $modules.cdr()])		
					}
				}
			}
			else
			{
				$Servers($server_name).n_set($modules.car(), $modules.cdr())
				// print mono (""+[$modules.car(), $modules.cdr()])
			}
		}
		$rit := @rand_range($rmin, $rmax)
	}
}


@proc_def ::ryth_prob_rand_mod($server_name, $modules, $prob, $rmin, $rmax, $r_low, $r_hi, $t, $tpo)
{
	@local $rit, $temp, $x, $amp, $offset, $sin_proc, $grain, $period, $noterest

	$rit := @rand_range($rmin, $rmax)
	$temp := $tpo

	group @tempo := $temp
	{
		loop $rit //@tempo := $tpo
		{
			$noterest := ((@rand(1.) < $prob)? 1: 0)
			if ($noterest == 1)
			{
				if($modules.is_tab())
				{
					forall $mods in $modules
					{
						if($mods[0] == "HOA_Encode")
						{
							$Servers($server_name).n_set($mods[1], ["x", @rand_range($mods[2], $mods[3]), "y", @rand_range($mods[4], $mods[5]), "z", @rand_range($mods[6], $mods[7])] )
							// print coord_prob (""+["x", @rand_range(-1, 1), $y, @rand_range(-1, 1), $z, @rand_range(-1, 1)])
						}
						else
						{
							$Servers($server_name).n_set($mods.car(), $mods.cdr())	
						// print list (""+[$modules.car(), $modules.cdr()])		
						}
					}
				}
				else
				{
					$Servers($server_name).n_set($modules.car(), $modules.cdr())
					// print mono (""+[$modules.car(), $modules.cdr()])
				}
			}
			$rit := @rand_range($rmin, $rmax)
		}
	}

	$amp := ($r_hi - $r_low)/2
    $sin_proc := 0
    $grain := 0.01
    $period := (1/$t)


    loop $period // @tempo := $t
    {
		  abort $sin_proc	
		  $sin_proc := {
				curve
				@grain := 0.01 //($grain * $period/60.)
				@action := {

						$temp := $x
					   // $val := (@sin($x) * $amp + $offset)  //+ $offset
					   // // scServer "n_set" $module $param $val
					   // $Servers($server_name).n_set($module, [$param, $val])
					   // // n_set $module $param $val
					   // // print ("n_set"+$server_name) $module $param $val $r_low $r_hi $t 
					   // // print $x $amp $period
					   // gui_data $server_name $group $module $param $val
				}                       
				   { $x {    { 0  }
						$period { (2* 3.141516 )}  }  // NON Pi = 3.1415926... d'où 3.1416 pas 3.141516 ????
					   }
	   }

    }

}



@proc_def ::ryth_prob($server_name, $modules, $prob, $rit, $tpo)
{	
	@local $noterest
	loop $rit @tempo := $tpo
	{
		$noterest := ((@rand(1.) < $prob)? 1: 0)
		if ($noterest == 1)
		{
			if($modules.is_tab())
			{
				forall $mods in $modules
				{
					$Servers($server_name).n_set($mods.car(), $mods.cdr())	
					// print print_ryth (""+[$mods.car(), $mods.cdr()])		
				}
			}
			else
			{
				$Servers($server_name).n_set($modules.car(), $modules.cdr())
				// print print_ryth (""+[$modules.car(), $modules.cdr()])	
			}
		}
	}
}

@proc_def ::ryth_seq($server_name, $modules, $ritmos_tab, $prob, $rit, $tpo, $loop = 0)
{	
	@local $inc := 0, $inc_spat := 0, $tabsize, $tab_spat_size, $durtab, $noterest

	$tabsize := @size($ritmos_tab)
	$durtab := $ritmos_tab[$inc]

	group @tempo $tpo
	{
		loop $durtab
		{
			$noterest := ((@rand(1.) < $prob)? 1: 0)
			if ($noterest == 1)
			{
				if($modules.is_tab())
				{
					forall $mods in $modules
					{
						if($mods[0] == "HOA_Encode")
						{
							$tab_spat_size := @size($mods[2])
							$Servers($server_name).n_set($mods[1], ["x", $mods[2][$inc_spat][0], "y", $mods[2][$inc_spat][1], "z", $mods[2][$inc_spat][2]])
						}
						else
						{
							$Servers($server_name).n_set($mods.car(), $mods.cdr())	
						// print print_ryth (""+[$mods.car(), $mods.cdr()])		
						}
					}
				}
				else
				{
					$Servers($server_name).n_set($modules.car(), $modules.cdr())
					// print print_ryth (""+[$modules.car(), $modules.cdr()])	
				}
			$durtab := $ritmos_tab[$inc]
			$inc := ($inc + 1) % $tabsize
			$inc_spat := ($inc_spat + 1) % $tab_spat_size
			// print inc_spat $inc_spat
			}
		} while ($loop != 0)
	}
}


@proc_def ::ryth_vect_prob($server_name, $modules, $ryth_tab, $ryth_prob, $prob, $rit, $tpo)
{	
	@local $inc := 0, $durtab, $spatab, $noterest

	$durtab := @vprob($ryth_tab, $ryth_prob)

	group @tempo $tpo
	{
		loop $durtab
		{
			$noterest := ((@rand(1.) < $prob)? 1: 0)
			if ($noterest == 1)
			{
				if($modules.is_tab())
				{
					forall $mods in $modules
					{
						if($mods[0] == "HOA_Encode")
						{
							$spatab := @vprob($mods[2], $mods[3])
							$Servers($server_name).n_set($mods[1], ["x", $spatab[0], "y", $spatab[1], "z", $spatab[2]])
						}
						else
						{
							$Servers($server_name).n_set($mods.car(), $mods.cdr())	
						// print print_ryth (""+[$mods.car(), $mods.cdr()])		
						}	
					}
				}
				else
				{
					$Servers($server_name).n_set($modules.car(), $modules.cdr())
					// print print_ryth (""+[$modules.car(), $modules.cdr()])	
				}
			$durtab := @vprob($ryth_tab, $ryth_prob)

			}
		}
	}
}


@proc_def ::ryth_vect_prob_mod_sin($server_name, $modules, $ryth_tab, $ryth_prob, $prob, $r_low, $r_hi, $t, $tpo)
{	
	@local $inc := 0, $durtab, $spatab , $temp, $x, $amp, $offset, $sin_proc, $grain, $period, $val := 0, $noterest

	$durtab := @vprob($ryth_tab, $ryth_prob)

	$temp := $tpo

	group @tempo $temp
	{
		loop $durtab
		{
			$noterest := ((@rand(1.) < $prob)? 1: 0)
			if ($noterest == 1)
			{
				if($modules.is_tab())
				{
					forall $mods in $modules
					{
						if($mods[0] == "HOA_Encode")
						{
							$spatab := @vprob($mods[2], $mods[3])
							$Servers($server_name).n_set($mods[1], ["x", $spatab[0], "y", $spatab[1], "z", $spatab[2]])
						}
						else
						{
							$Servers($server_name).n_set($mods.car(), $mods.cdr())	
						// print print_ryth (""+[$mods.car(), $mods.cdr()])		
						}	
					}
				}
				else
				{
					$Servers($server_name).n_set($modules.car(), $modules.cdr())
					// print print_ryth (""+[$modules.car(), $modules.cdr()])	
				}
			$durtab := @vprob($ryth_tab, $ryth_prob)

			}
		}
	}


    $sin_proc := 0
    $grain := 0.01
    $period := (1/$t)


    loop $period // @tempo := $t
    {
		  abort $sin_proc	
		  $sin_proc := {
				curve
				@grain := 0.01 //($grain * $period/60.)
				@action := {

						// $temp := $x
						$amp := ($r_hi - $r_low)/2
							$offset := $r_hi - $amp
					   $val := (@sin($x) * $amp + $offset)  //+ $offset
					   $temp := $val
					   // print amp $amp
					   // // scServer "n_set" $module $param $val
					   // $Servers($server_name).n_set($module, [$param, $val])
					   // // n_set $module $param $val
					   // // print ("n_set"+$server_name) $module $param $val $r_low $r_hi $t 
					   // // print $x $amp $period
					   // gui_data $server_name $group $module $param $val
				}                       
				   { $x {    { 0  }
						$period { (2* 3.141516 )}  }  // NON Pi = 3.1415926... d'où 3.1416 pas 3.141516 ????
					   }
	   }

    }
}


@proc_def ::ryth_vect_prob_mod_sin_dur($server_name, $modules, $ryth_tab, $ryth_prob, $prob, $r_low, $r_hi, $t, $tpo)
{	
	@local $inc := 0, $durtab, $spatab , $temp, $x, $amp, $offset, $sin_proc, $grain, $period, $val := 0, $grain_dur, $noterest

	$durtab := @vprob($ryth_tab, $ryth_prob)

	$temp := $tpo

	group @tempo $temp
	{
		loop $durtab
		{
			$grain_dur := 1/($temp/60)
			// print tempo $temp
			// print grain_dur $grain_dur
			$noterest := ((@rand(1.) < $prob)? 1: 0)
			if ($noterest == 1)
			{
				if($modules.is_tab())
				{
					forall $mods in $modules
					{
						if($mods[0] == "HOA_Encode")
						{
							$spatab := @vprob($mods[2], $mods[3])
							$Servers($server_name).n_set($mods[1], ["x", $spatab[0], "y", $spatab[1], "z", $spatab[2]])
						}
						else
						{
							$Servers($server_name).n_set($mods.car(), $mods.cdr().concat(["dur", $grain_dur]))	
						// print print_ryth (""+[$mods.car(), $mods.cdr()])		
						}	
					}
				}
				else
				{
					$Servers($server_name).n_set($modules.car(), $modules.cdr())
					// print print_ryth (""+[$modules.car(), $modules.cdr()])	
				}
			$durtab := @vprob($ryth_tab, $ryth_prob)

			}
		}
	}

	$amp := ($r_hi - $r_low)/2
	$offset := $r_hi - $amp
    $sin_proc := 0
    $grain := 0.01
    $period := (1/$t)


    loop $period // @tempo := $t
    {
		  abort $sin_proc	
		  $sin_proc := {
				curve
				@grain := 0.01 //($grain * $period/60.)
				@action := {

						// $temp := $x
						
					   $val := (@sin($x) * $amp + $offset)  //+ $offset
					   $temp := $val
					   // print tempo $val
					   // // scServer "n_set" $module $param $val
					   // $Servers($server_name).n_set($module, [$param, $val])
					   // // n_set $module $param $val
					   // // print ("n_set"+$server_name) $module $param $val $r_low $r_hi $t 
					   // // print $x $amp $period
					   // gui_data $server_name $group $module $param $val
				}                       
				   { $x {    { 0  }
						$period { (2* 3.141516 )}  }  // NON Pi = 3.1415926... d'où 3.1416 pas 3.141516 ????
					   }
	   }

    }
}


@fun_def build_nim_from_bpf($bpf)  // crea NIM a partir de bpf tab [v0, t0, (type0), v1, t1, (type1), v2, t2, (type2)....]
{
	    @local $i, $period, $val0, $val1, $type, $duree, $nim

	    $i := 0
	    $val1 := $bpf[0]
	    $period := $bpf[1] ; because it appears in the Loop period
	    $nim := NIM{ 0 $val1, 0 $val1 }

	    Loop  //@exclusive
	    {
		  $val0 := $bpf[$i]
		  $period := $bpf[$i+1]
		  $duree := $period - 0.001

		  if (@is_string($bpf[$i+2]))
		  {
			 $type := $bpf[$i+2]
			 $val1 := $bpf[$i+3]
			 $i := $i + 3;
		  }
		  else
		  {
			 $type := "linear"
			 $val1 := $bpf[$i+2]
			 $i := $i + 2;
		  }

		  $nim.push_back($val0, $period, $val1, $type)
		  
	    } while ($i+2 < @size($bpf))

	    return $nim
}


@fun_def from_bach_bpf_abs($bach_bpf)  // crea NIM a partir de bpf tab [v0, t0, (type0), v1, t1, (type1), v2, t2, (type2)....]
{
	@local $curves := [], $bpf_list := [], $count_curv := 0, $count := 0, $count2 := 0, $bpf := [], $t_tab := []
	
	Loop 
    {
		switch  // interpretation des curves de bach vers antescofo
		{
		case $bach_bpf[$count_curv+2] == 0.:
			$curves.push_back("linear")
			case ($bach_bpf[$count_curv+2] < 0.) && ($bach_bpf[$count_curv+2] > -0.5):
			$curves.push_back("quart_out")	
			case $bach_bpf[$count_curv+2] < -0.5:
			$curves.push_back("exp_out")				
			case $bach_bpf[$count_curv+2] > 0. && ($bach_bpf[$count_curv+2] < 0.5):
			$curves.push_back("quart_in")	
			case $bach_bpf[$count_curv+2] > 0.5:
			$curves.push_back("exp_in")
		}
		$t_tab.push_back($bach_bpf[$count_curv])
		$bpf.push_back($bach_bpf[$count_curv+1])

	$count_curv += 3
    } until ($count_curv == @size($bach_bpf))


    $curves := $curves.rotate(-1)
	// $bpf := $bach_bpf.rotate(-1) 
	$t_tab := @tab_diff_inc($t_tab) * 0.001 // convert to seconds

	$bpf_list := @lace([$bpf, $t_tab, $curves], @size($bpf)+@size($t_tab)+@size($curves))
 //    print curves2 $curves
 //    print bpf_amps2 $bpf
 //    print t_tab2 $t_tab
	// print bpf_list_2_anteco ($bpf_list.drop(-1))
 //    Loop // construction de la liste
 //    {
	// 	$bpf_list.push_back($bpf[$count])
	// 	$bpf_list.push_back($t_tab[$count2]) // millisecond from bach to seconds
	// 	$bpf_list.push_back($curves[$count2])
		
	// 	// $bpf_list.push_back($bpf[$count+1])
	// 	$count += 3
	// 	$count2 += 1
	// } while ($count+3 < @size($bpf))
	
	return $bpf_list.drop(-1)
}

@fun_def from_bach_spat_abs($bach_bpf)  // crea NIM a partir de bpf tab [v0, t0, (type0), v1, t1, (type1), v2, t2, (type2)....]
{
	@local $curves := [], $bpf_list := [], $count_t := 0, $count := 0, $count2 := 0, $bpf, $radio := [], $azi := [], $t_tab := []
	
	// $bach_bpf := $bach_bpf.drop(2) // enleve l'entete
	$bpf_list := $bach_bpf.drop(4)

	Loop 
    {

	$t_tab.push_back($bpf_list[$count2])
	$radio.push_back($bpf_list[$count2+1])
	$azi.push_back($bpf_list[$count2+2])

	$count2 += 4
    } until ($count2 == @size($bpf_list))

    

	$t_tab := @tab_diff_inc($t_tab) * 0.001 // convert to seconds
	print t_tab $t_tab
	print radio $radio
	print azi $azi

	$radio := @lace([$radio, $t_tab], @size($radio)+@size($t_tab))
	$azi := @lace([$azi, $t_tab], @size($azi)+@size($t_tab))


	return [$radio, $azi]
}
// spat: [ 0. 0.729469 0. 0 ] [ 0.227988 0.824362 -90.747974 1 ] [ 0.510912 0.824362 -234.283985 0 ] [ 1. 0.824362 64.650517 1 ]
// t  radio 	azi type
// 0. 0.729469 0. 0 4250.295334 0.824362 -90.747974 1 7787.342594 0.3706 0. 0 9524.740875 0.824362 -234.283985 0 18642.620538 0.824362 64.650517 1

@fun_def sc_server_tree($data)  // for Max cellblock visualisation
{
	@local $i, $d, $group_n, $synth_n

		$i := 0
		$group_n := 0
		$synth_n := 1

		if($data[0] == 0)
		{
			$i := 1
			cellblock clear all
	    Loop  //@exclusive
	   {
		// print ($data[$i]) ($data[$i+1]) //($data[$i+2])
		if(($data[$i+1]) == -1)
		{
			cellblock set ($group_n-1) $synth_n ($data[$i]) ($data[$i+2])
			print synth ($data[$i]) ($data[$i+2])
			$i := $i + 3
			$synth_n := $synth_n + 1
		}else{
			$synth_n := 1
			if($group_n==0)
			{
				cellblock cols ($data[$i+1] + 1) // cols number
			}
			if(($group_n>0) && ($data[$i+1]>10))
			{
				cellblock rows ($data[$i+1] + 1) // rows number
			}
			
			cellblock set $group_n 0 ($data[$i]) groupo   //($data[$i+1])
			print groupo ($data[$i])
			$i := $i + 2
			$group_n := $group_n + 1
		}
		  
	   } while ($i+2 <= @size($data))
    }
	}



whenever ($from_sc_server==$from_sc_server)
{

	// @sc_server_tree($from_sc_server)
	@sc_server_tree2map($from_sc_server)
	1 print (""+$sc_struct)
	1 $sc_struct.sc_build(0)

	// $from_sc_server
}


// print ([[map{("mDust", map{("freq", 100), ("amp", 100)})}], [map{("mDust", map{("freq", 100), ("amp", 100)})}]])


// $sc_tree := map{("group1", [["mDust", "freq", 100, "amp", 3], ["tAdCVerb", "revTime", 0.4]]), ("group2", [["windowtest3"], ["windowtest3"]])}

// print (""+$sc_tree("group1"))
	
// $map_cues := map{(1, "capta_L_catart"), (2, "off_capta_L"), (126, "kick_ballets"), (3, "off_ballets_traitements"), (4, "off_traitements"), (5, "kick1_partie_jose"), (6, "kick2_partie_jose"), (7, "kick3_partie_jose"), (8, "kick4_partie_jose"), (9, "kick5_partie_jose"), (10, "kick6_partie_jose"), (11, "kick7_partie_jose"), (12, "kick8_partie_jose"), (13, "kick9_partie_jose"), (14, "kick10_partie_jose"), (15, "kick11_partie_jose"), (16, "kick12_partie_jose"), (17, "kick13_partie_jose"), (18, "kick14_partie_jose"), (19, "kick15_partie_jose"), (20, "kick16_partie_jose"), (21, "kick17_partie_jose"), (22, "kick26_partie_jose_18"), (23, "kick28_partie_jose_19"), (24, "kick29_partie_jose_20"), (25, "kick30_partie_jose_21"), (26, "kick31_partie_jose_22"), (27, "kick32_partie_jose_23"), (28, "kick33_trill_24"), (29, "kick34_trill_25"), (30, "kick35_trill_26"), (31, "kick36_partie_jose_27"), (32, "kick38_partie_jose_28"), (33, "kick40_partie_jose_29"), (34, "kick42_partie_jose_30"), (35, "kick44_TRILL_31"), (36, "kick44_TRILL_off"), (37, "kick_sample_claves"), (38, "claves_dels"), (39, "off_claves")}

$mix_g := 0 // variable globale pour sc_struct_build
$bus_out := 0
$bus_in := 0
$sc_build_mix_group := 0
$sc_build_tracks := 0

@fun_def sc_build_map2($sc_map) // reconstruction à partir des paramètres de base nom des groups/tracks sans id
{	
	@local $tab_res
	if ($sc_map.is_undef())
	{ 
		print no_map_struct
		return 0 
	}
	else
	{
		forall $k, $v in $sc_map
		{
			// print key (""+$k)
			// print val (""+$v)
			forall $key, $val in $v
			{
				// print key2 (""+$key)
				// print val2 (""+$val)
				if ($key == 1) // default group
				{
					forall $elem, $val2 in $val
					{
						// print key1 (""+$k)
						// print val1 (""+$v)
						// print default_group (""+$elem)
						// print server $k
						// // print key $key
						// print val (""+$val) // defaul group id
						// print val2 (""+$val2) // defaul group id
						forall $m_g in $val2
						{
							@local $mix_g_n
							// print mix_group_name (""+$v($m_g)[1])
							$mix_g_n := $v($m_g)[1]

							// print mix_group_params (""+$v($m_g))

							forall $m_g2 in $v($m_g)[0].reverse()
							{
								// print track_id $m_g2
								if($v($m_g2).is_tab())
								{
									@local $track_n, $in_chnls, $doppl_t, $amp_t
									//print: track_name "MAP{ (\"amp\", 0), (\"dopamnt\", 1), (\"doppler\", 0), (\"encoder\", true), (\"fade_in\", 1), (\"in_channels\", 1), (\"track_name\", \"track_hoa1\") }"
									$track_n := $v($m_g2)[1]("track_name")
									// print track_n $track_n
									$in_chnls := $v($m_g2)[1]("in_channels")
									// print in_chnls $in_chnls
									$doppl_t := $v($m_g2)[1]("doppler")
									// print doppl_t $doppl_t
									$amp_t := $v($m_g2)[1]("amp")
									// print amp_t $amp_t
									// print track_name (""+$v($m_g2)[1])
									
									obj::crea_track_HOA($track_n, $mix_g_n, amp = $amp_t, doppler = $doppl_t, in_channels = $in_chnls)


									forall $nodes_synth in $v($m_g2)[0].reverse()
									{
										@local $synth_s, $params_s

										if($v($nodes_synth).is_defined("_synth"))
										{
											// synths MAP{ ("_synth", "TDust"), ("amp", -5), ("freq", 10), ("in", 555.0), ("out", 555.0) }
		
											$synth_s := $v($nodes_synth)("_synth")
											// $v($nodes_synth).remove("_synth")
											$v($nodes_synth).remove("in")
											$v($nodes_synth).remove("out")
											$params_s := @map2tab($v($nodes_synth))
											// print map2tab (""+@map2tab($v($nodes_synth)))
											$tracks($track_n).mod_add([$synth_s].concat($params_s))
										}
										// print synth_node_id $nodes_synth
										// print synths (""+$v($nodes_synth))

									}
								}
								else
								{
									@local $ambi_dec, $ambi_order
									$ambi_dec := $v($m_g2)("decoder")
									$ambi_order := $v($m_g2)("order")
									// print decoder (""+$v($m_g2))

									obj::mix_group_HOA($mix_g_n, $k, $ambi_dec, $ambi_order)

								}
							}
						}
					}
				}
			}
		}
	}
}


@fun_def sc_build_map_from_id($sc_map) // reconstruction à partir des paramètres de base nom des groups/tracks avec id
{	
	@local $tab_res
	if ($sc_map.is_undef())
	{ 
		print no_map_struct
		return 0 
	}
	else
	{
		forall $k, $v in $sc_map
		{
			// print key (""+$k)
			// print val (""+$v)
			forall $key, $val in $v
			{
				// print key2 (""+$key)
				// print val2 (""+$val)
				if ($key == 1) // default group
				{
					forall $elem, $val2 in $val
					{
						// print key1 (""+$k)
						// print val1 (""+$v)
						// print default_group (""+$elem)
						// print server $k
						// print key $key
						// print val (""+$val) // defaul group id
						// print val2 (""+$val2) // defaul group id
						forall $m_g in $val2
						{
							@local $mix_g_n
							print mix_group_name (""+$v($m_g)[1])
							$mix_g_n := $v($m_g)[1]

							print mix_group_params (""+$v($m_g))

							forall $m_g2 in $v($m_g)[0].reverse()
							{
								// print track_id $m_g2
								if($v($m_g2).is_tab())
								{
									@local $track_n, $in_chnls, $doppl_t, $amp_t, $id_t
									print: track_name "MAP{ (\"amp\", 0), (\"dopamnt\", 1), (\"doppler\", 0), (\"encoder\", true), (\"fade_in\", 1), (\"in_channels\", 1), (\"track_name\", \"track_hoa1\") }"
									$track_n := $v($m_g2)[1]("track_name")
									print track_n $track_n
									$in_chnls := $v($m_g2)[1]("in_channels")
									print in_chnls $in_chnls
									$doppl_t := $v($m_g2)[1]("doppler")
									print doppl_t $doppl_t
									$amp_t := $v($m_g2)[1]("amp")
									print amp_t $amp_t
									$amp_t := $v($m_g2)[1]("amp")
									$id_t := $v($m_g2)[1]("track_id")
									print id_t $id_t
									
									obj::crea_track_HOA($track_n, $mix_g_n, amp = $amp_t, doppler = $doppl_t, in_channels = $in_chnls, ext_id = $id_t)


									forall $nodes_synth in $v($m_g2)[0].reverse()
									{
										@local $synth_s, $params_s, $node_id_s

										if($v($nodes_synth).is_defined("_synth"))
										{
											// synths MAP{ ("_synth", "TDust"), ("amp", -5), ("freq", 10), ("in", 555.0), ("out", 555.0) }
		
											$synth_s := $v($nodes_synth)("_synth")
											// $v($nodes_synth).remove("_synth")
											$v($nodes_synth).remove("in")
											$v($nodes_synth).remove("out")
											$params_s := @map2tab($v($nodes_synth))
											$node_id_s := $v($nodes_synth)("node_id")
											print node_id_s $node_id_s
											print map2tab (""+@map2tab($v($nodes_synth)))
											$tracks($track_n).mod_add([$synth_s].concat($params_s), ext_id = $node_id_s)


										}
										// print synth_node_id $nodes_synth
										// print synths (""+$v($nodes_synth))

									}
								}
								else
								{
									@local $ambi_dec, $ambi_order, $mx_g_id
									$ambi_dec := $v($m_g2)("decoder")
									$ambi_order := $v($m_g2)("order")
									$mx_g_id := $v($m_g2)("index")
									print decoder_mix_group (""+$v($m_g2))

									obj::mix_group_HOA($mix_g_n, $k, $ambi_dec, $ambi_order, ext_id = $mx_g_id)

								}
							}
						}
					}
				}
			}
		}
	}
}



@fun_def sc_build_map($sc_map, $target, $server_name)
{	
	if ($sc_map.is_undef())
	{ 
		print no_map_struct
		return 0 }
	else
	{
		@local $node := $sc_map($server_name), $map2list := [] //, $default_g //, $group, $out_synth

		// print node_init (""+$node)
		// print target $target
		// print titititititititititititittititititiittititiitit

		if ($target.is_string()) // if target is name of mix_group or track
		{
			forall $k, $v in $node
			{
				// print key (""+$k)
				// print val (""+$v)

				if (@is_defined($v, $target))
				{
					// print node_target $k
					forall $key, $val in $v
					{
						// print key2 (""+$key)
						// print val2 (""+$val)
						if ($val.is_tab())
						{
							if ($k == 1) // if node in the default group (mix_group)
							{
								forall $elem in $val
								{
									print node_1 (""+$v)
									print node_key (""+$k)
										$sc_build_mix_group := $sc_map($server_name)($elem).domain()[0]
										print sc_build_mix_group $sc_build_mix_group $server_name
										obj::mix_group($sc_build_mix_group, $server_name)
										$amp_gt := "group"

										// $Servers($server_name).g_new($elem, 0, $k)
										// print elem_loop $elem

										// print elem_key (""+$sc_map($server_name)($elem).domain()[0])

										// $mix_g := $elem
										// $bus_index := $bus_index + 8 // incremente bus de 8 channels
										// $bus_out := 0
										// $bus_in := $SC_Servers($server_name)("bus_index") // current bus index for this server

										// print default_group bus_in $bus_in
										// print default_group bus_out $bus_out
										print sc_build_map $elem $server_name
										$sc_map.sc_build_map($elem, $server_name)
									// if ($k == 1) // group in default group
									// {
									// 	// $sc_build_mix_group := $sc_map($server_name)($elem).domain()[0]
									// 	// print sc_build_mix_group $sc_build_mix_group $server_name
									// 	// obj::mix_group($sc_build_mix_group, $server_name)

									// 	// // $Servers($server_name).g_new($elem, 0, $k)
									// 	// // print elem_loop $elem

									// 	// // print elem_key (""+$sc_map($server_name)($elem).domain()[0])

									// 	// // $mix_g := $elem
									// 	// // $bus_index := $bus_index + 8 // incremente bus de 8 channels
									// 	// // $bus_out := 0
									// 	// // $bus_in := $SC_Servers($server_name)("bus_index") // current bus index for this server

									// 	// // print default_group bus_in $bus_in
									// 	// // print default_group bus_out $bus_out
									// 	// print sc_build_map $elem $server_name
									// 	// $sc_map.sc_build_map($elem, $server_name)
									// }

								}
							}
							else
							{
								print val (""+$val)
								print key (""+$key)
								forall $elem in $val
								{
									$sc_build_mix_group := $key
									obj::mix_group($sc_build_mix_group, $server_name)

									$sc_map.sc_build_map($elem, $server_name)
									$amp_gt := "group"
								}
							}
						}

					}
				}
			}
		}
		else // if node id
		{

			@local $node_int := $node($target).range()[0], $node_int2 := $node($target)

			print 1 (""+$node_int)
			// print 2 (""+$node)
			print 3 (""+$node($target))
			print 4 (""+!@is_defined($node($target), "_synth"))
			print 5 (""+!@is_defined($node($target), "_synth"))

			if($node_int.is_tab() && (!@is_defined($node($target), "_synth")))
			{
				// print tytytytytytytytytytytytyytytytytytytytytytyty
				// $sc_build_tracks := $node($node_int[0]).domain()[0]
				// $sc_build_tracks := $node($target).range()[0]
				$sc_build_tracks := $node($target).domain()[0]
				print 11122 (""+$node($target).domain()[0])
				print 111 (""+!@is_defined($node($target), "_synth"))
				print 11 (""+$node($target))
				print 22 (""+$node_int)
				print 33 (""+$node($node_int))
				print 44 (""+$node($node_int[0]).domain())

				print crea_track $sc_build_tracks $sc_build_mix_group
				$amp_gt := "track"

				if ($sc_build_tracks != $sc_build_mix_group) // pour ne pas répéter quand recursion 
				{
					obj::crea_track($sc_build_tracks, 0, 0, 0, [], $sc_build_mix_group)

					forall $elem in $node_int.rotate(1)
					{

						print elem_loop2 $elem
						// print tatatatata
						// print mix_group bus_in $bus_in
						// print mix_group bus_out $bus_out					
						$sc_map.sc_build_map($elem, $server_name)	
						// $bus_out := $bus_in
						// $bus_index := $bus_index + 8 // incremente bus de 8 channels
						// $bus_in := $SC_Servers($server_name)("bus_index") // current bus index for this server			
					}
				}
				else
				{
					$sc_map.sc_build_map($node_int[0], $server_name)
				}

			}
			else
			{						
				// print node3 ($node("synth"))
					// print node_int2_node_int2_node_int2 (""+$node_int2)

				if($node_int2("_synth") == "audioOut8") // si c'est la outsynth audioOut8
				{				

					// print audioOut8 (""+$node_int2("_synth")) $sc_build_tracks $sc_build_mix_group
					// print amp amp ($node_int2("amp"))

					// $tracks("track1").amp($node_int2("amp"))
					print amp_amp_gt $amp_gt

					switch ($amp_gt) // if track or group
				{
					case "track":
						$tracks($sc_build_tracks).amp($node_int2("amp")) // recover amp from sc_struct MAP
						case "group":
						$groups($sc_build_mix_group).amp($node_int2("amp"))	// recover amp from sc_struct MAP	 			   		
					}
					// print bus_index_out $bus_index
					// print bus_in $bus_in
					// print bus_out $bus_out
					// print build out node_int2 ($node_int2("synth")) (" with parameters "+$node_int2) 
					// $Servers($server_name).s_new([$node_int2("_synth"), $target, 1, $group, "in", $bus_in, "out", $bus_out, "index", $bus_in, "in_ramp", 1, "amp", $node_int2("amp")])  //target 2 justo despues del nodo 180 audioOut
					// print s_new ($node_int2("_synth")) $target 1 $group in $bus_in out $bus_out index $bus_in in_ramp 1 amp 0
					// print $target
					// $out_synth := $target
					// $bus_index := $bus_index + 8 // incremente bus de 8 channels
					// $SC_Servers($server_name).insert("bus_index", $bus_in+8) // inc bus de server  

				}else{
					@local $synths := $node_int2("_synth")
					// print build leaf node_int2 ($node_int2("synth")) (" with parameters "+$node_int2) 
					// print sc_build_tracks $sc_build_tracks
					// print node3 (""+$node)
					// print node_int2 (""+$node_int2)	

					$node_int2.remove("_synth")
					$node_int2.remove("in")
					$node_int2.remove("out")

					forall $k, $v in $node_int2 //map to tab
					{
						$map2list.push_back($k)
						$map2list.push_back($v)
					}
					// print map2list $map2list
					$tracks($sc_build_tracks).mod_add([$synths].concat($map2list), "top")

					// $Servers($server_name).s_new([$synths, $target, 2, $out_synth, "in", $bus_out, "out", $bus_out].concat($map2list))  //target 2 justo despues del nodo 180 audioOut
					print s_new ([$synths].concat($map2list))

					// print s_new $synths $target 2 $out_synth in $bus_out out $bus_out $map2list
					// $node_int2.remove("_synth") // enleve la pair target "synth"
				
					// fonction qui transforme les pairs target/values qui resten en tab ou aplatir
					// lace entre 2 tab
				}
				// print node_int2 node_int2 $target
			}
		}
	}
}

@fun_def sc_build_map2server($sc_map, $target, $server_destination)
{	
	@local $node := $sc_map.range()[0] , $map2list := []
	// print node_range (""+$sc_map.range()[0])
	// print node_range_range (""+$sc_map.range()[0].range())
	if ($sc_map.is_undef())
	{ 
		print no_map_struct
		return 0 }
	else
	{
		if ($target.is_string()) // if target is name of mix_group or track
		{
			forall $k, $v in $sc_map
			{
				// print key (""+$k)
				// print val (""+$v)
					forall $key, $val in $v
					{
						if (@is_defined($val, $target))
						{
							print fatto (""+$val)
							$node := $val
							print nodenode (""+$node)
								forall $grp, $elem in $val
								{
									
									forall $x in $elem
									{
										print elem $x
										$sc_build_mix_group := $grp
										obj::mix_group($sc_build_mix_group, $server_destination)

										$sc_map.sc_build_map2server($x, $server_destination)
										$amp_gt := "group"
									}
								}
						}
					}
			}
		}
		else
		{
			@local $node_int := $node($target).range()[0], $node_int2 := $node($target)

			if($node_int.is_tab() && (!@is_defined($node($target), "_synth")))
			{
				$sc_build_tracks := $node($target).domain()[0]

				print crea_track $sc_build_tracks $sc_build_mix_group
				$amp_gt := "track"

				if ($sc_build_tracks != $sc_build_mix_group) // pour ne pas répéter quand recursion 
				{
					obj::crea_track8s($sc_build_tracks, 0, 0, 0, [], $sc_build_mix_group)

					forall $elem in $node_int.rotate(1)
					{
						$sc_map.sc_build_map2server($elem, $server_destination)				
					}
				}
				else
				{
					$sc_map.sc_build_map2server($node_int[0], $server_destination)
				}

			}
			else
			{						

				if($node_int2("_synth") == "audioOut8") // si c'est la outsynth audioOut8
				{				

					// print audioOut8 (""+$node_int2("_synth")) $sc_build_tracks $sc_build_mix_group
					// print amp amp ($node_int2("amp"))

					
					print amp_amp_gt $amp_gt

					switch ($amp_gt)
				{
					case "track":
						$tracks($sc_build_tracks).amp($node_int2("amp"))
						case "group":
						$groups($sc_build_mix_group).amp($node_int2("amp"))					   		
					}

				}else{
					@local $synths := $node_int2("_synth")

					$node_int2.remove("_synth")
					$node_int2.remove("in")
					$node_int2.remove("out")

					forall $k, $v in $node_int2 //map to tab
					{
						$map2list.push_back($k)
						$map2list.push_back($v)
					}
					// print map2list $map2list
					$tracks($sc_build_tracks).mod_add([$synths].concat($map2list), "top")
					print s_new ([$synths].concat($map2list))
				}
			}
		}
	}
}

@fun_def sc_struct_build($sc_map, $target, $server_name)
{	
	if ($sc_map.is_undef())
	{ 
		print no_map_struct
		return 0 }
	else
	{
		@local $node := $sc_map($server_name), $map2list := [] //, $default_g //, $group, $out_synth

		print node_init (""+$node)
		print target $target

		if ($target.is_string()) // if target is name of mix_group or track
		{
			forall $k, $v in $node
			{
				// print key (""+$k)
				// print val (""+$v)

				if (@is_defined($v, $target))
				{
					print node_target $k
					forall $key, $val in $v
					{
						// print key2 (""+$key)
						// print val2 (""+$val)
						if ($val.is_tab())
						{
							forall $elem in $val
							{
								// print elem_loop $elem
								$Servers($server_name).g_new($elem, 0, $k)
								print elem_loop $elem
								$mix_g := $elem
								// $bus_index := $bus_index + 8 // incremente bus de 8 channels
								$bus_out := 0
								$bus_in := $SC_Servers($server_name)("bus_index") // current bus index for this server

								print default_group bus_in $bus_in
								print default_group bus_out $bus_out
								$sc_map.sc_struct_build($elem, $server_name)
							}
							
						}

					}
				}
			}
		}
		else // if node id
		{
			@local $node_int := $node($target).range()[0], $node_int2 := $node($target)
			if($node_int.is_tab())
			{
				$Servers($server_name).g_new($target, 0, $mix_g) // tracks build into mix_group
				// print default_g1 $default_g
				print g_new2 $target 0 $mix_g
				$group := $target
				print node_int (""+$node_int)

				forall $elem in $node_int.rotate(1)
				{

					print elem_loop2 $elem
					print mix_group bus_in $bus_in
					print mix_group bus_out $bus_out					
					$sc_map.sc_struct_build($elem, $server_name)	
					$bus_out := $bus_in
					// $bus_index := $bus_index + 8 // incremente bus de 8 channels
					$bus_in := $SC_Servers($server_name)("bus_index") // current bus index for this server			
				}
			}
			else
			{						
				// print node3 ($node("synth"))
					print node_int2_node_int2_node_int2 (""+$node_int2)

				if($node_int2("_synth") == "audioOut8") // si c'est la outsynth audioOut8
				{				
					// print bus_index_out $bus_index
					// print bus_in $bus_in
					// print bus_out $bus_out
					// print build out node_int2 ($node_int2("synth")) (" with parameters "+$node_int2) 
					$Servers($server_name).s_new([$node_int2("_synth"), $target, 1, $group, "in", $bus_in, "out", $bus_out, "index", $bus_in, "in_ramp", 1, "amp", $node_int2("amp")])  //target 2 justo despues del nodo 180 audioOut
					print s_new ($node_int2("_synth")) $target 1 $group in $bus_in out $bus_out index $bus_in in_ramp 1 amp 0
					print $target
					$out_synth := $target
					// $bus_index := $bus_index + 8 // incremente bus de 8 channels
					$SC_Servers($server_name).insert("bus_index", $bus_in+8) // inc bus de server  

				}else{
					@local $synths := $node_int2("_synth")
					// print build leaf node_int2 ($node_int2("synth")) (" with parameters "+$node_int2) 

					$node_int2.remove("_synth")
					$node_int2.remove("in")
					$node_int2.remove("out")

					forall $k, $v in $node_int2 //map to tab
					{
						$map2list.push_back($k)
						$map2list.push_back($v)
					}
					// print map2list $map2list
					
					$Servers($server_name).s_new([$synths, $target, 2, $out_synth, "in", $bus_out, "out", $bus_out].concat($map2list))  //target 2 justo despues del nodo 180 audioOut

					print s_new $synths $target 2 $out_synth in $bus_out out $bus_out $map2list
					// $node_int2.remove("_synth") // enleve la pair target "synth"
				
					// fonction qui transforme les pairs target/values qui resten en tab ou aplatir
					// lace entre 2 tab
				}
				// print node_int2 node_int2 $target
			}
		}
	}
}

@fun_def sc_struct_build_id($sc_map, $key, $server_name)
{	
	if ($sc_map.is_undef())
	{ 
		print no_map_struct
		return 0 }
	else
	{
		@local $node := $sc_map($server_name)($key), $map2list := [] //, $default_g //, $group, $out_synth

		if(($node.size() == 1) && (!@is_defined($node, "_synth"))) // if 1 element and not _synth (track) -> TAB
		{
			print node_init (""+$node)
			if(@member($node.domain(), "default_group"))
			{
				forall $elem in $node.range().flatten()
				{
					$Servers($server_name).g_new($elem, 0, 1) // mix_group build into default_group 
					print elem_loop $elem
					$mix_g := $elem
					$bus_index := $bus_index + 8 // incremente bus de 8 channels
					$bus_out := 0
					$bus_in := $bus_index
					print default_group bus_in $bus_in
					print default_group bus_out $bus_out
					$sc_map.sc_struct_build($elem, $server_name)				
				}
			}
			else
			{
				
				$Servers($server_name).g_new($key, 0, $mix_g) // tracks build into mix_group
				// print default_g1 $default_g
				print g_new2 $key 0 $mix_g
				$group := $key
				forall $elem in @range($node)[0].rotate(1)
				{

					print elem_loop2 $elem
					print mix_group bus_in $bus_in
					print mix_group bus_out $bus_out					
					$sc_map.sc_struct_build($elem, $server_name)	
					$bus_out := $bus_in
					$bus_index := $bus_index + 8 // incremente bus de 8 channels
					$bus_in := $bus_index			
				}				
			}
		}
		else
		{						
			// print node3 ($node("synth"))

			if($node("_synth") == "audioOut8") // si c'est la outsynth audioOut8
			{
				// $bus_index := $bus_index + 8
				print node_node_node (""+$node)

				print bus_index_out $bus_index
				print bus_in $bus_in
				print bus_out $bus_out
				// print build out node ($node("synth")) (" with parameters "+$node) 
				$Servers($server_name).s_new([$node("_synth"), $key, 1, $group, "in", $bus_in, "out", $bus_out, "index", $bus_index, "in_ramp", 1, "amp", $node("amp")])  //target 2 justo despues del nodo 180 audioOut
				print s_new ($node("_synth")) $key 1 $group in $bus_in out $bus_out index $bus_index in_ramp 1 amp 0
				print $key
				$out_synth := $key
			}else{
				@local $synths := $node("_synth")
				// print build leaf node ($node("synth")) (" with parameters "+$node) 

				$node.remove("_synth")
				$node.remove("in")
				$node.remove("out")

				

				forall $k, $v in $node //map to tab
				{
					$map2list.push_back($k)
					$map2list.push_back($v)
				}
				// print map2list $map2list
				
				$Servers($server_name).s_new([$synths, $key, 2, $out_synth, "in", $bus_out, "out", $bus_out].concat($map2list))  //target 2 justo despues del nodo 180 audioOut

				print s_new $synths $key 2 $out_synth in $bus_out out $bus_out $map2list
				// $node.remove("_synth") // enleve la pair key "synth"
			
				// fonction qui transforme les pairs key/values qui resten en tab ou aplatir
				// lace entre 2 tab
			}
			// print node node $key
		}
	}
}

// @proc_def alfonsina()
// {
// 	@local $A := 1000000, $B, $C, $annee := 2017
// 	$B := ($A+10000)*0.9 // -> 909000
// 	$C := $A - $B // -> 91000
	
	
// 	print result11 $B
// 	print result12 $C
// 	print result10 $A
// 	print toto ($C>20000)

// 	loop toto 0.01
// 	{
// 		if($C>20000)
// 		{
// 			$A := $B
// 			$B := ($A+10000)*0.9 // -> 827100
// 			$C := $A - $B
// 			// $result0 := $B
// 			print result1 $B
// 			print result2 $C
// 	// print toto ($C>20000)
			
// 			$annee := $annee + 1
// 			print $annee

// 		}
// 		else
// 		{
// 			print result2_else $result2
// 			print $annee
// 			abort toto
// 		}
// 	}
// }

// 1 ::alfonsina()


@fun_def sc_build($sc, $key)
{	
	if (!$sc.is_defined($key))
	{ 
		print no_map_struct
		return 0 }
	else
	{
		@local $node := $sc($key), $map2list := [] //, $group, $out_synth

		// g_new 1 0 0 // create the default group

		if ($node.is_tab())	
		{
			if($key != 0)
			{
				// print build group $key contains ($node.rotate(1))
				// g_new $key 0 1 // build into default group
				// print g_new $key 0 1
				$group := $key
				// $bus_index := $bus_index + 8
				print bus_index_group $bus_index
			}
			print node2 (""+$node)
			print node_rotate (""+$node.rotate(1))
			forall $elem in $node.rotate(1)
			{
				print elem_loop $elem
				$sc.sc_build($elem)
				
			}
		}
		else
		{
			print node_else (""+$node)
			print key $key
			// print node3 ($node("synth"))

			if($node("_synth") == "audioOut8") // si c'est la outsynth audioOut8
			{
				$bus_index := $bus_index + 8
				print bus_index_out $bus_index
				// print build out node ($node("synth")) (" with parameters "+$node) 
				// s_new ($node("_synth")) $key 1 $group in $bus_index out 0 index $bus_index in_ramp 1 amp 0
				// print s_new ($node("_synth")) $key 1 $group in $bus_index out 0 index $bus_index in_ramp 1 amp 0
				$out_synth := $key
			}else{
				// print build leaf node ($node("synth")) (" with parameters "+$node) 

				forall $k, $v in $node //map to tab
				{
					$map2list.push_back($k)
					$map2list.push_back($v)
				}
				// print map2list $map2list
				
				// $node.remove("in") // enleve la pair key "in"
				// $node.remove("out") // enleve la pair key "out"

				// s_new ($node("_synth")) $key 2 $out_synth in $bus_index out $bus_index $map2list
				print s_new ($node("_synth")) $key 2 $out_synth in $bus_index out $bus_index $map2list
				$node.remove("_synth") // enleve la pair key "synth"

				// print node_sin_synth (""+$node)

				// print (@domain($node))
				// print (@range($node))				
				// fonction qui transforme les pairs key/values qui resten en tab ou aplatir
				// lace entre 2 tab
			}
			// print node node $key
		}
	}
}

@fun_def sc_server_tree2map($data)
{	
	@local $i, $d, $group_n, $synth_n

		$i := 0
		$group_n := 0
		$synth_n := 1

		if($data[0] == 0) //global group
		{
		
			print global index ($data[0])
			$i := 5 //offset
			
	    Loop
	   {
		print index_index $i
		// print ($data[$i]) ($data[$i+1]) //($data[$i+2])
		if(($data[$i+1]) != -1)
		{
			$synth_n := 1

			// cellblock set $group_n 0 ($data[$i]) groupo   //($data[$i+1])
			print groupo ($data[$i])
			$sc_struct(1).push_back($data[$i]) 
			$sc_struct.add_pair($data[$i], []) // crea nueva key group
			$group_n := $data[$i]
			$i := $i + 2
			// $group_n := $group_n + 1
			// cellblock set ($group_n-1) $synth_n ($data[$i]) ($data[$i+2])

		}else{
			print synth ($data[$i]) ($data[$i+2])
			$sc_struct($group_n).push_back($data[$i]) // llena tab de index
			$sc_struct.add_pair($data[$i], map{("_synth", $data[$i+2])})
			$i := $i + 3
			$synth_n := $synth_n + 1
		}
		  
	   } while ($i+2 <= @size($data))
    }
}


@fun_def sc_server_tree2map($data)
{	
	@local $i, $d, $group_n, $synth_n

		$i := 0
		$group_n := 0
		$synth_n := 1

		if($data[0] == 0) //global group
		{
		
			print global index ($data[0])
			$i := 5 //offset
			
	    Loop
	   {
		print index_index $i
		// print ($data[$i]) ($data[$i+1]) //($data[$i+2])
		if(($data[$i+1]) != -1)
		{
			$synth_n := 1

			// cellblock set $group_n 0 ($data[$i]) groupo   //($data[$i+1])
			print groupo ($data[$i])
			$sc_struct(1).push_back($data[$i]) 
			$sc_struct.add_pair($data[$i], []) // crea nueva key group
			$group_n := $data[$i]
			$i := $i + 2
			// $group_n := $group_n + 1
			// cellblock set ($group_n-1) $synth_n ($data[$i]) ($data[$i+2])

		}else{
			print synth ($data[$i]) ($data[$i+2])
			$sc_struct($group_n).push_back($data[$i]) // llena tab de index
			$sc_struct.add_pair($data[$i], map{("_synth", $data[$i+2])})
			$i := $i + 3
			$synth_n := $synth_n + 1
		}
		  
	   } while ($i+2 <= @size($data))
    }
}

whenever ($from_sc_server2==$from_sc_server2)
{

	// @sc_server_tree($from_sc_server)
	@sc_server_tree2map2($from_sc_server2)
	1 print (""+$sc_struct)
	@savevalue($home + "/Documents/Doctorado/sc_struct.asco.txt", $sc_struct.remove(0)) //.listify)
	1 $sc_struct.sc_build(0)
	print (@min_key($sc_struct))
	print ($sc_struct(1))
	print (@min_val($sc_struct(1)))
	print (@max_key($sc_struct))

	// $from_sc_server
}

@fun_def sc_server_tree2map2($data)
{	
	@local $i, $d, $group_n, $synth_n, $synth_node

		$i := 0
		$group_n := 0
		$synth_n := 1
		$synth_node := 0

		print sc_server_tree2map2

		if($data[0] == 0) //default group
		{
			$i := 2
			print global index ($data[0])
	    Loop
	   {
		// print ($data[$i]) ($data[$i+1]) //($data[$i+2])
		if(($data[$i+1]) != -1)
		{
			$synth_n := 1

			// cellblock set $group_n 0 ($data[$i]) groupo   //($data[$i+1])
			print groupo ($data[$i])
			print groupo_fils ($data[$i+1])
			$sc_struct(1).push_back($data[$i]) // root tree 0
			$sc_struct.add_pair($data[$i], []) // crea nueva key group

			$group_n := $data[$i]
			$i := $i + 2
			// $group_n := $group_n + 1
			// cellblock set ($group_n-1) $synth_n ($data[$i]) ($data[$i+2])

		}else{
			print synth ($data[$i]) ($data[$i+2])
			print number_params ($data[$i+3])
			$synth_node := $data[$i] // node number for MAP en forall

			$sc_struct($group_n).push_back($data[$i]) // llena tab de index
			$sc_struct.add_pair($data[$i], map{("_synth", $data[$i+2])}) // crea MAP para nombre_synth + parametros

			forall $params in $data[$i+3] // loop recorre lista de parametros
			{
				print params ($data[$i+4]) ($data[$i+5])
				if($data[$i+4] != "in" && $data[$i+4] != "out") // enleve les in/out
				{
					$sc_struct($synth_node).add_pair($data[$i+4], $data[$i+5]) // llena map node_synth con parametros
				}
				$i := $i + 2
			}

			$i := $i + 4 //offset (node_index, -1, synth_name, number_params)
			$synth_n := $synth_n + 1
		}
		  
	   } while ($i+2 <= @size($data))
    }
}




@fun_def sc_server_tree2map2_group($data) //reduce index from 0 to n
{	
	@local $i, $d, $group_n, $synth_n, $synth_node

		$i := 0
		$group_n := 0
		$synth_n := 1
		$synth_node := 0

		print sc_server_tree2map2

		if($data[0] == 0) //default group
		{
			$i := 2
			print global index ($data[0])
	    Loop
	   {
		// print ($data[$i]) ($data[$i+1]) //($data[$i+2])
		if(($data[$i+1]) != -1)
		{
			$synth_n := 1

			// cellblock set $group_n 0 ($data[$i]) groupo   //($data[$i+1])
			print groupo ($data[$i])
			print groupo_fils ($data[$i+1])
			$sc_group_struct(1).push_back($data[$i]) // root tree 0
			$sc_group_struct.add_pair($data[$i], []) // crea nueva key group

			$group_n := $data[$i]
			$i := $i + 2
			// $group_n := $group_n + 1
			// cellblock set ($group_n-1) $synth_n ($data[$i]) ($data[$i+2])

		}else{
			print synth ($data[$i]) ($data[$i+2])
			print number_params ($data[$i+3])
			$synth_node := $data[$i] // node number for MAP en forall

			$sc_group_struct($group_n).push_back($data[$i]) // llena tab de index
			$sc_group_struct.add_pair($data[$i], map{("_synth", $data[$i+2])}) // crea MAP para nombre_synth + parametros

			forall $params in $data[$i+3] // loop recorre lista de parametros
			{
				print params ($data[$i+4]) ($data[$i+5])
				if($data[$i+4] != "in" && $data[$i+4] != "out") // enleve les in/out
				{
					$sc_group_struct($synth_node).add_pair($data[$i+4], $data[$i+5]) // llena map node_synth con parametros
				}
				$i := $i + 2
			}

			$i := $i + 4 //offset (node_index, -1, synth_name, number_params)
			$synth_n := $synth_n + 1
		}
		  
	   } while ($i+2 <= @size($data))
    }
}





// $sc_track_hoa_grain.mod_add(["HOA_Grain3", "envbuf", 54, "buf", 62, "env_rate", 0.1, "t_trig", 1, "dis", 1, "azim", -1, "el", 10])





@proc_def HOA_grain($buf, $envbuf, $dur, $pos, $dist, $azim, $elev, $amp, $mix_group_decoder) 
{
	@local $node_id_mod, $server_name, $main_group_id, $order

		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		// scServer "s_new" ("HOA_Grain"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_rate $dur t_trig 1 dis $dist azim $azim el $elev amp $amp
		$Servers($server_name).s_new(["HOA_Grain"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_rate", $dur, "t_trig", 1, "dis", $dist, "azim", $azim, "el", $elev, "amp", $amp])

		// print ("s_new"+$server_name) ("HOA_Grain"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf env_rate $dur t_trig 1 dis $dist azim $azim el $elev amp $amp


		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_grain_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07) 
{
	@local $node_id_mod, $server_name, $main_group_name, $main_group_id, $order, $xyz_offset

		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		//$space_group($server_name)($main_group_name)("val").add_pair($main_group_id, $xyz)
		// print $main_group_id
		// print $main_group_name
		// print (""+$space_group($server_name)($main_group_name))

		$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print server_test (""+["HOA_Grain_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf ($SF_map($server_name)($buf)) envbuf ($envs($server_name)($envbuf)) pos $pos env_dur $dur t_trig 1 "x" ($x+$HOA_global_x) "y" ($y+$HOA_global_y) "z" ($z+$HOA_global_z) "xoffset" ($xyz_offset[0]) "yoffset" ($xyz_offset[1]) "zoffset" ($xyz_offset[2]) "amp" $amp "rate" $rate "spk_radius" $spk_radius

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_grain_xyz_track($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $track_HOA_NE, $spk_radius = 1.07) 
{
	@local $node_id_mod, $server_name, $main_group_name, $main_group_id, $order, $xyz_offset, $hoa_bus

		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		// $main_group_id := $tracks($track_HOA_NE).$node_id_out
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		//$space_group($server_name)($main_group_name)("val").add_pair($main_group_id, $xyz)
		// print $main_group_id
		// print $main_group_name
		// print (""+$space_group($server_name)($main_group_name))

		$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_id_mod, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print server_test (""+["HOA_Grain_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf ($SF_map($server_name)($buf)) envbuf ($envs($server_name)($envbuf)) pos $pos env_dur $dur t_trig 1 "x" ($x+$HOA_global_x) "y" ($y+$HOA_global_y) "z" ($z+$HOA_global_z) "xoffset" ($xyz_offset[0]) "yoffset" ($xyz_offset[1]) "zoffset" ($xyz_offset[2]) "amp" $amp "rate" $rate "spk_radius" $spk_radius

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_grain_xyz_track_buf($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $track_HOA_NE, $spk_radius = 1.07) 
{
	@local $node_id_mod, $server_name, $main_group_name, $main_group_id, $order, $xyz_offset, $hoa_bus

		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		// $main_group_id := $tracks($track_HOA_NE).$node_id_out
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		//$space_group($server_name)($main_group_name)("val").add_pair($main_group_id, $xyz)
		// print $main_group_id
		// print $main_group_name
		// print (""+$space_group($server_name)($main_group_name))

		$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_id_mod, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $buf, "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print server_test (""+["HOA_Grain_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf ($SF_map($server_name)($buf)) envbuf ($envs($server_name)($envbuf)) pos $pos env_dur $dur t_trig 1 "x" ($x+$HOA_global_x) "y" ($y+$HOA_global_y) "z" ($z+$HOA_global_z) "xoffset" ($xyz_offset[0]) "yoffset" ($xyz_offset[1]) "zoffset" ($xyz_offset[2]) "amp" $amp "rate" $rate "spk_radius" $spk_radius

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOAmbi_grain_xyz_track_buf($buf, $envbuf, $rate, $dur, $pos, $coords, $amp, $track_HOA_NE) 
{
	@local $node_id_mod, $server_name, $main_group_name, $main_group_id, $order, $xyz_offset, $hoa_bus

		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		// $main_group_id := $tracks($track_HOA_NE).$node_id_out
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		//$space_group($server_name)($main_group_name)("val").add_pair($main_group_id, $xyz)
		// print $main_group_id
		// print $main_group_name
		// print (""+$space_group($server_name)($main_group_name))

		$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOAmbi_Grain_xyz"+$order, $node_id_mod, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $buf, "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "coords", $coords+$xyz_offset, "amp", $amp, "rate", $rate])
		// print server_test (""+["HOA_Grain_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf ($SF_map($server_name)($buf)) envbuf ($envs($server_name)($envbuf)) pos $pos env_dur $dur t_trig 1 "x" ($x+$HOA_global_x) "y" ($y+$HOA_global_y) "z" ($z+$HOA_global_z) "xoffset" ($xyz_offset[0]) "yoffset" ($xyz_offset[1]) "zoffset" ($xyz_offset[2]) "amp" $amp "rate" $rate "spk_radius" $spk_radius

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}
// position en secondes
@proc_def HOA_grain_xyz_track2($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $track_HOA_NE, $spk_radius = 1.07) 
{
	@local $node_id_mod, $server_name, $main_group_name, $main_group_id, $order, $xyz_offset

		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$hoa_bus
		$order :=  $tracks($track_HOA_NE).$order

		//$space_group($server_name)($main_group_name)("val").add_pair($main_group_id, $xyz)
		// print $main_group_id
		// print $main_group_name
		// print (""+$space_group($server_name)($main_group_name))

		$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_Grain_pos_xyz"+$order, $node_id_mod, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print server_test (""+["HOA_Grain_pos_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf ($SF_map($server_name)($buf)) envbuf ($envs($server_name)($envbuf)) pos $pos env_dur $dur t_trig 1 "x" ($x+$HOA_global_x) "y" ($y+$HOA_global_y) "z" ($z+$HOA_global_z) "xoffset" ($xyz_offset[0]) "yoffset" ($xyz_offset[1]) "zoffset" ($xyz_offset[2]) "amp" $amp "rate" $rate "spk_radius" $spk_radius

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_grain2_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07) 
{
	@local $node_id_mod, $server_name, $main_group_id, $order

		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		// print buffer_number (""+$SF_map($server_name)($buf))
		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_Grain2_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

		// print grain_concat (""+["HOA_Grain2_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_grain3_xyz($buf, $envbuf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07) 
{
	@local $node_id_mod, $server_name, $main_group_id, $order

		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		print buffer_number (""+$SF_map($server_name)($buf))
		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_Grain2_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $buf, "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_grainIn_xyz_track($in, $envbuf0, $envbuf1, $dur, $del, $env_interp, $x, $y, $z, $amp, $track_HOA_NE) 
{
	@local $node_id_mod, $server_name, $main_group_name, $main_group_id, $order, $xyz_offset, $hoa_bus

		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		// $main_group_id := $tracks($track_HOA_NE).$node_id_out
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		//$space_group($server_name)($main_group_name)("val").add_pair($main_group_id, $xyz)
		// print $main_group_id
		// print $main_group_name
		// print (""+$space_group($server_name)($main_group_name))

		$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_GrainIn_Interp_del_xyz"+$order, $node_id_mod, 2, $main_group_id, "in", $in, "globTBus", $hoa_bus, "envbuf0", $envs($server_name)($envbuf0), "envbuf1", $envs($server_name)($envbuf1), "env_dur", $dur, "del", $del, "env_interp", $env_interp, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp]) //, "rate", $rate, "spk_radius", $spk_radius
		// print server_test (""+["HOA_Grain_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf ($SF_map($server_name)($buf)) envbuf ($envs($server_name)($envbuf)) pos $pos env_dur $dur t_trig 1 "x" ($x+$HOA_global_x) "y" ($y+$HOA_global_y) "z" ($z+$HOA_global_z) "xoffset" ($xyz_offset[0]) "yoffset" ($xyz_offset[1]) "zoffset" ($xyz_offset[2]) "amp" $amp "rate" $rate "spk_radius" $spk_radius

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_DelGrain_xyz($in, $envbuf0, $envbuf1, $dur, $del, $env_interp, $x, $y, $z, $amp, $track_HOA_NE) 
{
	@local $node_id_mod, $server_name, $main_group_name, $main_group_id, $order, $xyz_offset, $hoa_bus

		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		// $main_group_id := $tracks($track_HOA_NE).$node_id_out
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		//$space_group($server_name)($main_group_name)("val").add_pair($main_group_id, $xyz)
		// print $main_group_id
		// print $main_group_name
		// print (""+$space_group($server_name)($main_group_name))

		$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

		// scServer "s_new" ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_DelGrain_xyz"+$order, $node_id_mod, 2, $main_group_id, "in", $in, "globTBus", $hoa_bus, "envbuf0", $envs($server_name)($envbuf0), "envbuf1", $envs($server_name)($envbuf1), "env_dur", $dur, "del", $del, "env_interp", $env_interp, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp]) //, "rate", $rate, "spk_radius", $spk_radius
		// print server_test (""+["HOA_Grain_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos, "env_dur", $dur, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf ($SF_map($server_name)($buf)) envbuf ($envs($server_name)($envbuf)) pos $pos env_dur $dur t_trig 1 "x" ($x+$HOA_global_x) "y" ($y+$HOA_global_y) "z" ($z+$HOA_global_z) "xoffset" ($xyz_offset[0]) "yoffset" ($xyz_offset[1]) "zoffset" ($xyz_offset[2]) "amp" $amp "rate" $rate "spk_radius" $spk_radius

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}

@proc_def HOA_sample_xyz($buf, $rate, $dur, $pos, $x, $y, $z, $amp, $mix_group_decoder, $spk_radius = 1.07) 
{
	@local $node_id_mod, $server_name, $main_group_id, $order

		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_id_mod := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		// scServer "s_new" ("HOA_Play_samp_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf pos $pos t_trig 1 x $x y $y z $z amp $amp rate $rate 
		$Servers($server_name).s_new(["HOA_Play_samp_xyz"+$order, $node_id_mod, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "pos", $pos, "t_trig", 1, "x", $x+$HOA_global_x, "y", $y+$HOA_global_y, "z", $z+$HOA_global_z, "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

		// print ("s_new"+$server_name) ("HOA_Grain_xyz"+$order) $node_id_mod 0 $main_group_id globTBus $hoa_bus buf $buf envbuf $envbuf pos $pos env_dur $dur t_trig 1 x $x y $y z $z amp $amp rate $rate 

		$SC_Servers($server_name).add_pair("node_id", $node_id_mod + 1)
}


@proc_def HOA_grain_xyz_rand_fix($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $mix_group_decoder, $grain_group) 
{
	@local $poltocar, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $ryth_rand, $server_name, $main_group_name
	
	$ryth_rand := @rand_range($ryth_min, $ryth_max)

	// $server_name := $SC_Groups($mix_group_decoder)("server_name")
	$main_group_name := $SC_Groups($mix_group_decoder)("name")

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

	loop circle_rand $ryth_rand
	{
		
		// print (@poltocar(12, $angle_inc_rand))
		$rand_x := @rand_range($x_min, $x_max)
		$rand_y := @rand_range($y_min, $y_max)
		$rand_z := @rand_range($z_min, $z_max)
		$rate := @rand_range($rate_min, $rate_max)	
		$pos := @rand_range($pos_min, $pos_max)
		$env_dur := @rand_range($env_dur_min, $env_dur_max)
		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		// $poltocar := @poltocar(0.5, $angle_inc_rand)
		// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)

		::HOA_grain_xyz($buf, $envbuf, $rate, $env_dur, $pos, $rand_x+$HOA_global_x, $rand_y+$HOA_global_y, $rand_z+$HOA_global_z, $amp, $mix_group_decoder)
		@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

	}

}

@obj_def HOA_grain_xyz_rand_fix_track($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $grain_group) 
{
	@local $poltocar, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $ryth_rand, $server_name, $main_group_name, $curve_xyz := 0, $inner_tempo := 60, $loop_tempo := 60
	@init 
    {
		$ryth_rand := @rand_range($ryth_min, $ryth_max)

		group @tempo $inner_tempo 
		{
			loop circle_rand $ryth_rand
			{
				
				// print (@poltocar(12, $angle_inc_rand))
				$rand_x := @rand_range($x_min, $x_max)
				$rand_y := @rand_range($y_min, $y_max)
				$rand_z := @rand_range($z_min, $z_max)
				$rate := @rand_range($rate_min, $rate_max)	
				$pos := @rand_range($pos_min, $pos_max)
				$env_dur := @rand_range($env_dur_min, $env_dur_max)
				$ryth_rand := @rand_range($ryth_min, $ryth_max)
				// $poltocar := @poltocar(0.5, $angle_inc_rand)
				// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)

				::HOA_grain_xyz_track($buf, $envbuf, $rate, $env_dur, $pos, $rand_x+$HOA_global_x, $rand_y+$HOA_global_y, $rand_z+$HOA_global_z, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

			}
		}
	}
	@fun_def rand_x_min($r_min) 
	{ 
		$x_min := $r_min
	}
	@fun_def rand_x_max($r_max) 
	{ 
		$x_max := $r_max
	}
	@proc_def x_interpol($i_x_min, $i_x_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $x_min_init, $x_max_end
	   $x_min_init := $x_min //init position x_min
	   $x_max_end := $x_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_x_min($l_min)
				$THISOBJ.rand_x_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$x_min, $x_max} @type := $type
			 $t   {$i_x_min, $i_x_max}} 
	   }
	}	
	@proc_def y_interpol($i_y_min, $i_y_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $y_min_init, $y_max_end
	   $y_min_init := $y_min //init position x_min
	   $y_max_end := $y_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_y_min($l_min)
				$THISOBJ.rand_y_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$y_min, $y_max} @type := $type
			 $t   {$i_y_min, $i_y_max}} 
	   }
	}	
	@proc_def z_interpol($i_z_min, $i_z_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $z_min_init, $z_max_end
	   $z_min_init := $z_min //init position x_min
	   $z_max_end := $z_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_z_min($l_min)
				$THISOBJ.rand_z_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$z_min, $z_max} @type := $type
			 $t   {$i_z_min, $i_z_max}} 
	   }
	}		
    @proc_def xyz_interpol($bpf, $loop = 0) 
    {
		@local $nim, $xyz_pos, $inc := 0, $nim_dur, $periode
		$nim := @build_nim_from_bpf($bpf)
		$nim_dur := @max_key($nim)

		$xyz_pos := $bpf[0]
		$periode := (60/$loop_tempo)*$nim_dur
		abort $curve_xyz
		$curve_xyz := { loop $periode
		{
			curve @grain := 0.01, 
			@tempo := $loop_tempo,
			@action 
			{
					$THISOBJ.rand_x_min($xyz_pos[0])
					$THISOBJ.rand_x_max($xyz_pos[1])
					$THISOBJ.rand_y_min($xyz_pos[2])
					$THISOBJ.rand_y_max($xyz_pos[3])
					$THISOBJ.rand_z_min($xyz_pos[4])
					$THISOBJ.rand_z_max($xyz_pos[5])	
					$periode := (60/$loop_tempo)*$nim_dur // actualise la valeur de la periode							
			} 
			{ $xyz_pos : $nim }
			$inc += 1			    
		} until ($inc >= $loop)
		}
    }		
	@fun_def xyz_interpol_stop() 
	{ 
		abort $curve_xyz
	}
	@fun_def rand_y_min($r_min) 
	{ 
		$y_min := $r_min
	}
	@fun_def rand_y_max($r_max) 
	{ 
		$y_max := $r_max
	}
	@fun_def rand_z_min($r_min) 
	{ 
		$z_min := $r_min
	}
	@fun_def rand_z_max($r_max) 
	{ 
		$z_max := $r_max
	}			
	@fun_def ryth_min($r_min) 
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) 
	{ 
		$ryth_max := $r_max
	}	
	@fun_def rate_min($r_min) 
	{ 
		$rate_min := $r_min
	}
	@fun_def rate_max($r_max) 
	{ 
		$rate_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) 
	{ 
		$env_dur_min := $env_d_min
	}
	@fun_def env_dur_max($env_d_max) 
	{ 
		$env_dur_max := $env_d_max
	}
	@fun_def pos_min($p_min) 
	{ 
		$pos_min := $p_min
	}
	@fun_def pos_max($p_max) 
	{ 
		$pos_max := $p_max
	}	
	@fun_def buf($bf) 
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) 
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) 
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def tempo_loop($tpo)
	{ 
		$loop_tempo := $tpo
	}				
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}
}


@obj_def HOA_grain_xyz_rand_fix_track_buf($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $grain_group) 
{
	@local $poltocar, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $ryth_rand, $server_name, $main_group_name, $curve_xyz := 0, $inner_tempo := 60, $loop_tempo := 60
	@init 
    {
		$ryth_rand := @rand_range($ryth_min, $ryth_max)

		group @tempo $inner_tempo 
		{
			loop circle_rand $ryth_rand
			{
				
				// print (@poltocar(12, $angle_inc_rand))
				$rand_x := @rand_range($x_min, $x_max)
				$rand_y := @rand_range($y_min, $y_max)
				$rand_z := @rand_range($z_min, $z_max)
				$rate := @rand_range($rate_min, $rate_max)	
				$pos := @rand_range($pos_min, $pos_max)
				$env_dur := @rand_range($env_dur_min, $env_dur_max)
				$ryth_rand := @rand_range($ryth_min, $ryth_max)
				// $poltocar := @poltocar(0.5, $angle_inc_rand)
				// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)

				::HOA_grain_xyz_track_buf($buf, $envbuf, $rate, $env_dur, $pos, $rand_x+$HOA_global_x, $rand_y+$HOA_global_y, $rand_z+$HOA_global_z, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

			}
		}
	}
	@fun_def rand_x_min($r_min) 
	{ 
		$x_min := $r_min
	}
	@fun_def rand_x_max($r_max) 
	{ 
		$x_max := $r_max
	}
	@proc_def x_interpol($i_x_min, $i_x_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $x_min_init, $x_max_end
	   $x_min_init := $x_min //init position x_min
	   $x_max_end := $x_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_x_min($l_min)
				$THISOBJ.rand_x_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$x_min, $x_max} @type := $type
			 $t   {$i_x_min, $i_x_max}} 
	   }
	}	
	@proc_def y_interpol($i_y_min, $i_y_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $y_min_init, $y_max_end
	   $y_min_init := $y_min //init position x_min
	   $y_max_end := $y_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_y_min($l_min)
				$THISOBJ.rand_y_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$y_min, $y_max} @type := $type
			 $t   {$i_y_min, $i_y_max}} 
	   }
	}	
	@proc_def z_interpol($i_z_min, $i_z_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $z_min_init, $z_max_end
	   $z_min_init := $z_min //init position x_min
	   $z_max_end := $z_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_z_min($l_min)
				$THISOBJ.rand_z_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$z_min, $z_max} @type := $type
			 $t   {$i_z_min, $i_z_max}} 
	   }
	}		
    @proc_def xyz_interpol($bpf, $loop = 0) 
    {
		@local $nim, $xyz_pos, $inc := 0, $nim_dur, $periode
		$nim := @build_nim_from_bpf($bpf)
		$nim_dur := @max_key($nim)

		$xyz_pos := $bpf[0]
		$periode := (60/$loop_tempo)*$nim_dur
		abort $curve_xyz
		$curve_xyz := { loop $periode
		{
			curve @grain := 0.01, 
			@tempo := $loop_tempo,
			@action 
			{
					$THISOBJ.rand_x_min($xyz_pos[0])
					$THISOBJ.rand_x_max($xyz_pos[1])
					$THISOBJ.rand_y_min($xyz_pos[2])
					$THISOBJ.rand_y_max($xyz_pos[3])
					$THISOBJ.rand_z_min($xyz_pos[4])
					$THISOBJ.rand_z_max($xyz_pos[5])	
					$periode := (60/$loop_tempo)*$nim_dur // actualise la valeur de la periode							
			} 
			{ $xyz_pos : $nim }
			$inc += 1			    
		} until ($inc >= $loop)
		}
    }		
	@fun_def xyz_interpol_stop() 
	{ 
		abort $curve_xyz
	}
	@fun_def rand_y_min($r_min) 
	{ 
		$y_min := $r_min
	}
	@fun_def rand_y_max($r_max) 
	{ 
		$y_max := $r_max
	}
	@fun_def rand_z_min($r_min) 
	{ 
		$z_min := $r_min
	}
	@fun_def rand_z_max($r_max) 
	{ 
		$z_max := $r_max
	}			
	@fun_def ryth_min($r_min) 
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) 
	{ 
		$ryth_max := $r_max
	}	
	@fun_def rate_min($r_min) 
	{ 
		$rate_min := $r_min
	}
	@fun_def rate_max($r_max) 
	{ 
		$rate_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) 
	{ 
		$env_dur_min := $env_d_min
	}
	@fun_def env_dur_max($env_d_max) 
	{ 
		$env_dur_max := $env_d_max
	}
	@fun_def pos_min($p_min) 
	{ 
		$pos_min := $p_min
	}
	@fun_def pos_max($p_max) 
	{ 
		$pos_max := $p_max
	}	
	@fun_def buf($bf) 
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) 
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) 
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def tempo_loop($tpo)
	{ 
		$loop_tempo := $tpo
	}				
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}
}

@obj_def HOAmbi_grain_xyz_rand_fix_track_buf($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $grain_group) 
{
	@local $cartopol, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $ryth_rand, $server_name, $main_group_name, $curve_xyz := 0, $inner_tempo := 60, $loop_tempo := 60
	@init 
    {
		$ryth_rand := @rand_range($ryth_min, $ryth_max)

		group @tempo $inner_tempo 
		{
			loop circle_rand $ryth_rand
			{
				
				// print (@cartopol(12, $angle_inc_rand))
				$rand_x := @rand_range($x_min, $x_max)
				$rand_y := @rand_range($y_min, $y_max)
				$rand_z := @rand_range($z_min, $z_max)
				$rate := @rand_range($rate_min, $rate_max)	
				$pos := @rand_range($pos_min, $pos_max)
				$env_dur := @rand_range($env_dur_min, $env_dur_max)
				$ryth_rand := @rand_range($ryth_min, $ryth_max)
				$cartopol := @cartopol3D_compiled($rand_x, $rand_y, $rand_z)
				// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)

				::HOAmbi_grain_xyz_track_buf($buf, $envbuf, $rate, $env_dur, $pos, $cartopol, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

			}
		}
	}
	@fun_def rand_x_min($r_min) 
	{ 
		$x_min := $r_min
	}
	@fun_def rand_x_max($r_max) 
	{ 
		$x_max := $r_max
	}
	@proc_def x_interpol($i_x_min, $i_x_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $x_min_init, $x_max_end
	   $x_min_init := $x_min //init position x_min
	   $x_max_end := $x_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_x_min($l_min)
				$THISOBJ.rand_x_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$x_min, $x_max} @type := $type
			 $t   {$i_x_min, $i_x_max}} 
	   }
	}	
	@proc_def y_interpol($i_y_min, $i_y_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $y_min_init, $y_max_end
	   $y_min_init := $y_min //init position x_min
	   $y_max_end := $y_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_y_min($l_min)
				$THISOBJ.rand_y_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$y_min, $y_max} @type := $type
			 $t   {$i_y_min, $i_y_max}} 
	   }
	}	
	@proc_def z_interpol($i_z_min, $i_z_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $z_min_init, $z_max_end
	   $z_min_init := $z_min //init position x_min
	   $z_max_end := $z_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_z_min($l_min)
				$THISOBJ.rand_z_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$z_min, $z_max} @type := $type
			 $t   {$i_z_min, $i_z_max}} 
	   }
	}		
    @proc_def xyz_interpol($bpf, $loop = 0) 
    {
		@local $nim, $xyz_pos, $inc := 0, $nim_dur, $periode
		$nim := @build_nim_from_bpf($bpf)
		$nim_dur := @max_key($nim)

		$xyz_pos := $bpf[0]
		$periode := (60/$loop_tempo)*$nim_dur
		abort $curve_xyz
		$curve_xyz := { loop $periode
		{
			curve @grain := 0.01, 
			@tempo := $loop_tempo,
			@action 
			{
					$THISOBJ.rand_x_min($xyz_pos[0])
					$THISOBJ.rand_x_max($xyz_pos[1])
					$THISOBJ.rand_y_min($xyz_pos[2])
					$THISOBJ.rand_y_max($xyz_pos[3])
					$THISOBJ.rand_z_min($xyz_pos[4])
					$THISOBJ.rand_z_max($xyz_pos[5])	
					$periode := (60/$loop_tempo)*$nim_dur // actualise la valeur de la periode							
			} 
			{ $xyz_pos : $nim }
			$inc += 1			    
		} until ($inc >= $loop)
		}
    }		
	@fun_def xyz_interpol_stop() 
	{ 
		abort $curve_xyz
	}
	@fun_def rand_y_min($r_min) 
	{ 
		$y_min := $r_min
	}
	@fun_def rand_y_max($r_max) 
	{ 
		$y_max := $r_max
	}
	@fun_def rand_z_min($r_min) 
	{ 
		$z_min := $r_min
	}
	@fun_def rand_z_max($r_max) 
	{ 
		$z_max := $r_max
	}			
	@fun_def ryth_min($r_min) 
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) 
	{ 
		$ryth_max := $r_max
	}	
	@fun_def rate_min($r_min) 
	{ 
		$rate_min := $r_min
	}
	@fun_def rate_max($r_max) 
	{ 
		$rate_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) 
	{ 
		$env_dur_min := $env_d_min
	}
	@fun_def env_dur_max($env_d_max) 
	{ 
		$env_dur_max := $env_d_max
	}
	@fun_def pos_min($p_min) 
	{ 
		$pos_min := $p_min
	}
	@fun_def pos_max($p_max) 
	{ 
		$pos_max := $p_max
	}	
	@fun_def buf($bf) 
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) 
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) 
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def tempo_loop($tpo)
	{ 
		$loop_tempo := $tpo
	}				
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}
}

@obj_def HOAmbi_grain_xyz_rand_fix_track_buf_list($buf_list, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $grain_group) 
{
	@local $cartopol, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $ryth_rand, $server_name, $main_group_name, $curve_xyz := 0, $inner_tempo := 60, $loop_tempo := 60
	@init 
    {
		$ryth_rand := @rand_range($ryth_min, $ryth_max)

		group // @tempo $inner_tempo 
		{
			loop circle_rand $ryth_rand
			{
				
				// print (@cartopol(12, $angle_inc_rand))
				$rand_x := @rand_range($x_min, $x_max)
				$rand_y := @rand_range($y_min, $y_max)
				$rand_z := @rand_range($z_min, $z_max)
				$rate := @rand_range($rate_min, $rate_max)	
				$pos := @rand_range($pos_min, $pos_max)
				$env_dur := @rand_range($env_dur_min, $env_dur_max)
				$ryth_rand := @rand_range($ryth_min, $ryth_max)
				$cartopol := @cartopol3D_compiled($rand_x, $rand_y, $rand_z)
				// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)

				::HOAmbi_grain_xyz_track_buf(@choose($buf_list), $envbuf, $rate, $env_dur, $pos, $cartopol, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

			}
		}
	}
	@fun_def rand_x_min($r_min) 
	{ 
		$x_min := $r_min
	}
	@fun_def rand_x_max($r_max) 
	{ 
		$x_max := $r_max
	}
	@proc_def x_interpol($i_x_min, $i_x_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $x_min_init, $x_max_end
	   $x_min_init := $x_min //init position x_min
	   $x_max_end := $x_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_x_min($l_min)
				$THISOBJ.rand_x_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$x_min, $x_max} @type := $type
			 $t   {$i_x_min, $i_x_max}} 
	   }
	}	
	@proc_def y_interpol($i_y_min, $i_y_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $y_min_init, $y_max_end
	   $y_min_init := $y_min //init position x_min
	   $y_max_end := $y_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_y_min($l_min)
				$THISOBJ.rand_y_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$y_min, $y_max} @type := $type
			 $t   {$i_y_min, $i_y_max}} 
	   }
	}	
	@proc_def z_interpol($i_z_min, $i_z_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $z_min_init, $z_max_end
	   $z_min_init := $z_min //init position x_min
	   $z_max_end := $z_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_z_min($l_min)
				$THISOBJ.rand_z_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$z_min, $z_max} @type := $type
			 $t   {$i_z_min, $i_z_max}} 
	   }
	}		
    @proc_def xyz_interpol($bpf, $loop = 0) 
    {
		@local $nim, $xyz_pos, $inc := 0, $nim_dur, $periode
		$nim := @build_nim_from_bpf($bpf)
		$nim_dur := @max_key($nim)
		print RT_TEMPO $RT_TEMPO
		$xyz_pos := $bpf[0]
		$periode := (60/$RT_TEMPO)*$nim_dur
		abort $curve_xyz
		$curve_xyz := { loop $periode
		{
			curve @grain := 0.01, 
			@tempo := $RT_TEMPO,
			@action 
			{
					$THISOBJ.rand_x_min($xyz_pos[0])
					$THISOBJ.rand_x_max($xyz_pos[1])
					$THISOBJ.rand_y_min($xyz_pos[2])
					$THISOBJ.rand_y_max($xyz_pos[3])
					$THISOBJ.rand_z_min($xyz_pos[4])
					$THISOBJ.rand_z_max($xyz_pos[5])	
					$periode := (60/$RT_TEMPO)*$nim_dur // actualise la valeur de la periode							
			} 
			{ $xyz_pos : $nim }
			$inc += 1			    
		} until ($inc >= $loop)
		}
    }		
	@fun_def xyz_interpol_stop() 
	{ 
		abort $curve_xyz
	}
	@fun_def rand_y_min($r_min) 
	{ 
		$y_min := $r_min
	}
	@fun_def rand_y_max($r_max) 
	{ 
		$y_max := $r_max
	}
	@fun_def rand_z_min($r_min) 
	{ 
		$z_min := $r_min
	}
	@fun_def rand_z_max($r_max) 
	{ 
		$z_max := $r_max
	}			
	@fun_def ryth_min($r_min) 
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) 
	{ 
		$ryth_max := $r_max
	}	
	@fun_def rate_min($r_min) 
	{ 
		$rate_min := $r_min
	}
	@fun_def rate_max($r_max) 
	{ 
		$rate_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) 
	{ 
		$env_dur_min := $env_d_min
	}
	@fun_def env_dur_max($env_d_max) 
	{ 
		$env_dur_max := $env_d_max
	}
	@fun_def pos_min($p_min) 
	{ 
		$pos_min := $p_min
	}
	@fun_def pos_max($p_max) 
	{ 
		$pos_max := $p_max
	}	
	@fun_def buf($bf) 
	{ 
		$buf_list := $bf
	}		
	@fun_def envbuf($eb) 
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) 
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def tempo_loop($tpo)
	{ 
		$loop_tempo := $tpo
	}				
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}
}


@obj_def HOA_grainIN_xyz_rand_fix_track($in, $envbuf0, $envbuf1, $env_interp, $del_min, $del_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE) 
{
	@local $poltocar, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $del, $server_name, $main_group_name, $curve_xyz := 0, $inner_tempo := 60, $loop_tempo := 60, $proc_dico := map {}, $proc_index := 0
	@init 
    {
    	$tab_dico := []
	}
	@fun_def add() 
	{ 
		$tab_dico.push_back(::HOA_grainIn_xyz_proc($in, $envbuf0, $envbuf1, $env_interp, $del_min, $del_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $proc_index))
		$proc_index += 1
	}
	@fun_def remove() 
	{
		if($tab_dico.size()> 0)
		{
			abort $tab_dico[0]
			$tab_dico.remove(0)
		
			// forall $i in 3 // x, y, z
			// {
			// 	$out_pos_final.remove(0)
			// }
		}
		else 
		{
			print no more processes
		}
	}
	@fun_def del($del_mi, $del_ma) 
	{ 
		forall $proc in $tab_dico
		{
			$proc.$del_min := $del_mi
			$proc.$del_max := $del_ma
		}
	}	
	@fun_def env_interp($env_itp) 
	{ 
		forall $proc in $tab_dico
		{
			$proc.$env_interp := $env_itp
		}
	}	
	@fun_def rand_x_min($r_min) 
	{ 
		$x_min := $r_min
	}
	@fun_def rand_x_max($r_max) 
	{ 
		$x_max := $r_max
	}
	@proc_def x_interpol($i_x_min, $i_x_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $x_min_init, $x_max_end
	   $x_min_init := $x_min //init position x_min
	   $x_max_end := $x_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_x_min($l_min)
				$THISOBJ.rand_x_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$x_min, $x_max} @type := $type
			 $t   {$i_x_min, $i_x_max}} 
	   }
	}	
	@proc_def y_interpol($i_y_min, $i_y_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $y_min_init, $y_max_end
	   $y_min_init := $y_min //init position x_min
	   $y_max_end := $y_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_y_min($l_min)
				$THISOBJ.rand_y_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$y_min, $y_max} @type := $type
			 $t   {$i_y_min, $i_y_max}} 
	   }
	}	
	@proc_def z_interpol($i_z_min, $i_z_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $z_min_init, $z_max_end
	   $z_min_init := $z_min //init position x_min
	   $z_max_end := $z_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_z_min($l_min)
				$THISOBJ.rand_z_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$z_min, $z_max} @type := $type
			 $t   {$i_z_min, $i_z_max}} 
	   }
	}		
    @proc_def xyz_interpol($bpf, $loop = 0) 
    {
		@local $nim, $xyz_pos, $inc := 0, $nim_dur, $periode
		$nim := @build_nim_from_bpf($bpf)
		$nim_dur := @max_key($nim)

		$xyz_pos := $bpf[0]
		$periode := (60/$loop_tempo)*$nim_dur
		abort $curve_xyz
		$curve_xyz := { loop $periode
		{
			curve @grain := 0.01, 
			@tempo := $loop_tempo,
			@action 
			{
					$THISOBJ.rand_x_min($xyz_pos[0])
					$THISOBJ.rand_x_max($xyz_pos[1])
					$THISOBJ.rand_y_min($xyz_pos[2])
					$THISOBJ.rand_y_max($xyz_pos[3])
					$THISOBJ.rand_z_min($xyz_pos[4])
					$THISOBJ.rand_z_max($xyz_pos[5])	
					$periode := (60/$loop_tempo)*$nim_dur // actualise la valeur de la periode							
			} 
			{ $xyz_pos : $nim }
			$inc += 1			    
		} until ($inc >= $loop)
		}
    }		
	@fun_def xyz_interpol_stop() 
	{ 
		abort $curve_xyz
	}
	@fun_def rand_y_min($r_min) 
	{ 
		$y_min := $r_min
	}
	@fun_def rand_y_max($r_max) 
	{ 
		$y_max := $r_max
	}
	@fun_def rand_z_min($r_min) 
	{ 
		$z_min := $r_min
	}
	@fun_def rand_z_max($r_max) 
	{ 
		$z_max := $r_max
	}			
	@fun_def ryth_min($r_min) 
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) 
	{ 
		$ryth_max := $r_max
	}	
	@fun_def rate_min($r_min) 
	{ 
		$rate_min := $r_min
	}
	@fun_def rate_max($r_max) 
	{ 
		$rate_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) 
	{ 
		forall $proc in $tab_dico
		{
			$proc.$env_dur_min := $env_d_min
		}
	}
	@fun_def env_dur_max($env_d_max) 
	{ 
		forall $proc in $tab_dico
		{
			$proc.$env_dur_max := $env_d_max
		}		
	}	
	@fun_def envbuf($eb) 
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) 
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def tempo_loop($tpo)
	{ 
		$loop_tempo := $tpo
	}				
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}
}

@obj_def HOA_grainIN_del_xyz($in, $envbuf0, $envbuf1, $env_interp, $rate_min, $rate_max, $del_min, $del_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE) 
{
	@local $poltocar, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $del, $server_name, $main_group_name, $curve_xyz := 0, $inner_tempo := 60, $loop_tempo := 60, $proc_dico := map {}, $proc_index := 0
	@init 
    {
    	// $tab_dico := []
    	$rate := @rand_range($rate_min, $rate_max)

		group @tempo $RT_TEMPO //$inner_tempo 
		{
			loop $rate
			{
				// print env_dur $env_dur
				// print (@poltocar(12, $angle_inc_rand))
				$rand_x := @rand_range($x_min, $x_max)
				$rand_y := @rand_range($y_min, $y_max)
				$rand_z := @rand_range($z_min, $z_max)
				$env_dur := @rand_range($env_dur_min, $env_dur_max)
				$del := @rand_range($del_min, $del_max)
				
				// $poltocar := @poltocar(0.5, $angle_inc_rand)
				// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)
				// @proc_def HOA_grainIn_xyz_track($in, $envbuf0, $envbuf1, $dur, $del, $env_interp, $x, $y, $z, $amp, $track_HOA_NE) 
				// print HOA_grainIn_xyz_track (""+[$in, $envbuf0, $envbuf1, $env_dur, $del, $env_interp, $rand_x+$HOA_global_x, $rand_y+$HOA_global_y, $rand_z+$HOA_global_z, $amp, $track_HOA_NE])
				::HOA_DelGrain_xyz($in, $envbuf0, $envbuf1, $env_dur, $del, $env_interp, $rand_x, $rand_y, $rand_z, $amp, $track_HOA_NE)
				// @command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z // oFx
				$rate := @rand_range($rate_min, $rate_max)	
			}
		}    	
	}
/*	@fun_def add() 
	{ 
		$tab_dico.push_back(::HOA_grainIn_xyz_proc($in, $envbuf0, $envbuf1, $env_interp, $del_min, $del_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $proc_index))
		$proc_index += 1
	}
	@fun_def remove() 
	{
		if($tab_dico.size()> 0)
		{
			abort $tab_dico[0]
			$tab_dico.remove(0)
		
			// forall $i in 3 // x, y, z
			// {
			// 	$out_pos_final.remove(0)
			// }
		}
		else 
		{
			print no more processes
		}
	}*/
	@fun_def del($del_mi, $del_ma) 
	{ 
/*		forall $proc in $tab_dico
		{
			$proc.$del_min := $del_mi
			$proc.$del_max := $del_ma
		}*/
		$del_min := $del_mi
		$del_max := $del_ma
	}	
	@fun_def env_interp($env_itp) 
	{ 
/*		forall $proc in $tab_dico
		{
			$proc.$env_interp := $env_itp
		}*/
	$env_interp := $env_itp		
	}	
	@fun_def rand_x_min($r_min) 
	{ 
		$x_min := $r_min
	}
	@fun_def rand_x_max($r_max) 
	{ 
		$x_max := $r_max
	}
	@proc_def x_interpol($i_x_min, $i_x_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $x_min_init, $x_max_end
	   $x_min_init := $x_min //init position x_min
	   $x_max_end := $x_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_x_min($l_min)
				$THISOBJ.rand_x_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$x_min, $x_max} @type := $type
			 $t   {$i_x_min, $i_x_max}} 
	   }
	}	
	@proc_def y_interpol($i_y_min, $i_y_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $y_min_init, $y_max_end
	   $y_min_init := $y_min //init position x_min
	   $y_max_end := $y_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_y_min($l_min)
				$THISOBJ.rand_y_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$y_min, $y_max} @type := $type
			 $t   {$i_y_min, $i_y_max}} 
	   }
	}	
	@proc_def z_interpol($i_z_min, $i_z_max, $t, $type = "linear") 
	{ 
	    @local $l_min, $l_max, $z_min_init, $z_max_end
	   $z_min_init := $z_min //init position x_min
	   $z_max_end := $z_max //init position x_max
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.rand_z_min($l_min)
				$THISOBJ.rand_z_max($l_max)
	} 
	   { $l_min, $l_max {            
				    {$z_min, $z_max} @type := $type
			 $t   {$i_z_min, $i_z_max}} 
	   }
	}		
    @proc_def xyz_interpol($bpf, $loop = 0) 
    {
		@local $nim, $xyz_pos, $inc := 0, $nim_dur, $periode
		$nim := @build_nim_from_bpf($bpf)
		$nim_dur := @max_key($nim)

		$xyz_pos := $bpf[0]
		$periode := (60/$loop_tempo)*$nim_dur
		abort $curve_xyz
		$curve_xyz := { loop $periode
		{
			curve @grain := 0.01, 
			@tempo := $loop_tempo,
			@action 
			{
					$THISOBJ.rand_x_min($xyz_pos[0])
					$THISOBJ.rand_x_max($xyz_pos[1])
					$THISOBJ.rand_y_min($xyz_pos[2])
					$THISOBJ.rand_y_max($xyz_pos[3])
					$THISOBJ.rand_z_min($xyz_pos[4])
					$THISOBJ.rand_z_max($xyz_pos[5])	
					$periode := (60/$loop_tempo)*$nim_dur // actualise la valeur de la periode							
			} 
			{ $xyz_pos : $nim }
			$inc += 1			    
		} until ($inc >= $loop)
		}
    }		
	@fun_def xyz_interpol_stop() 
	{ 
		abort $curve_xyz
	}
	@fun_def rand_y_min($r_min) 
	{ 
		$y_min := $r_min
	}
	@fun_def rand_y_max($r_max) 
	{ 
		$y_max := $r_max
	}
	@fun_def rand_z_min($r_min) 
	{ 
		$z_min := $r_min
	}
	@fun_def rand_z_max($r_max) 
	{ 
		$z_max := $r_max
	}			
	@fun_def ryth_min($r_min) 
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) 
	{ 
		$ryth_max := $r_max
	}	
	@fun_def rate_min($r_min) 
	{ 
		$rate_min := $r_min
	}
	@fun_def rate_max($r_max) 
	{ 
		$rate_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) 
	{ 
		/*forall $proc in $tab_dico
		{
			$proc.$env_dur_min := $env_d_min
		}*/
		$env_dur_min := $env_d_min
	}
	@fun_def env_dur_max($env_d_max) 
	{ 
		/*forall $proc in $tab_dico
		{
			$proc.$env_dur_max := $env_d_max
		}		*/
		$env_dur_max := $env_d_max
	}	
	@fun_def envbuf($eb) 
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) 
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def tempo_loop($tpo)
	{ 
		$loop_tempo := $tpo
	}				
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}
}

@proc_def ::HOA_grainIn_xyz_proc($in, $envbuf0, $envbuf1, $env_interp, $del_min, $del_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $grain_group)
{
	@local $dur, $inner_tempo  := 60, $rand_x, $rand_y, $rand_z, $env_dur := 0, $del

	// $env_dur := @rand_range($env_dur_min, $env_dur_max)

	group @tempo $RT_TEMPO //$inner_tempo 
	{
		loop circle_rand $env_dur
		{
			print env_dur $env_dur
			// print (@poltocar(12, $angle_inc_rand))
			$rand_x := @rand_range($x_min, $x_max)
			$rand_y := @rand_range($y_min, $y_max)
			$rand_z := @rand_range($z_min, $z_max)
			// $rate := @rand_range($rate_min, $rate_max)	
			$del := @rand_range($del_min, $del_max)
			
			// $poltocar := @poltocar(0.5, $angle_inc_rand)
			// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)
			// @proc_def HOA_grainIn_xyz_track($in, $envbuf0, $envbuf1, $dur, $del, $env_interp, $x, $y, $z, $amp, $track_HOA_NE) 
			// print HOA_grainIn_xyz_track (""+[$in, $envbuf0, $envbuf1, $env_dur, $del, $env_interp, $rand_x+$HOA_global_x, $rand_y+$HOA_global_y, $rand_z+$HOA_global_z, $amp, $track_HOA_NE])
			::HOA_grainIn_xyz_track($in, $envbuf0, $envbuf1, $env_dur, $del, $env_interp, $rand_x+$HOA_global_x, $rand_y+$HOA_global_y, $rand_z+$HOA_global_z, $amp, $track_HOA_NE)
			// @command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z // oFx
			$env_dur := @rand_range($env_dur_min, $env_dur_max)


		}
	}
}


// @proc_def HOA_grain_xyz_rand_pos_mod($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $mix_group_decoder, $grain_group) 
// {
// 	@local $poltocar, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $ryth_rand
	
// 	$ryth_rand := @rand_range($ryth_min, $ryth_max)

// 	loop circle_rand $ryth_rand
// 	{
		
// 		// print (@poltocar(12, $angle_inc_rand))
// 		$rand_x := @rand_range($x_min, $x_max)
// 		$rand_y := @rand_range($y_min, $y_max)
// 		$rand_z := @rand_range($z_min, $z_max)
// 		$rate := @rand_range($rate_min, $rate_max)
// 		$pos := @rand_range($pos_min, $pos_max)
// 		$env_dur := @rand_range($env_dur_min, $env_dur_max)
// 		$ryth_rand := @rand_range($ryth_min, $ryth_max)
// 		// $poltocar := @poltocar(0.5, $angle_inc_rand)
// 		// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)

// 		::HOA_grain_xyz($buf, $envbuf, $rate, $env_dur, $pos, $rand_x, $rand_y, $rand_z, $amp, "group_hoa_binaural")
// 		scServer "of_grains" @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

// 	}

// }

@proc_def HOA_sample_xyz_rand_fix($buf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $mix_group_decoder, $grain_group) 
{
	@local $poltocar, $rand_x, $rand_y, $rand_z, $env_dur, $rate, $pos, $ryth_rand, $server_name
	
	$ryth_rand := @rand_range($ryth_min, $ryth_max)

	// $server_name := $SC_Groups($mix_group_decoder)("server_name")

	loop circle_rand $ryth_rand
	{
		
		// print (@poltocar(12, $angle_inc_rand))
		$rand_x := @rand_range($x_min, $x_max)
		$rand_y := @rand_range($y_min, $y_max)
		$rand_z := @rand_range($z_min, $z_max)
		$rate := @rand_range($rate_min, $rate_max)
		$pos := @rand_range($pos_min, $pos_max)
		// $env_dur := @rand_range($env_dur_min, $env_dur_max)
		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		// $poltocar := @poltocar(0.5, $angle_inc_rand)
		// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)

		::HOA_sample_xyz($buf, $rate, $pos, $rand_x+$HOA_global_x, $rand_y+$HOA_global_y, $rand_z+$HOA_global_z, $amp, $mix_group_decoder)
		@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z


	}

}


	// ::HOA_grain_xyz(53, 55, @rand_range(1,2), $env_dur, $pos, $rand_x, $rand_y, $rand_z, 0, "group_hoa_binaural")

@obj_def HOA_grain_xyz_rand_pos_mod_track($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $track_HOA_NE, $grain_group) 
{
	@init 
    {
		@local $rand_x := 0, $rand_y := 0, $rand_z := 0, $env_dur := 0.1, $rate := 1, $pos := 0, $ryth_rand := 0.1, $tpo := 120, $server_name, $main_group_name

		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_x($THISOBJ), $x_min, $x_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_y($THISOBJ), $y_min, $y_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_z($THISOBJ), $z_min, $z_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos($THISOBJ), $pos_min, $pos_max, 1, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 1, "linear", $tpo)


		$ryth_rand := @rand_range($ryth_min, $ryth_max)

		// $server_name := $SC_Groups($mix_group_decoder)("server_name")
		// $main_group_name := $SC_Groups($mix_group_decoder)("name")

		// if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		// {
		// 	print already defined "xyz_offset"
		// }
		// else
		// {
		// 	$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		// }		

		loop circle_rand $ryth_rand
		{
			
			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $poltocar := @poltocar(0.5, $angle_inc_rand)
			// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)
			// print pos $pos
			// print rand_x $rand_x
			// print $buf $envbuf $rate $env_dur $pos $rand_x $rand_y $rand_z $amp $mix_group_decoder
			// print pos $pos
			// print $buf $envbuf $rate $env_dur $pos ($rand_x+@rand(0.5)) ($rand_y+@rand(0.5)) ($rand_z+@rand(0.5)) $amp $mix_group_decoder
			// print buf $buf
			// print server $server_name
			// print (""+$SF_map($server_name)($buf))
			// print (""+$envs($server_name)($envbuf))
			// print $amp
			::HOA_grain_xyz_track($buf, $envbuf, $rate, $env_dur, $pos, $rand_x+@rand(0.5)+$HOA_global_x, $rand_y+@rand(0.5)+$HOA_global_y, $rand_z+@rand(0.5)+$HOA_global_z, $amp, $track_HOA_NE)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

		}

	}

	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}
	@fun_def rand_x($x) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_x := $x
		// print x $x
	}
	@fun_def rand_y($y) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_y := $y
		// print y $y
	}
	@fun_def rand_z($z) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_z := $z
		// print z $z
	}
	@fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate := $rate_val
		// print rate_val $rate_val
	}
	@fun_def pos($pos_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur := $env_dur_val
		// print env_dur_val $env_dur_val
	}
	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	@fun_def env_dur_min($e_d_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $e_d_min
	}
	@fun_def env_dur_max($e_d_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $e_d_max
	}		
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}		
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}	
}

@obj_def HOA_grain_xyz_rand_pos_mod($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $mix_group_decoder, $grain_group) 
{
	@init 
    {
		@local $rand_x := 0, $rand_y := 0, $rand_z := 0, $env_dur := 0.1, $rate := 1, $pos := 0, $ryth_rand := 0.1, $tpo := 120, $server_name, $main_group_name

		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_x($THISOBJ), $x_min, $x_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_y($THISOBJ), $y_min, $y_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_z($THISOBJ), $z_min, $z_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos($THISOBJ), $pos_min, $pos_max, 1, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 1, "linear", $tpo)


		$ryth_rand := @rand_range($ryth_min, $ryth_max)

		// $server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}		

		loop circle_rand $ryth_rand
		{
			
			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $poltocar := @poltocar(0.5, $angle_inc_rand)
			// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)
			// print pos $pos
			// print rand_x $rand_x
			// print $buf $envbuf $rate $env_dur $pos $rand_x $rand_y $rand_z $amp $mix_group_decoder
			// print pos $pos
			// print $buf $envbuf $rate $env_dur $pos ($rand_x+@rand(0.5)) ($rand_y+@rand(0.5)) ($rand_z+@rand(0.5)) $amp $mix_group_decoder
			// print buf $buf
			// print server $server_name
			// print (""+$SF_map($server_name)($buf))
			// print (""+$envs($server_name)($envbuf))
			::HOA_grain_xyz($buf, $envbuf, $rate, $env_dur, $pos, $rand_x+@rand(0.5)+$HOA_global_x, $rand_y+@rand(0.5)+$HOA_global_y, $rand_z+@rand(0.5)+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

		}

	}

	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}
	@fun_def rand_x($x) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_x := $x
		// print x $x
	}
	@fun_def rand_y($y) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_y := $y
		// print y $y
	}
	@fun_def rand_z($z) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_z := $z
		// print z $z
	}
	@fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate := $rate_val
		// print rate_val $rate_val
	}
	@fun_def pos($pos_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur := $env_dur_val
		// print env_dur_val $env_dur_val
	}
	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	@fun_def env_dur_min($e_d_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $e_d_min
	}
	@fun_def env_dur_max($e_d_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $e_d_max
	}		
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}		
}


@obj_def HOA_samp_xyz_rand_pos_mod($buf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $mix_group_decoder, $grain_group) 
{
	@init 
    {
		@local $rand_x := 0, $rand_y := 0, $rand_z := 0, $env_dur := 0.1, $rate := 1, $pos := 0, $ryth_rand := 0.1, $tpo := 120, $server_name

		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_x($THISOBJ), $x_min, $x_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_y($THISOBJ), $y_min, $y_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_z($THISOBJ), $z_min, $z_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos($THISOBJ), $pos_min, $pos_max, 0., "linear", $tpo)
		// $THISOBJ.rand_lfo_basic_obj($THISOBJ.env_dur, $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)

		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		$server_name := $SC_Groups($mix_group_decoder)("server_name")

		loop circle_rand $ryth_rand
		{
			
			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $poltocar := @poltocar(0.5, $angle_inc_rand)
			// $pos := $angle_inc_rand.scale(0, 360, 0., 1., 1)
			// print pos $pos
			// print rand_x $rand_x
			// print $buf $envbuf $rate $env_dur $pos $rand_x $rand_y $rand_z $amp $mix_group_decoder

			::HOA_sample_xyz($SF_map($server_name)($buf), $rate, $pos, $rand_x+@rand(0.5)+$HOA_global_x, $rand_y+@rand(0.5)+$HOA_global_y, $rand_z+@rand(0.5)+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) $rand_x $rand_y $rand_z

		}

	}

	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}
	@fun_def rand_x($x) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_x := $x
	}
	@fun_def rand_y($y) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_y := $y
	}
	@fun_def rand_z($z) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_z := $z
	}
	@fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate := $rate_val
	}
	@fun_def pos($pos_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos := $pos_val
	}
	@fun_def env_dur($env_dur_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur := $env_dur_val
	}

}

@obj_def HOA_grain_xyz_rand_pos_mod2_track($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $rand_lfo_x_min, $rand_lfo_x_max, $rand_lfo_y_min, $rand_lfo_y_max, $rand_lfo_z_min, $rand_lfo_z_max, $pos_lfo_min, $pos_lfo_max, $amp, $track_HOA_NE, $grain_group) 
{
	@init 
    {
		@local $rand_x := 0, $rand_y := 0, $rand_z := 0, $env_dur := 0.1, $rate := 1, $pos := 0, $ryth_rand := 0.1, $tpo := 60, $rrand_x, $rrand_y, $rrand_z, $rrate, $r_env_dur, $pos_lfo, $lfo_rand_x, $lfo_rand_y, $lfo_rand_z, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $server_name, $inner_tempo := 60, $loop_tempo := 60, $buf_tab, $buf_prob := 1, $curv_prob := 0

		group @tempo $inner_tempo 
		{
			$lfo_rand_x := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_x($THISOBJ), $rand_lfo_x_min, $rand_lfo_x_max, 0.5, "linear", $tpo)
			$lfo_rand_y := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_y($THISOBJ), $rand_lfo_y_min, $rand_lfo_y_max, 0.5, "linear", $tpo)
			$lfo_rand_z := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_z($THISOBJ), $rand_lfo_z_min, $rand_lfo_z_max, 0.5, "linear", $tpo)
			$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
			$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_lfo_min, $pos_lfo_max, 0., "linear", $tpo)
			$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)

			$buf_tab := [$buf, $buf]
			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $server_name := $SC_Groups($mix_group_decoder)("server_name")

			loop circle_rand $ryth_rand
			{
				if(@rand(1) < $buf_prob)
				{
					$buf := $buf_tab[0]
				}
				else 
				{
					$buf := $buf_tab[1]
				}
				$rrand_x := @rand_range($x_min, $x_max)
				$rrand_y := @rand_range($y_min, $y_max)
				$rrand_z := @rand_range($z_min, $z_max)
				// $rrate := @rand_range($rate_min, $rate_max)
				$pos := @rand_range($pos_min, $pos_max)
				$r_env_dur := @rand_range($env_dur_min, $env_dur_max)
				$ryth_rand := @rand_range($ryth_min, $ryth_max)

				// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($rand_x+$rrand_x) ($rand_y+$rrand_y) ($rand_z*$rrand_z) $amp $mix_group_decoder

				::HOA_grain_xyz_track($buf, $envbuf, $rate, $r_env_dur, $pos, $rand_x+@rand(0.5)+$HOA_global_x, $rand_y+@rand(0.5)+$HOA_global_y, $rand_z+@rand(0.5)+$HOA_global_z, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($r_env_dur) ($rand_x+$rrand_x) ($rand_y+$rrand_y) ($rand_z*$rrand_z)

			}
		}
	}

	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}
	@fun_def rand_x($x) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_x := $x
	}
	@fun_def rand_y($y) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_y := $y
	}
	@fun_def rand_z($z) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_z := $z
	}
	@fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate := $rate_val
	}
	@fun_def pos_lfo($pos_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_lfo := $pos_val
	}
	@fun_def env_dur($env_dur_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur := $env_dur_val
	}
	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $env_d_min
	}
	@fun_def env_dur_max($env_d_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $env_d_max
	}
	@fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_min := $p_min
	}
	@fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_max := $p_max
	}
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_x.$tpo := $t
		$lfo_rand_y.$tpo := $t
		$lfo_rand_z.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
	}
	@proc_def buf($bf, $t = 0, $type = "linear") // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $lprob
		$buf_tab.remove(0)
		$buf_tab.push_back($bf)
		abort $curv_prob
		$curv_prob := { Curve
			   @grain := 0.01,
			   @action { $buf_prob := $lprob} 
			   { $lprob {            
						 {1} @type := $type
					 $t   {0}} 
			   }
		}
		// $buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def buf_prob($prob)
	{ 
		$buf_prob := $prob
	}			
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}	
}

@obj_def HOAmbi_grain_xyz_rand_pos_mod2_track($buf_list, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $rand_lfo_x_min, $rand_lfo_x_max, $rand_lfo_y_min, $rand_lfo_y_max, $rand_lfo_z_min, $rand_lfo_z_max, $pos_lfo_min, $pos_lfo_max, $amp, $track_HOA_NE, $grain_group) 
{
	@init 
    {
		@local $cartopol, $rand_x := 0, $rand_y := 0, $rand_z := 0, $env_dur := 0.1, $rate := 1, $pos := 0, $ryth_rand := 0.1, $tpo := 60, $rrand_x, $rrand_y, $rrand_z, $rrate, $r_env_dur, $pos_lfo, $lfo_rand_x, $lfo_rand_y, $lfo_rand_z, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $server_name, $inner_tempo := 60, $loop_tempo := 60, $buf_tab, $buf_prob := 1, $curv_prob := 0

		group @tempo $inner_tempo 
		{
			$lfo_rand_x := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_x($THISOBJ), $rand_lfo_x_min, $rand_lfo_x_max, 0.5, "linear", $tpo)
			$lfo_rand_y := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_y($THISOBJ), $rand_lfo_y_min, $rand_lfo_y_max, 0.5, "linear", $tpo)
			$lfo_rand_z := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_z($THISOBJ), $rand_lfo_z_min, $rand_lfo_z_max, 0.5, "linear", $tpo)
			$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
			$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_lfo_min, $pos_lfo_max, 0., "linear", $tpo)
			$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)

			// $buf_tab := [$buf, $buf]
			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $server_name := $SC_Groups($mix_group_decoder)("server_name")

			loop circle_rand $ryth_rand
			{
				// if(@rand(1) < $buf_prob)
				// {
				// 	$buf := $buf_tab[0]
				// }
				// else 
				// {
				// 	$buf := $buf_tab[1]
				// }
				$rrand_x := @rand_range($x_min, $x_max)
				$rrand_y := @rand_range($y_min, $y_max)
				$rrand_z := @rand_range($z_min, $z_max)
				// $rrate := @rand_range($rate_min, $rate_max)
				$pos := @rand_range($pos_min, $pos_max)
				$r_env_dur := @rand_range($env_dur_min, $env_dur_max)
				$ryth_rand := @rand_range($ryth_min, $ryth_max)
				$cartopol := @cartopol3D_compiled($rand_x+$rrand_x, $rand_y+$rrand_y, $rand_z*$rrand_z)

				// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($rand_x+$rrand_x) ($rand_y+$rrand_y) ($rand_z*$rrand_z) $amp $mix_group_decoder
				::HOAmbi_grain_xyz_track_buf(@choose($buf_list), $envbuf, $rate, $r_env_dur, $pos, $cartopol, $amp, $track_HOA_NE)

				// ::HOA_grain_xyz_track($buf, $envbuf, $rate, $r_env_dur, $pos, $cartopol, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($r_env_dur) ($rand_x+$rrand_x) ($rand_y+$rrand_y) ($rand_z*$rrand_z)

			}
		}
	}

	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}
	@fun_def rand_x($x) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_x := $x
	}
	@fun_def rand_y($y) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_y := $y
	}
	@fun_def rand_z($z) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_z := $z
	}
	@fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate := $rate_val
	}
	@fun_def pos_lfo($pos_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_lfo := $pos_val
	}
	@fun_def env_dur($env_dur_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur := $env_dur_val
	}
	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	@fun_def env_dur_min($env_d_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $env_d_min
	}
	@fun_def env_dur_max($env_d_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $env_d_max
	}
	@fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_min := $p_min
	}
	@fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_max := $p_max
	}
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_x.$tpo := $t
		$lfo_rand_y.$tpo := $t
		$lfo_rand_z.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
	}
	@proc_def buf($bf) //, $t = 0, $type = "linear") // seulement quand une un track a plusieurs instances du même module
	{ 
		// @local $lprob
		// $buf_tab.remove(0)
		// $buf_tab.push_back($bf)
		// abort $curv_prob
		// $curv_prob := { Curve
		// 	   @grain := 0.01,
		// 	   @action { $buf_prob := $lprob} 
		// 	   { $lprob {            
		// 				 {1} @type := $type
		// 			 $t   {0}} 
		// 	   }
		// }
		$buf_list := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}	
	@fun_def tempo_grain($tpo)
	{ 
		$inner_tempo := $tpo
	}	
	@fun_def buf_prob($prob)
	{ 
		$buf_prob := $prob
	}			
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}	
}
@obj_def HOA_grain_polar_vol_rand_lfo($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $radio_min, $radio_max, $theta_min, $theta_max, $phi_min, $phi_max, $init_radio, $init_theta, $init_phi, $pos_lfo_min, $pos_lfo_max, $amp, $mix_group_decoder, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_radio := 0, $rand_theta := 0, $rand_phi := 0, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $pos_lfo, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $lfo_rand_phi, $lfo_rand_theta, $lfo_rand_radio, $node_inc

		$lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		$lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		$lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_lfo_min, $pos_lfo_max, 0., "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)

		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

			$ryth_rand := @rand_range($ryth_min, $ryth_max)

			$poltocar := @poltocar3D_compiled($rand_radio, $rand_phi, $rand_theta)

			// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $mix_group_decoder
			$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

			$node_inc += 1
			$SC_Servers($server_name).add_pair("node_id", $node_inc)

			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
		}


	}

	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}
	@fun_def rand_radio($r) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_radio := $r
	}
	@fun_def rand_theta($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_theta := $t
	}
	@fun_def rand_phi($p) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_phi := $p
	}
	@fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate := $rate_val
	}
	@fun_def pos_lfo($pos_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_lfo := $pos_val
	}
	@fun_def env_dur($env_dur_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur := $env_dur_val
	}
	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_radio.$tpo := $t
		$lfo_rand_theta.$tpo := $t
		$lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}		
}


@obj_def HOA_grain_polar_vol_rand_pos($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $radio_min, $radio_max, $theta_min, $theta_max, $phi_min, $phi_max, $pos_min, $pos_max, $amp, $mix_group_decoder, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_radio := 0, $rand_theta := 0, $rand_phi := 0, $rand_pos, $rand_env_dur, $rand_rate, $ryth_rand := 0.1, $tpo := 120, $node_inc


		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")


		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")


			// $rrate := @rand_range($rate_min, $rate_max)
			$rand_radio := @rand_range($radio_min, $radio_max)
			$rand_theta := @rand_range($theta_min, $theta_max)
			$rand_phi := @rand_range($phi_min, $phi_max)-180 // offset -180

			$rand_pos := @rand_range($pos_min, $pos_max)

			$rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
			$rand_rate := @rand_range($rate_min, $rate_max)

			$ryth_rand := @rand_range($ryth_min, $ryth_max)

			$poltocar := @poltocar3D_compiled($rand_radio, $rand_phi, $rand_theta)

			// print (""+["HOA_Grain_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rand_rate, "spk_radius", $spk_radius])

			$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rand_rate, "spk_radius", $spk_radius])

			$node_inc += 1
			$SC_Servers($server_name).add_pair("node_id", $node_inc)

			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($rand_env_dur) ($poltocar[0]+$xyz_offset[0]+$HOA_global_x) ($poltocar[1]+$xyz_offset[1]+$HOA_global_y) ($poltocar[2]+$xyz_offset[2]++$HOA_global_z)
		}
	}
	@fun_def rate_min($rmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_min := $rmin
	}
	@fun_def rate_max($rmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_max := $rmax
	}

	@fun_def ryth_min($rymin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $rymin
	}
	@fun_def ryth_max($rymax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $rymax
	}

	@fun_def env_dur_min($edmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $edmin
	}
	@fun_def env_dur_max($edmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $edmax
	}

	@fun_def radio_min($rdmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio_min := $rdmin
	}
	@fun_def radio_max($rdmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio_max := $rdmax
	}
	

	@fun_def theta_min($tmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$theta_min := $tmin
	}
	@fun_def theta_max($tmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$theta_max := $tmax
	}

	@fun_def phi_min($phmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$phi_min := $phmin
	}
	@fun_def phi_max($phmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$phi_max := $phmax
	}	

	@fun_def pos_min($posmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_min := $posmin
	}
	@fun_def pos_max($posmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_max := $posmax
	}	

	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}		
}

@obj_def HOA_grain_polar_vol_rand_pos2($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $radio_min, $radio_max, $theta_min, $theta_max, $phi_min, $phi_max, $pos_min, $pos_max, $amp, $track_HOA_NE, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_radio := 0, $rand_theta := 0, $rand_phi := 0, $rand_pos, $rand_env_dur, $rand_rate, $ryth_rand := 0.1, $tpo := 120, $node_inc, $in_buf


		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		if($SF_map.is_defined($server_name)) // si serveur a chargé les SF
		{
			if($SF_map($server_name).is_defined($buf)) // If it's a soundfile in the SF_dir
			{
				$in_buf := $SF_map($server_name)($buf)
			}
			else // if not defined use the buffer id number
			{
				$in_buf := $buf
			}
		}
		else // if not defined use the buffer id number
		{
			$in_buf := $buf
		}

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")


			// $rrate := @rand_range($rate_min, $rate_max)
			$rand_radio := @rand_range($radio_min, $radio_max)
			$rand_theta := @rand_range($theta_min, $theta_max)
			$rand_phi := @rand_range($phi_min, $phi_max)-180 // offset -180

			$rand_pos := @rand_range($pos_min, $pos_max)

			$rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
			$rand_rate := @rand_range($rate_min, $rate_max)

			$ryth_rand := @rand_range($ryth_min, $ryth_max)

			$poltocar := @poltocar3D_compiled($rand_radio, $rand_phi, $rand_theta)

			// print (""+["HOA_Grain_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $in_buf, "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rand_rate, "spk_radius", $spk_radius])

			$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $in_buf, "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rand_rate, "spk_radius", $spk_radius])

			$node_inc := $SC_Servers($server_name)("node_id") + 1
			$SC_Servers($server_name).add_pair("node_id", $node_inc)

			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			// @command("of_grains"+$grain_group) @dur2mlsec($rand_env_dur) ($poltocar[0]+$xyz_offset[0]+$HOA_global_x) ($poltocar[1]+$xyz_offset[1]+$HOA_global_y) ($poltocar[2]+$xyz_offset[2]++$HOA_global_z)
		}
	}
	@fun_def rate_min($rmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_min := $rmin
	}
	@fun_def rate_max($rmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_max := $rmax
	}

	@fun_def ryth_min($rymin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $rymin
	}
	@fun_def ryth_max($rymax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $rymax
	}

	@fun_def env_dur_min($edmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $edmin
	}
	@fun_def env_dur_max($edmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $edmax
	}

	@fun_def radio_min($rdmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio_min := $rdmin
	}
	@fun_def radio_max($rdmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio_max := $rdmax
	}
	

	@fun_def theta_min($tmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$theta_min := $tmin
	}
	@fun_def theta_max($tmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$theta_max := $tmax
	}

	@fun_def phi_min($phmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$phi_min := $phmin
	}
	@fun_def phi_max($phmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$phi_max := $phmax
	}	

	@fun_def pos_min($posmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_min := $posmin
	}
	@fun_def pos_max($posmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_max := $posmax
	}	

	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}		
}

@obj_def HOAmbi_grain_polar_vol_rand_pos2($buf_list, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $radio_min, $radio_max, $theta_min, $theta_max, $phi_min, $phi_max, $pos_min, $pos_max, $amp, $track_HOA_NE, $grain_group) 
{
	@init 
    {
		@local $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_radio := 0, $rand_theta := 0, $rand_phi := 0, $rand_pos, $rand_env_dur, $rand_rate, $ryth_rand := 0.1, $tpo := 120, $node_inc, $in_buf


		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		// $server_name := $tracks($track_HOA_NE).$server_name
		// $main_group_name := $tracks($track_HOA_NE).$group_name
		// $main_group_id := $tracks($track_HOA_NE).$node_id_out
		// // $node_inc := $SC_Servers($server_name)("node_id") // last id
		// $hoa_bus := $tracks($track_HOA_NE).$bus
		// $order :=  $tracks($track_HOA_NE).$order

		// if($SF_map.is_defined($server_name)) // si serveur a chargé les SF
		// {
		// 	if($SF_map($server_name).is_defined($buf)) // If it's a soundfile in the SF_dir
		// 	{
		// 		$in_buf := $SF_map($server_name)($buf)
		// 	}
		// 	else // if not defined use the buffer id number
		// 	{
		// 		$in_buf := $buf
		// 	}
		// }
		// else // if not defined use the buffer id number
		// {
		// 	$in_buf := $buf
		// }

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")


			// $rrate := @rand_range($rate_min, $rate_max)
			$rand_radio := @rand_range($radio_min, $radio_max)
			$rand_theta := @rand_range($theta_min, $theta_max)
			$rand_phi := @rand_range($phi_min, $phi_max) // -180 // offset -180

			$rand_pos := @rand_range($pos_min, $pos_max)

			$rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
			$rand_rate := @rand_range($rate_min, $rate_max)

			$ryth_rand := @rand_range($ryth_min, $ryth_max)

			$poltocar := @poltocar3D_compiled($rand_radio, $rand_phi, $rand_theta)

			// $node_inc := $SC_Servers($server_name)("node_id") // last id

			// print (""+["HOA_Grain_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", @choose($buf_list), "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "coords", [$rand_radio, $rand_phi, $rand_theta]+$xyz_offset, "amp", $amp, "rate", $rand_rate])
			// $Servers($server_name).s_new(["HOAmbi_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $hoa_bus, "buf", @choose($buf_list), "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "coords", [$rand_radio, $rand_phi, $rand_theta]+$xyz_offset, "amp", $amp, "rate", $rand_rate])

			// $Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $in_buf, "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rand_rate, "spk_radius", $spk_radius])
				// @proc_def HOAmbi_grain_xyz_track_buf($buf, $envbuf, $rate, $dur, $pos, $coords, $amp, $track_HOA_NE) 
				// print (""+[@choose($buf_list), $envbuf, $rand_rate, $rand_env_dur, $rand_pos, [$rand_radio, $rand_phi, $rand_theta], $amp, $track_HOA_NE])
			::HOAmbi_grain_xyz_track_buf(@choose($buf_list), $envbuf, $rand_rate, $rand_env_dur, $rand_pos, [$rand_radio, $rand_phi, $rand_theta], $amp, $track_HOA_NE)

			// $node_inc := $SC_Servers($server_name)("node_id") + 1
			// $SC_Servers($server_name).add_pair("node_id", $node_inc + 1)

			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($rand_env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
		}
	}
	@fun_def rate_min($rmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_min := $rmin
	}
	@fun_def rate_max($rmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_max := $rmax
	}

	@fun_def ryth_min($rymin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $rymin
	}
	@fun_def ryth_max($rymax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $rymax
	}

	@fun_def env_dur_min($edmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $edmin
	}
	@fun_def env_dur_max($edmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $edmax
	}

	@fun_def radio_min($rdmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio_min := $rdmin
	}
	@fun_def radio_max($rdmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio_max := $rdmax
	}
	

	@fun_def theta_min($tmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$theta_min := $tmin
	}
	@fun_def theta_max($tmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$theta_max := $tmax
	}

	@fun_def phi_min($phmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$phi_min := $phmin
	}
	@fun_def phi_max($phmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$phi_max := $phmax
	}	

	@fun_def pos_min($posmin) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_min := $posmin
	}
	@fun_def pos_max($posmax) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_max := $posmax
	}	

	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf_list := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	
	@fun_def amp($a) // seulement quand une un track a plusieurs instances du même module
	{ 
		$amp := $a
	}		
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}		
}

@obj_def HOA_grain_rot_rand($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $mix_group_decoder, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_pos, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node_inc, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod // , $inc := 0

		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			$rand_pos := @rand_range($pos_min, $pos_max)

			$rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
			$rand_rate := @rand_range($rate_min, $rate_max)

			// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

			// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $mix_group_decoder
			$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $rand_pos, "env_dur", $rand_env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rand_rate, "spk_radius", $spk_radius])

			$node_inc += 1
			$SC_Servers($server_name).add_pair("node_id", $node_inc)

			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
		}		
	}
	// @proc_def radio($r)
	// {

	// 	if($r.is_tab()) // if $val is bpf
	// 	{
	// 		abort $last_bpf_r_curve // to avoid interferences

	// 		$nim := @build_nim_from_bpf($r)
	// 		$lradio := $r[0]
	// 		$last_bpf_r_curve := { curve @grain := 0.01, 
	// 			@action 
	// 			{
	// 				$radio := $lradio // $Servers($server_name).n_set($node_id_out, ["a", $la])	
	// 			} 
	// 			{ $lradio : $nim }
	// 		}
	// 	}
	// 	else
	// 	{
	// 		$radio := $r	
	// 	}
	// }	
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@fun_def dir($d) // seulement quand une un track a plusieurs instances du même module
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	@fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rate_max := $rate_ma
	}

	@fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		$env_dur_max := $env_dur_ma
	}

	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	@fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_min := $p_min
	}
	@fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_max := $p_max
	}	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_radio.$tpo := $t
		$lfo_rand_theta.$tpo := $t
		$lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	

	@proc_def amp($a)
	{

		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
}

@obj_def HOA_grain_rot_rand_lfo_rev($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $mix_group_decoder, $grain_group, $rev_amp = -20, $spk_radius = 1.07) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset, $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_pos, $pos_lfo, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node_inc := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $revtime := 1, $rev_id // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, 0., "linear", $tpo)

		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		// reverb
		$rev_id := $SC_Servers($server_name)("node_id")

		$Servers($server_name).s_new(["TAdCVerb_order"+$order, $rev_id, 0, $main_group_id, "in", $hoa_bus, "out", $hoa_bus, "revTime", $revtime, "amp", $rev_amp])

		$SC_Servers($server_name).add_pair("node_id", $rev_id+1) // inc

		$node_inc := $SC_Servers($server_name)("node_id") // last id

		$SC_Servers($server_name).insert("bus_index", $hoa_bus + ($order+1).pow(2)) // inc bus de server + hoa_bus (4) + $hoa_rev_bus (4) 


		// $SC_Servers($server_name).add_pair("node_id", $node_inc)



		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $rand_pos := @rand_range($pos_min, $pos_max)

			// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
			// $rand_rate := @rand_range($rate_min, $rate_max)

			// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

			// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $mix_group_decoder
			$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $rev_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

			$node_inc += 1
			$SC_Servers($server_name).add_pair("node_id", $node_inc)

			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
		}		
	}
	// @proc_def radio($r)
	// {

	// 	if($r.is_tab()) // if $val is bpf
	// 	{
	// 		abort $last_bpf_r_curve // to avoid interferences

	// 		$nim := @build_nim_from_bpf($r)
	// 		$lradio := $r[0]
	// 		$last_bpf_r_curve := { curve @grain := 0.01, 
	// 			@action 
	// 			{
	// 				$radio := $lradio // $Servers($server_name).n_set($node_id_out, ["a", $la])	
	// 			} 
	// 			{ $lradio : $nim }
	// 		}
	// 	}
	// 	else
	// 	{
	// 		$radio := $r	
	// 	}
	// }	
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}
	@fun_def rate2($rate_val) 
	{ 
		abort $lfo_rand_rate
		$rate := $rate_val
		// print rate $rate_val
	}	
	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}

	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	// @fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_min := $rate_m
	// }
	// @fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_max := $rate_ma
	// }

	// @fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_min := $env_dur_m
	// }
	// @fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_max := $env_dur_ma
	// }

	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	// @fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_min := $p_min
	// }
	// @fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_max := $p_max
	// }	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_radio.$tpo := $t
		$lfo_rand_theta.$tpo := $t
		$lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	

	@fun_def revtime($rv) // seulement quand une un track a plusieurs instances du même module
	{ 
		
		$Servers($server_name).n_set($rev_id, ["revTime", $rv])
	}
	@fun_def rev_amp($rva) // seulement quand une un track a plusieurs instances du même module
	{ 
		
		$Servers($server_name).n_set($rev_id, ["amp", $rva])
	}

	@fun_def hfDamping($hf) // seulement quand une un track a plusieurs instances du même module
	{ 
		
		$Servers($server_name).n_set($rev_id, ["hfDamping", $hf])
	}

	@fun_def rev_pause($time)
	{
		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 0
		$Servers($server_name).n_set($rev_id, ["matrix_ramp", @dur2sec($time), "gate", 0])
		// @dur2sec($time) scServer "n_set" $group_id gate 0
	}

	@fun_def rev_resume($time)
	{	
		// scServer "n_run" $group_id 1
		$Servers($server_name).n_run($rev_id, 1)

		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 1
		$Servers($server_name).n_set($rev_id, ["matrix_ramp", @dur2sec($time), "gate", 1])
	}


	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
	@abort
	{
		$Servers($server_name).n_set($rev_id, ["matrix_ramp", 1.5, "free", 0])

		// print ("abort "+$track_name)
	    // $THISOBJ.free(0.01) // 
	 //    forall $k, $v in $track_proc($server_name)($track_name) // abort processus
		// {
		// 	abort $v
		// }
	}	

}


@obj_def HOA_grain_rot_rand_lfo_rev2($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $track_HOA_NE, $grain_group, $rev_amp = -20, $spk_radius = 1.07) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset, $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_pos, $pos_lfo, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node_inc := 0, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $revtime := 1, $rev_id // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, 0., "linear", $tpo)

		$ryth_rand := @rand_range($ryth_min, $ryth_max)
		// $server_name := $SC_Groups($mix_group_decoder)("server_name")
		// $main_group_name := $SC_Groups($mix_group_decoder)("name")
		// $main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		
		// $hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		// $order :=  $SC_Groups($mix_group_decoder)("order")

		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		// $node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		// reverb
		$rev_id := $SC_Servers($server_name)("node_id")
		print reverb (""+["TAdCVerb_order"+$order, $rev_id, 0, $main_group_id, "in", $hoa_bus, "out", $hoa_bus, "revTime", $revtime, "amp", $rev_amp])
		$Servers($server_name).s_new(["TAdCVerb_order"+$order, $rev_id, 2, $main_group_id, "in", $hoa_bus, "out", $hoa_bus, "revTime", $revtime, "amp", $rev_amp])

		$SC_Servers($server_name).add_pair("node_id", $rev_id+1) // inc

		$node_inc := $SC_Servers($server_name)("node_id") // last id

		$SC_Servers($server_name).insert("bus_index", $hoa_bus + ($order+1).pow(2)) // inc bus de server + hoa_bus (4) + $hoa_rev_bus (4) 


		// $SC_Servers($server_name).add_pair("node_id", $node_inc)



		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

			$ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $rand_pos := @rand_range($pos_min, $pos_max)

			// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
			// $rand_rate := @rand_range($rate_min, $rate_max)

			// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

			// print $buf $envbuf $rate $env_dur $pos_lfo ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $track_HOA_NE
			$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $rev_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
			// print: harm-trem-C5-c4-2.aif perc 1.306915 0.031069 <undef> 0.582017 -0.369433 0.121554 0 <undef>

			$node_inc += 1
			$SC_Servers($server_name).add_pair("node_id", $node_inc)

			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			// @command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
		}		
	}
	// @proc_def radio($r)
	// {

	// 	if($r.is_tab()) // if $val is bpf
	// 	{
	// 		abort $last_bpf_r_curve // to avoid interferences

	// 		$nim := @build_nim_from_bpf($r)
	// 		$lradio := $r[0]
	// 		$last_bpf_r_curve := { curve @grain := 0.01, 
	// 			@action 
	// 			{
	// 				$radio := $lradio // $Servers($server_name).n_set($node_id_out, ["a", $la])	
	// 			} 
	// 			{ $lradio : $nim }
	// 		}
	// 	}
	// 	else
	// 	{
	// 		$radio := $r	
	// 	}
	// }	
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}
	@fun_def rate2($rate_val) 
	{ 
		abort $lfo_rand_rate
		$rate := $rate_val
		// print rate $rate_val
	}	
	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}

	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	// @fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_min := $rate_m
	// }
	// @fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_max := $rate_ma
	// }

	// @fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_min := $env_dur_m
	// }
	// @fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_max := $env_dur_ma
	// }

	@fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_min := $r_min
	}
	@fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	{ 
		$ryth_max := $r_max
	}	
	// @fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_min := $p_min
	// }
	// @fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_max := $p_max
	// }	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_radio.$tpo := $t
		$lfo_rand_theta.$tpo := $t
		$lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	

	@fun_def revtime($rv) // seulement quand une un track a plusieurs instances du même module
	{ 
		
		$Servers($server_name).n_set($rev_id, ["revTime", $rv])
	}
	@fun_def rev_amp($rva) // seulement quand une un track a plusieurs instances du même module
	{ 
		
		$Servers($server_name).n_set($rev_id, ["amp", $rva])
	}

	@fun_def hfDamping($hf) // seulement quand une un track a plusieurs instances du même module
	{ 
		
		$Servers($server_name).n_set($rev_id, ["hfDamping", $hf])
	}

	@fun_def rev_pause($time)
	{
		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 0
		$Servers($server_name).n_set($rev_id, ["matrix_ramp", @dur2sec($time), "gate", 0])
		// @dur2sec($time) scServer "n_set" $group_id gate 0
	}

	@fun_def rev_resume($time)
	{	
		// scServer "n_run" $group_id 1
		$Servers($server_name).n_run($rev_id, 1)

		// scServer "n_set" $group_id matrix_ramp @dur2sec($time) gate 1
		$Servers($server_name).n_set($rev_id, ["matrix_ramp", @dur2sec($time), "gate", 1])
	}


	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
	@abort
	{
		$Servers($server_name).n_set($rev_id, ["matrix_ramp", 1.5, "free", 0])

		// print ("abort "+$track_name)
	    // $THISOBJ.free(0.01) // 
	 //    forall $k, $v in $track_proc($server_name)($track_name) // abort processus
		// {
		// 	abort $v
		// }
	}	

}

@obj_def HOA_grain_rot_rand_lfo($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $mix_group_decoder, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset, $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_pos, $pos_lfo, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node_inc, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $lfo_rand_ryth, $lryth, $last_bpf_ryth_curve := 0, $levd, $last_bpf_env_dur_curve := 0, $on_off := 1  // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, $pos_min, "linear", $tpo)
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $ryth_max, $ryth_min, "linear", $tpo)

		// $ryth_rand := @rand_range($ryth_min, $ryth_max)
		$ryth_rand := $ryth_min
		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			if($on_off)
			{
				$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

				// $ryth_rand := @rand_range($ryth_min, $ryth_max)
				// $rand_pos := @rand_range($pos_min, $pos_max)

				// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
				// $rand_rate := @rand_range($rate_min, $rate_max)

				// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

				// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $mix_group_decoder
				$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

				$node_inc += 1
				$SC_Servers($server_name).add_pair("node_id", $node_inc)

				// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
			}
		}		
	}
	// @proc_def radio($r)
	// {

	// 	if($r.is_tab()) // if $val is bpf
	// 	{
	// 		abort $last_bpf_r_curve // to avoid interferences

	// 		$nim := @build_nim_from_bpf($r)
	// 		$lradio := $r[0]
	// 		$last_bpf_r_curve := { curve @grain := 0.01, 
	// 			@action 
	// 			{
	// 				$radio := $lradio // $Servers($server_name).n_set($node_id_out, ["a", $la])	
	// 			} 
	// 			{ $lradio : $nim }
	// 		}
	// 	}
	// 	else
	// 	{
	// 		$radio := $r	
	// 	}
	// }	
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}

	@fun_def on_off($of) 
	{ 
		$on_off := $of
		// print rate $rate_val
	}

	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}
	
	@fun_def ryth($ry) 
	{ 
		$ryth_rand := $ry
		// print env_dur $env_dur_val
	}	
	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	// @fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_min := $rate_m
	// }
	// @fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_max := $rate_ma
	// }

	// @fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_min := $env_dur_m
	// }
	// @fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_max := $env_dur_ma
	// }
	@fun_def ryth_min($r_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_min := $r_min

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $r_m, $ryth_max, 0.01, "linear", $tpo)
		$ryth_min := $r_m

	}
	@fun_def ryth_max($r_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_max := $r_max

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $r_ma, 0.01, "linear", $tpo)
		$ryth_max := $r_ma	
	}	

	@proc_def ryth_bpf($ry)
	{
		@local $nim 
		if($ry.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_ryth
			abort $last_bpf_ryth_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ry)
			$lryth := $ry[0]
			$last_bpf_ryth_curve := { curve @grain := 0.01, 
				@action 
				{
					$ryth_rand := $lryth	
					// print rythm $lryth			
				} 
				{ $lryth : $nim }
			}
		}
		else
		{
			print not tab
		}
	}

	@proc_def env_dur_bpf($ev)
	{
		@local $nim 
		if($ev.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_env_dur
			abort $last_bpf_env_dur_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ev)
			$levd := $ev[0]
			$last_bpf_env_dur_curve := { curve @grain := 0.01, 
				@action 
				{
					$env_dur := $levd	
					// print rythm $lryth			
				} 
				{ $levd : $nim }
			}
		}
		else
		{
			print not tab
		}
	}


	// @fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_min := $r_min
	// }
	// @fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_max := $r_max
	// }	
	// @fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_min := $p_min
	// }
	// @fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_max := $p_max
	// }	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_radio.$tpo := $t
		$lfo_rand_theta.$tpo := $t
		$lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	

	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
}


@obj_def HOA_grain_rot_rand_lfo2($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $track_HOA_NE, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset, $server_name, $main_group_name, $main_group_id, $node_id_mod, $bus, $order, $rand_pos, $pos_lfo, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node_inc, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $lfo_rand_ryth, $lryth, $last_bpf_ryth_curve := 0, $levd, $last_bpf_env_dur_curve := 0, $on_off := 1, $lfo_maps := map {}  // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo) //, "lfo_env_dur")		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo) //, "lfo_rate")
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, $pos_min, "linear", $tpo) //, "lfo_pos")
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $ryth_max, $ryth_min, "linear", $tpo) //, "lfo_ryth")

		// $ryth_rand := @rand_range($ryth_min, $ryth_max)
		$ryth_rand := $ryth_min
		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		// print NEW_Recipiente server_name $server_name
		// print NEW_Recipiente main_group_name $main_group_name
		// print NEW_Recipiente main_group_id $main_group_id
		// print NEW_Recipiente bus $bus
		// print NEW_Recipiente order $order	

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			if($on_off)
			{
				$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

				// $ryth_rand := @rand_range($ryth_min, $ryth_max)
				// $rand_pos := @rand_range($pos_min, $pos_max)

				// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
				// $rand_rate := @rand_range($rate_min, $rate_max)

				// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

				// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $track_HOA_NE
				$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

				$node_inc += 1
				$SC_Servers($server_name).add_pair("node_id", $node_inc)

				// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
			}
		}		
	}
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) //, $key) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $lfo_maps.add_pair($key, ::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo))
			::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}

	@fun_def on_off($of) 
	{ 
		$on_off := $of
		// print rate $rate_val
	}

	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}
	
	@fun_def ryth($ry) 
	{ 
		$ryth_rand := $ry
		// print env_dur $env_dur_val
	}	
	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	// @fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_min := $rate_m
	// }
	// @fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_max := $rate_ma
	// }

	// @fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_min := $env_dur_m
	// }
	// @fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_max := $env_dur_ma
	// }
	@fun_def ryth_min($r_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_min := $r_min

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $r_m, $ryth_max, 0.01, "linear", $tpo)
		$ryth_min := $r_m

	}
	@fun_def ryth_max($r_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_max := $r_max

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $r_ma, 0.01, "linear", $tpo)
		$ryth_max := $r_ma	
	}	

	@proc_def ryth_bpf($ry)
	{
		@local $nim 
		if($ry.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_ryth
			abort $last_bpf_ryth_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ry)
			$lryth := $ry[0]
			$last_bpf_ryth_curve := { curve @grain := 0.01, 
				@action 
				{
					$ryth_rand := $lryth	
					// print rythm $lryth			
				} 
				{ $lryth : $nim }
			}
		}
		else
		{
			print not tab
		}
	}

	@proc_def env_dur_bpf($ev)
	{
		@local $nim 
		if($ev.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_env_dur
			abort $last_bpf_env_dur_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ev)
			$levd := $ev[0]
			$last_bpf_env_dur_curve := { curve @grain := 0.01, 
				@action 
				{
					$env_dur := $levd	
					// print rythm $lryth			
				} 
				{ $levd : $nim }
			}
		}
		else
		{
			print not tab
		}
	}


	// @fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_min := $r_min
	// }
	// @fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_max := $r_max
	// }	
	// @fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_min := $p_min
	// }
	// @fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_max := $p_max
	// }	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		// $lfo_rand_radio.$tpo := $t
		// $lfo_rand_theta.$tpo := $t
		// $lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_ryth.$tpo := $t
		// $lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	

	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
}

@obj_def HOAmbi_grain_rot_rand_lfo2($buf_list, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $track_HOA_NE, $grain_group) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset, $server_name, $main_group_name, $main_group_id, $node_id_mod, $bus, $order, $rand_pos, $pos_lfo, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node_inc, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $lfo_rand_ryth, $lryth, $last_bpf_ryth_curve := 0, $levd, $last_bpf_env_dur_curve := 0, $on_off := 1, $lfo_maps := map {}  // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo) //, "lfo_env_dur")		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo) //, "lfo_rate")
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, $pos_min, "linear", $tpo) //, "lfo_pos")
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $ryth_max, $ryth_min, "linear", $tpo) //, "lfo_ryth")

		// $ryth_rand := @rand_range($ryth_min, $ryth_max)
		$ryth_rand := $ryth_min
		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		// $node_inc := $SC_Servers($server_name)("node_id") // last id
		$bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		// print NEW_Recipiente server_name $server_name
		// print NEW_Recipiente main_group_name $main_group_name
		// print NEW_Recipiente main_group_id $main_group_id
		// print NEW_Recipiente bus $bus
		// print NEW_Recipiente order $order	

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									// $poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)
									$poltocar := @poltocar3D_compiled($radio_res, $phi*$dir, $theta)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]
										// print phi $phi theta $theta
										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			if($on_off)
			{
				$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

				// $ryth_rand := @rand_range($ryth_min, $ryth_max)
				// $rand_pos := @rand_range($pos_min, $pos_max)

				// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
				// $rand_rate := @rand_range($rate_min, $rate_max)

				// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

				// print (@choose($buf_list)) ($envs($server_name)($envbuf)) "pos" $pos_lfo "env_dur" $env_dur "t_trig" 1 "coords" ([$radio_res, $phi, $theta]+$xyz_offset) "amp" $amp "rate" $rate
				// $Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])
				$node_inc := $SC_Servers($server_name)("node_id") // last id				
				$Servers($server_name).s_new(["HOAmbi_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $bus, "buf", @choose($buf_list), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "coords", [$radio_res, $phi, $theta]+$xyz_offset, "amp", $amp, "rate", $rate])

				// $node_inc += 1
				$SC_Servers($server_name).add_pair("node_id", $node_inc + 1)

				// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
			}
		}		
	}
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) //, $key) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $lfo_maps.add_pair($key, ::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo))
			::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}

	@fun_def on_off($of) 
	{ 
		$on_off := $of
		// print rate $rate_val
	}

	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}
	
	@fun_def ryth($ry) 
	{ 
		$ryth_rand := $ry
		// print env_dur $env_dur_val
	}	
	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	// @fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_min := $rate_m
	// }
	// @fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_max := $rate_ma
	// }

	// @fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_min := $env_dur_m
	// }
	// @fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_max := $env_dur_ma
	// }
	@fun_def ryth_min($r_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_min := $r_min

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $r_m, $ryth_max, 0.01, "linear", $tpo)
		$ryth_min := $r_m

	}
	@fun_def ryth_max($r_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_max := $r_max

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $r_ma, 0.01, "linear", $tpo)
		$ryth_max := $r_ma	
	}	

	@proc_def ryth_bpf($ry)
	{
		@local $nim 
		if($ry.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_ryth
			abort $last_bpf_ryth_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ry)
			$lryth := $ry[0]
			$last_bpf_ryth_curve := { curve @grain := 0.01, 
				@action 
				{
					$ryth_rand := $lryth	
					// print rythm $lryth			
				} 
				{ $lryth : $nim }
			}
		}
		else
		{
			print not tab
		}
	}

	@proc_def env_dur_bpf($ev)
	{
		@local $nim 
		if($ev.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_env_dur
			abort $last_bpf_env_dur_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ev)
			$levd := $ev[0]
			$last_bpf_env_dur_curve := { curve @grain := 0.01, 
				@action 
				{
					$env_dur := $levd	
					// print rythm $lryth			
				} 
				{ $levd : $nim }
			}
		}
		else
		{
			print not tab
		}
	}


	// @fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_min := $r_min
	// }
	// @fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_max := $r_max
	// }	
	// @fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_min := $p_min
	// }
	// @fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_max := $p_max
	// }	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		// $lfo_rand_radio.$tpo := $t
		// $lfo_rand_theta.$tpo := $t
		// $lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_ryth.$tpo := $t
		// $lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf_list := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	

	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}
	@proc_def free($t = 1)
	{
	   @local $lamp, $amp_init, $amp_end := -90, $type := "linear"
	   $amp_init := $amp
	   Curve
	   @grain := 0.01,
	   @action {
			
				$THISOBJ.amp($lamp)
				// print amp $amp
	} 
	   { $lamp {            
				    {$amp_init} @type := $type
			 $t   {$amp_end}} 
	   }
    $t abort $THISOBJ	
    }	
    @abort
	{
		$THISOBJ.free()
	}			
}

@obj_def HOA_grain_rot_rand_lfo2_mod($buf, $envbuf, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $track_HOA_NE, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset, $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_pos, $pos_lfo, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node_inc, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $lfo_rand_ryth, $lryth, $last_bpf_ryth_curve := 0, $levd, $last_bpf_env_dur_curve := 0, $on_off := 1, $lfo_maps := map {}  // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo) //, "lfo_env_dur")		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo) //, "lfo_rate")
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, $pos_min, "linear", $tpo) //, "lfo_pos")
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $ryth_max, $ryth_min, "linear", $tpo) //, "lfo_ryth")

		// $ryth_rand := @rand_range($ryth_min, $ryth_max)
		$ryth_rand := $ryth_min
		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		// print NEW_Recipiente server_name $server_name
		// print NEW_Recipiente main_group_name $main_group_name
		// print NEW_Recipiente main_group_id $main_group_id
		// print NEW_Recipiente hoa_bus $hoa_bus
		// print NEW_Recipiente order $order	

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			if($on_off)
			{
				$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

				// $ryth_rand := @rand_range($ryth_min, $ryth_max)
				// $rand_pos := @rand_range($pos_min, $pos_max)

				// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
				// $rand_rate := @rand_range($rate_min, $rate_max)

				// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

				// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $track_HOA_NE
				$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf", $envs($server_name)($envbuf), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

				$node_inc += 1
				$SC_Servers($server_name).add_pair("node_id", $node_inc)

				// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
			}
		}		
	}
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type) //, $key) // seulement quand une un track a plusieurs instances du même module
	{ 
		@local $v1, $v2, $duree, $current, $curve_proc, $val, $curve_int_proc, $delay

		$v1 := $init_val
		$v2 := $init_val
		$curve_int_proc := 0

		$delay := @rand(1.) + 0.5

		group @tempo := $tpo
		{
			Loop $delay @exclusive //@tempo := $tpo
			{
				print tempo $tpo
				abort $curve_int_proc

				$v1 := $v2
				$v2 := @rand_range($min, $max) // @rand($max-$min)+$min

				$duree := $delay
				$delay := @rand(1.) + 0.5

				curve
				   // @tempo := $tpo
				   @Grain := 0.005 //0.01s 
				   @action :=  { 
						 $param($val) 
					    }

				   { $val {
						  {$v1} @type := $type
					  $duree {$v2} 
					  }
				   }
			}
		}

		// $lfo_maps.add_pair($key, ::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo))
			// ::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}

	@fun_def on_off($of) 
	{ 
		$on_off := $of
		// print rate $rate_val
	}

	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}
	
	@fun_def ryth($ry) 
	{ 
		$ryth_rand := $ry
		// print env_dur $env_dur_val
	}	
	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	// @fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_min := $rate_m
	// }
	// @fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_max := $rate_ma
	// }

	// @fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_min := $env_dur_m
	// }
	// @fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_max := $env_dur_ma
	// }
	@fun_def ryth_min($r_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_min := $r_min

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $r_m, $ryth_max, 0.01, "linear", $tpo)
		$ryth_min := $r_m

	}
	@fun_def ryth_max($r_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_max := $r_max

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $r_ma, 0.01, "linear", $tpo)
		$ryth_max := $r_ma	
	}	

	@proc_def ryth_bpf($ry)
	{
		@local $nim 
		if($ry.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_ryth
			abort $last_bpf_ryth_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ry)
			$lryth := $ry[0]
			$last_bpf_ryth_curve := { curve @grain := 0.01, 
				@action 
				{
					$ryth_rand := $lryth	
					// print rythm $lryth			
				} 
				{ $lryth : $nim }
			}
		}
		else
		{
			print not tab
		}
	}

	@proc_def env_dur_bpf($ev)
	{
		@local $nim 
		if($ev.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_env_dur
			abort $last_bpf_env_dur_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ev)
			$levd := $ev[0]
			$last_bpf_env_dur_curve := { curve @grain := 0.01, 
				@action 
				{
					$env_dur := $levd	
					// print rythm $lryth			
				} 
				{ $levd : $nim }
			}
		}
		else
		{
			print not tab
		}
	}


	// @fun_def ryth_min($r_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_min := $r_min
	// }
	// @fun_def ryth_max($r_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$ryth_max := $r_max
	// }	
	// @fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_min := $p_min
	// }
	// @fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_max := $p_max
	// }	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$tpo := $t
		// print temp $t
		// $lfo_rand_env_dur.$tpo := $t
		// // $lfo_rand_radio.$tpo := $t
		// // $lfo_rand_theta.$tpo := $t
		// // $lfo_rand_phi.$tpo := $t
		// $lfo_rand_rate.$tpo := $t
		// $lfo_rand_pos_lfo.$tpo := $t
		// $lfo_rand_ryth.$tpo := $t
		// $lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf($eb) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf := $eb
	}	

	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
}


@obj_def HOA_grain_rot_rand_lfo2_multi($buf_tab, $envbuf_tab, $rate_min, $rate_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $track_HOA_NE, $grain_group, $tpo = 120, $spk_radius = 1.07) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset, $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_pos, $pos_lfo, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $node_inc, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $lfo_rand_ryth, $lryth, $last_bpf_ryth_curve := 0, $levd, $last_bpf_env_dur_curve := 0, $on_off := 1  // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, $pos_min, "linear", $tpo)
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $ryth_max, $ryth_min, "linear", $tpo)

		// $ryth_rand := @rand_range($ryth_min, $ryth_max)
		$ryth_rand := $ryth_min
		$server_name := $tracks($track_HOA_NE).$server_name
		$main_group_name := $tracks($track_HOA_NE).$group_name
		$main_group_id := $tracks($track_HOA_NE).$node_id_out
		$node_inc := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $tracks($track_HOA_NE).$bus
		$order :=  $tracks($track_HOA_NE).$order

		// print NEW_Recipiente server_name $server_name
		// print NEW_Recipiente main_group_name $main_group_name
		// print NEW_Recipiente main_group_id $main_group_id
		// print NEW_Recipiente hoa_bus $hoa_bus
		// print NEW_Recipiente order $order	

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			@local $buf_choose, $bufenv_choose
			if($on_off)
			{
				$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

				// $ryth_rand := @rand_range($ryth_min, $ryth_max)
				// $rand_pos := @rand_range($pos_min, $pos_max)

				// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
				// $rand_rate := @rand_range($rate_min, $rate_max)

				// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)
				$buf_choose := @choose($buf_tab)
				$bufenv_choose := @choose($envbuf_tab)
				// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $track_HOA_NE
				$Servers($server_name).s_new(["HOA_Grain_xyz"+$order, $node_inc, 2, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf_choose), "envbuf", $envs($server_name)($bufenv_choose), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "spk_radius", $spk_radius])

				$node_inc += 1
				$SC_Servers($server_name).add_pair("node_id", $node_inc)

				// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $track_HOA_NE)
				@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
			}
		}		
	}
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}

	@fun_def on_off($of) 
	{ 
		$on_off := $of
		// print rate $rate_val
	}

	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}
	
	@fun_def ryth($ry) 
	{ 
		$ryth_rand := $ry
		// print env_dur $env_dur_val
	}	
	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}

	@fun_def ryth_min($r_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_min := $r_min

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $r_m, $ryth_max, 0.01, "linear", $tpo)
		$ryth_min := $r_m

	}
	@fun_def ryth_max($r_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_max := $r_max

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $r_ma, 0.01, "linear", $tpo)
		$ryth_max := $r_ma	
	}	

	@proc_def ryth_bpf($ry)
	{
		@local $nim 
		if($ry.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_ryth
			abort $last_bpf_ryth_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ry)
			$lryth := $ry[0]
			$last_bpf_ryth_curve := { curve @grain := 0.01, 
				@action 
				{
					$ryth_rand := $lryth	
					// print rythm $lryth			
				} 
				{ $lryth : $nim }
			}
		}
		else
		{
			print not tab
		}
	}

	@proc_def env_dur_bpf($ev)
	{
		@local $nim 
		if($ev.is_tab()) // if $val is bpf
		{
			abort $lfo_rand_env_dur
			abort $last_bpf_env_dur_curve // to avoid interferences

			$nim := @build_nim_from_bpf($ev)
			$levd := $ev[0]
			$last_bpf_env_dur_curve := { curve @grain := 0.01, 
				@action 
				{
					$env_dur := $levd	
					// print rythm $lryth			
				} 
				{ $levd : $nim }
			}
		}
		else
		{
			print not tab
		}
	}

	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		// $lfo_rand_radio.$tpo := $t
		// $lfo_rand_theta.$tpo := $t
		// $lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_ryth.$tpo := $t
		// $lfo_rand_env_dur.$tpo := $t
	}
	@fun_def buf($bft) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf_tab := $bft
	}		
	@fun_def envbuf($ebt) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf_tab := $ebt
	}	

	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
}





@obj_def HOA_grain_interpol_rot_rand_lfo($buf, $envbuf0, $envbuf1, $rate_min, $rate_max, $ryth_min, $ryth_max, $ifac_min, $ifac_max, $env_dur_min, $env_dur_max, $pos_min, $pos_max, $dir, $duree, $radio, $start_angle, $start_elev, $end_angle, $end_elev, $period, $type, $id, $amp, $mix_group_decoder, $grain_group, $spk_radius = 1.07) 
{
	@init 
    {
		@local $phi, $theta, $poltocar, $xyz_offset := [0, 0, 0], $server_name, $main_group_name, $main_group_id, $node_id_mod, $hoa_bus, $order, $rand_pos, $pos_lfo, $ifac, $env_dur := 0.1, $rate := 1, $ryth_rand := 0.1, $tpo := 120, $node, $radio_res, $radio_fac := 1, $tempo_fac := 1, $curve_int_proc := 0, $elev := 1, $nim, $lamp, $last_bpf_a_curve := 0, $last_bpf_r_curve := 0, $lradio, $last_bpf_ele_curve := 0, $lelev, $last_bpf_per_curve := 0, $lperiod, $lfo_rand_radio, $lfo_rand_theta, $lfo_rand_phi, $lfo_rand_rate, $lfo_rand_pos_lfo, $lfo_rand_env_dur, $lfo_rand_ifac, $lfo_rand_ryth // , $inc := 0

		// $lfo_rand_radio := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_radio($THISOBJ), $radio_min, $radio_max, $init_radio, "linear", $tpo)
		// $lfo_rand_theta := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_theta($THISOBJ), $theta_min, $theta_max, $init_theta, "linear", $tpo)
		// $lfo_rand_phi := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_phi($THISOBJ), $phi_min, $phi_max, $init_phi, "linear", $tpo)
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)		
		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_max, 1, "linear", $tpo)
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_max, 0., "linear", $tpo)
		$lfo_rand_ifac := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ifac($THISOBJ), $ifac_min, $ifac_max, 0., "linear", $tpo)
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $ryth_max, 0., "linear", $tpo)

		print mix_group_decoder $mix_group_decoder
		// $ryth_rand := @rand_range($ryth_min, $ryth_max)
		$ryth_rand := $ryth_min
		$server_name := $SC_Groups($mix_group_decoder)("server_name")
		$main_group_name := $SC_Groups($mix_group_decoder)("name")
		$main_group_id := $SC_Groups($mix_group_decoder)("main_group_id")
		$node := $SC_Servers($server_name)("node_id") // last id
		$hoa_bus := $SC_Groups($mix_group_decoder)("hoa_bus")
		$order :=  $SC_Groups($mix_group_decoder)("order")

		if($space_group($server_name)($main_group_name).is_defined("xyz_offset")) // if visualization actif
		{
			print already defined "xyz_offset"
		}
		else
		{
			$space_group($server_name)($main_group_name).add_pair("xyz_offset", [0, 0, 0]) // store xyz position in map for oFx visualization
		}
		
		$radio_res := $radio * $radio_fac
		// $poltocar := @poltocar3D_compiled($radio_res, ($theta_max*$elev)-90, ($phi*(-$dir))-90)
		$poltocar := @poltocar3D_compiled($radio_res, 0, 0)

		$Servers($server_name).s_new(["HOA_Grain_Buf_Interpol_xyz"+$order, $node, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf0", $envs($server_name)($envbuf0), "envbuf1", $envs($server_name)($envbuf1), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "ifac", $ifac, "spk_radius", $spk_radius])

		group @tempo := ($period*$tempo_fac)
		{
			Loop $duree @exclusive //@tempo := $tpo
			{
				abort $curve_int_proc

				$curve_int_proc := {  curve
					   // @tempo := $tpo
					   @Grain := 0.02 //0.01s 
					   @action :=  { 
									$radio_res := $radio * $radio_fac
									$poltocar := @poltocar3D_compiled($radio_res, ($theta*$elev)-90, ($phi*(-$dir))-90)

					 //   				$xyz[0] := $poltocar[0]
										// $xyz[1] := $poltocar[1]
										// $xyz[2] := $poltocar[2]

										// $Servers($server_name).n_set($track_id, ["x", $xyz[0]+$HOA_global_x+$HOA_local_x, "y", $xyz[1]+$HOA_global_y+$HOA_local_y, "z", $xyz[2]+$HOA_global_z+$HOA_local_z])		            
										// print xyz (""+$xyz.concat([@rand_range(0, 1)]))
										// test_pos1 $xyz
										// osc_send_descriptors ("/spatc/"+$id+"/xyzw") ($xyz.concat([@rand_range(0, 1)]))

							 // @command("n_set"+$server_name) $group $param $val
						    }

					   { $phi, $theta {
						  {$start_angle, $start_elev} @type := $type
						  $duree {$end_angle, $end_elev} 
						  }
					   }
				    }
				// $inc += 1			    
			} //until ($inc >= $loop)
		}

		loop circle_rand $ryth_rand
		{
			
			$xyz_offset := $space_group($server_name)($main_group_name)("xyz_offset")

			// $ryth_rand := @rand_range($ryth_min, $ryth_max)
			// $rand_pos := @rand_range($pos_min, $pos_max)

			// $rand_env_dur := @rand_range($env_dur_min, $env_dur_max)
			// $rand_rate := @rand_range($rate_min, $rate_max)

			// $poltocar := @poltocar3D($rand_radio , $rand_theta, $rand_phi)

			// print $buf $envbuf $rate $env_dur ($pos+$pos_lfo) ($poltocar[0]) ($poltocar[1]) ($poltocar[2]) $amp $mix_group_decoder
			// $Servers($server_name).s_new(["HOA_Grain_Buf_Interpol_xyz"+$order, $node_inc, 0, $main_group_id, "globTBus", $hoa_bus, "buf", $SF_map($server_name)($buf), "envbuf0", $envs($server_name)($envbuf0), "envbuf1", $envs($server_name)($envbuf1), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "ifac", $ifac, "spk_radius", $spk_radius])
			$Servers($server_name).n_set($node, ["buf", $SF_map($server_name)($buf), "envbuf0", $envs($server_name)($envbuf0), "envbuf1", $envs($server_name)($envbuf1), "pos", $pos_lfo, "env_dur", $env_dur, "t_trig", 1, "x", $poltocar[0]+$HOA_global_x, "y", $poltocar[1]+$HOA_global_y, "z", $poltocar[2]+$HOA_global_z, "xoffset", $xyz_offset[0], "yoffset", $xyz_offset[1], "zoffset", $xyz_offset[2], "amp", $amp, "rate", $rate, "ifac", $ifac, "spk_radius", $spk_radius])


			// ::HOA_grain_xyz($server_name, $order, $node_id_mod, $main_group_id, $buf, $envbuf, $rate, $env_dur, $pos_lfo, $poltocar[0]+$HOA_global_x, $poltocar[1]+$HOA_global_y, $poltocar[2]+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($poltocar[0]+$xyz_offset[0]) ($poltocar[1]+$xyz_offset[1]) ($poltocar[2]+$xyz_offset[2])
		}	

		$SC_Servers($server_name).add_pair("node_id", $node + 1)
	
	}
	// @proc_def radio($r)
	// {

	// 	if($r.is_tab()) // if $val is bpf
	// 	{
	// 		abort $last_bpf_r_curve // to avoid interferences

	// 		$nim := @build_nim_from_bpf($r)
	// 		$lradio := $r[0]
	// 		$last_bpf_r_curve := { curve @grain := 0.01, 
	// 			@action 
	// 			{
	// 				$radio := $lradio // $Servers($server_name).n_set($node_id_out, ["a", $la])	
	// 			} 
	// 			{ $lradio : $nim }
	// 		}
	// 	}
	// 	else
	// 	{
	// 		$radio := $r	
	// 	}
	// }	
	@fun_def radio($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		$radio := $t
	}

	@proc_def radio_fac($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_r_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lradio_fac := $r[0]
			$last_bpf_r_curve := { curve @grain := 0.01, 
				@action 
				{
					$radio_fac := $lradio_fac // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lradio_fac : $nim }
			}
		}
		else
		{
			$radio_fac := $r	
		}
	}	
	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}

	@fun_def rate($rate_val) 
	{ 
		$rate := $rate_val
		// print rate $rate_val
	}
	@fun_def pos_lfo($pos_val) 
	{ 
		$pos_lfo := $pos_val
		// print pos_val $pos_val
	}
	@fun_def env_dur($env_dur_val) 
	{ 
		$env_dur := $env_dur_val
		// print env_dur $env_dur_val
	}
	@fun_def ifac($ifac_val) 
	{ 
		$ifac := $ifac_val
		// print env_dur $env_dur_val
	}

	@fun_def ryth($ry) 
	{ 
		$ryth_rand := $ry
		// print env_dur $env_dur_val
	}	

	@fun_def rate_min($rate_m) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_m, $rate_max, 1, "linear", $tpo)
		// $rate := $rate_val
		$rate_min := $rate_m
	}
	@fun_def rate_max($rate_ma) 
	{ 
		abort $lfo_rand_rate

		$lfo_rand_rate := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_rate($THISOBJ), $rate_min, $rate_ma, 1, "linear", $tpo)
		$rate_max := $rate_ma
	}	
	@fun_def pos_min($pos_m) 
	{ 
		abort $lfo_rand_pos_lfo

		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_m, $pos_max, 0., "linear", $tpo)
		$pos_min := $pos_m
		// $pos_lfo := $pos_val
	}
	@fun_def pos_max($pos_ma) 
	{ 
		abort $lfo_rand_pos_lfo
		$lfo_rand_pos_lfo := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_pos_lfo($THISOBJ), $pos_min, $pos_ma, 0., "linear", $tpo)
		$pos_max := $pos_ma
		// $pos_lfo := $pos_val
	}

	@fun_def env_dur_min($env_dur_m) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $env_dur_m, $env_dur_max, 0.01, "linear", $tpo)
		$env_dur_min := $env_dur_m
	}
	@fun_def env_dur_max($env_dur_ma) 
	{ 
		abort $lfo_rand_env_dur
		$lfo_rand_env_dur := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_env_dur($THISOBJ), $ryth_min, $env_dur_ma, 0.01, "linear", $tpo)
		$env_dur_max := $env_dur_ma
	}

	@fun_def ryth_min($r_m) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_min := $r_min

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_min, $ryth_ma, 0.01, "linear", $tpo)
		$ryth_min := $r_m

	}
	@fun_def ryth_max($r_ma) // seulement quand une un track a plusieurs instances du même module
	{ 
		// $ryth_max := $r_max

		abort $lfo_rand_ryth
		$lfo_rand_ryth := $THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_ryth($THISOBJ), $ryth_m, $ryth_max, 0.01, "linear", $tpo)
		$ryth_max := $r_ma	
	}	

	@fun_def dir($d) 
	{ 
		$dir := $d
	}
	@proc_def elev($r)
	{
		@local $nim 

		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_ele_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lelev := $r[0]
			$last_bpf_ele_curve := { curve @grain := 0.01, 
				@action 
				{
					$elev := $lelev // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lelev : $nim }
			}
		}
		else
		{
			$elev := $r	
		}
	}	
	@proc_def period($r)
	{
		@local $nim 
		
		if($r.is_tab()) // if $val is bpf
		{
			abort $last_bpf_per_curve // to avoid interferences

			$nim := @build_nim_from_bpf($r)
			$lperiod := $r[0]
			$last_bpf_per_curve := { curve @grain := 0.01, 
				@action 
				{
					$period := $lperiod // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lperiod : $nim }
			}
		}
		else
		{
			$period := $r	
		}
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	// @fun_def rate_min($rate_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_min := $rate_m
	// }
	// @fun_def rate_max($rate_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate_max := $rate_ma
	// }

	// @fun_def env_dur_min($env_dur_m) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_min := $env_dur_m
	// }
	// @fun_def env_dur_max($env_dur_ma) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur_max := $env_dur_ma
	// }


	// @fun_def pos_min($p_min) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_min := $p_min
	// }
	// @fun_def pos_max($p_max) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$pos_max := $p_max
	// }	
	
	@fun_def tpo($t) // seulement quand une un track a plusieurs instances du même module
	{ 
		print temp $t
		$lfo_rand_env_dur.$tpo := $t
		// $lfo_rand_radio.$tpo := $t
		// $lfo_rand_theta.$tpo := $t
		// $lfo_rand_phi.$tpo := $t
		$lfo_rand_rate.$tpo := $t
		$lfo_rand_pos_lfo.$tpo := $t
		$lfo_rand_env_dur.$tpo := $t
		$lfo_rand_ryth.$tpo := $t
	}
	@fun_def buf($bf) // seulement quand une un track a plusieurs instances du même module
	{ 
		$buf := $bf
	}		
	@fun_def envbuf0($eb0) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf0 := $eb0
	}	
	@fun_def envbuf1($eb1) // seulement quand une un track a plusieurs instances du même module
	{ 
		$envbuf1 := $eb1
	}	
	@proc_def amp($a)
	{
		@local $nim 
		if($a.is_tab()) // if $val is bpf
		{
			abort $last_bpf_a_curve // to avoid interferences

			$nim := @build_nim_from_bpf($a)
			$lamp := $a[0]
			$last_bpf_a_curve := { curve @grain := 0.01, 
				@action 
				{
					$amp := $lamp // $Servers($server_name).n_set($node_id_out, ["a", $la])	
				} 
				{ $lamp : $nim }
			}
		}
		else
		{
			$amp := $a		
		}
	}	
}


@obj_def HOA_samp_xyz_rand_pos_mod2($buf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $rand_lfo_x_min, $rand_lfo_x_max, $rand_lfo_y_min, $rand_lfo_y_max, $rand_lfo_z_min, $rand_lfo_z_max, $pos_lfo_min, $pos_lfo_max, $amp, $mix_group_decoder, $grain_group) 
{
	@init 
    {
		@local $rand_x := 0, $rand_y := 0, $rand_z := 0, $env_dur := 0.1, $rate := 1, $pos := 0, $ryth_rand := 0.1, $tpo := 120, $rand_lfo_x, $rand_lfo_y, $rand_lfo_z, $pos_lfo

		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_x($THISOBJ), $rand_lfo_x_min, $rand_lfo_x_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_y($THISOBJ), $rand_lfo_y_min, $rand_lfo_y_max, 0.5, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj(@set_HOA_rand_z($THISOBJ), $rand_lfo_z_min, $rand_lfo_z_max, 0.5, "linear", $tpo)
		// $THISOBJ.rand_lfo_basic_obj($THISOBJ.rate, $rate_min, $rate_max, 1, "linear", $tpo)
		$THISOBJ.rand_lfo_basic_obj($THISOBJ.pos_lfo(), $pos_lfo_min, $pos_lfo_max, 0., "linear", $tpo)
		// $THISOBJ.rand_lfo_basic_obj($THISOBJ.env_dur, $env_dur_min, $env_dur_max, 0.01, "linear", $tpo)

		$ryth_rand := @rand_range($ryth_min, $ryth_max)

		loop circle_rand $ryth_rand
		{
			
			$rand_x := @rand_range($x_min, $x_max)
			$rand_y := @rand_range($y_min, $y_max)
			$rand_z := @rand_range($z_min, $z_max)
			$rate := @rand_range($rate_min, $rate_max)
			$pos := @rand_range($pos_min, $pos_max)
			// $env_dur := @rand_range($env_dur_min, $env_dur_max)
			$ryth_rand := @rand_range($ryth_min, $ryth_max)

			::HOA_samp_xyz($buf, $rate, $pos+$pos_lfo, $rand_x+$rand_lfo_x+$HOA_global_x, $rand_y+$rand_lfo_y+$HOA_global_y, ($rand_z*$rand_lfo_z)+$HOA_global_z, $amp, $mix_group_decoder)
			@command("of_grains"+$grain_group) @dur2mlsec($env_dur) ($rand_x+$rand_lfo_x) ($rand_y+$rand_lfo_y) ($rand_z*$rand_lfo_z)

		}

	}

	@proc_def rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo) // seulement quand une un track a plusieurs instances du même module
	{ 
		::rand_lfo_basic_obj($param, $min, $max, $init_val, $type, $tpo)	
		// $rand_x := $min
	}
	@fun_def rand_lfo_x($x) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_lfo_x := $x
	}
	@fun_def rand_lfo_y($y) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_lfo_y := $y
	}
	@fun_def rand_lfo_z($z) // seulement quand une un track a plusieurs instances du même module
	{ 
		$rand_lfo_z := $z
	}
	// @fun_def rate($rate_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$rate := $rate_val
	// }
	@fun_def pos_lfo($pos_val) // seulement quand une un track a plusieurs instances du même module
	{ 
		$pos_lfo := $pos_val
	}
	// @fun_def env_dur($env_dur_val) // seulement quand une un track a plusieurs instances du même module
	// { 
	// 	$env_dur := $env_dur_val
	// }
}

// @obj_def HOA_grain_xyz_rand_pos_mod2($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $amp, $mix_group_decoder, $grain_group) 
			
// HOA_grain_xyz_rand_pos_mod2($buf, $envbuf, $rate_min, $rate_max, $pos_min, $pos_max, $ryth_min, $ryth_max, $env_dur_min, $env_dur_max, $x_min, $x_max, $y_min, $y_max, $z_min, $z_max, $rand_lfo_x_min, $rand_lfo_x_max, $rand_lfo_y_min, $rand_lfo_y_max, $rand_lfo_z_min, $rand_lfo_z_max, $pos_lfo_min, $pos_lfo_max, $amp, $mix_group_decoder, $grain_group) 
	


// generador de vectores aleatorios + ritmos: numero de valores de la lista, minimo maximo, tempo
@proc_def ::rand_vect_interpol2($address, $track, $param, $num, $min, $max, $tmpo)
{

	@local $t0, $t1, $del

	$t0 := @rand_vect($num, $min, $max)
	$t1 := @rand_vect($num, $min, $max)

	$del := @rand(1.) + 0.5

	loop $del+0.001 @tempo := $tmpo
	{

		$t0 := $t1
		$t1 := @rand_vect($num, $min, $max)
		
		
		    Curve trate  @Grain := 0.01s,  @Action := @command($address) $track setn $param (($t1*$y)+($t0*(1-$y)))
        {
        $y
            {
            {0.} 
            $del {1.} 
            }
        }
		0.001 $del := @rand(1.) + 0.05

	}

}

///// Flucoma integration https://www.flucoma.org
///// Analyse offline buffers
/// Slice Audio

@global $flu_onset @persistent
if (@is_undef($flu_onset)) { $flu_onset := map{} }

// [ "/cmd", "FluidBufOnsetSlice/processNew", 19677, 97, 0, -1, 0, -1, 98, 9, 0.1, 2, 5, 0, 1024, -1, -1, 1024, 1, DATA[40] ]
// server, source, startFrame: 0, numFrames: -1, startChan: 0, numChans: -1, indices, metric: 0, threshold: 0.5, minSliceLength: 2, filterSize: 5, frameDelta: 0, windowSize: 1024, hopSize: -1, fftSize: -1, freeWhenDone: true, action
@proc_def FluidBufOnsetSlice($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $indices_buf = 0, $metric = 9, $threshold = 0.1, $minSliceLength = 2, $filterSize = 5, $frameDelta = 0, $windowSize = 1024, $hopSize = -1, $fftSize = -1)
{
	@local $proc_id, $src_buf_id, $ind_buf_id, $sync_inc := @rand_int(50000), $dur_secs, $when, $num_frames, $buf_sampling_rate, $slices_points := [], $source_buf_dur

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	
	if($source_buf.is_obj())
	{
		$src_buf_id := $source_buf.id()
	}
	else
	{
		$src_buf_id := $source_buf
	}
	if($indices_buf.is_obj())
	{
		$ind_buf_id := $indices_buf.id()
	}
	else
	{
		$ind_buf_id := $indices_buf
	}	
// [ "/cmd", "FluidBufOnsetSlice", "FluidBufOnsetSlice/processNew", 9207, 43, 0, -1, 0, -1, 44, 9, 0.13, 2, 5, 0, 1024, -1, -1, 1024, 1, DATA[40] ]

	// print FluidBufOnsetSlice (""+["FluidBufOnsetSlice/processNew", $proc_id, $source_buf, $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $metric, $threshold, $minSliceLength, $filterSize, $frameDelta, $windowSize, $hopSize, $fftSize, $freeWhenDone])
	$Servers($server_name).cmd(["FluidBufOnsetSlice", "FluidBufOnsetSlice/processNew", $proc_id, $src_buf_id, $startFrame, $numFrames, $startChan, $numChans, $ind_buf_id, $metric, $threshold, $minSliceLength, $filterSize, $frameDelta, $windowSize, $hopSize, $fftSize, 1024, "toto"]) // create the vst_all file
	
	whenever (($FluidBufOnsetSliceDone[0] == $server_name) && ($FluidBufOnsetSliceDone[1] == "/done")) // wait for analyse Done
	{
		print free_replay FluidBufOnsetSliceDone $proc_id
		$Servers($server_name).b_query($indices_buf.id())
		$Servers($server_name).sync($proc_id)
		// $sync_inc += 1
	}
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $proc_id)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		print free_replay2 FluidBufOnsetSliceDone $proc_id
		$num_frames := $buf_info[3]
		$buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $indices_buf  	
		$Servers($server_name).cmd(["FluidBufOnsetSlice", "FluidBufOnsetSlice/free", $proc_id]) // free process into the server
		$Servers($server_name).b_getn($indices_buf.id(), 0, $num_frames)
		$Servers($server_name).sync($sync_inc)
		// print $sync_inc
	}	
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc
	{
		print buf_setn_final $buf_setn
		print free_replay3 FluidBufOnsetSliceDone $proc_id
		// $source_buf.dur()
		// $slices_points.push_back($buf_setn.take($num_frames*-1))
		$slices_points.push_back($buf_setn.drop(4))

		// $slices_points.push_back($source_buf.dur()*$buf_sampling_rate)
		// $slices_points.push_back($num_frames)
		// print (""+$slices_points.flatten())
		$flu_onset.add_pair($ana_name, $slices_points.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}
}

@global $flu_stats @persistent
if (@is_undef($flu_stats)) { $flu_stats := map{} }
// print (""+$flu_stats)
// [ "/cmd", "FluidBufStats", "FluidBufStats/processNew", 3519, 20, 0, -1, 0, -1, 21, 1, 0, 0, 50, 100, -1, -1, 1, DATA[40] ]
// FluidBufStats.process(server, 							source, startFrame: 0, numFrames: -1, startChan: 0, numChans: -1, stats, select, numDerivs: 0, low: 0, middle: 50, high: 100, outliersCutoff: -1, weights, freeWhenDone: true, action)
@proc_def FluidBufStats($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $stats_buf = 0, $select = 1, $numDerivs = 0, $low = 0, $middle = 50, $high = 100, $outliersCutoff = -1, $weights = -1)
{
	@local $proc_id, $sync_inc := @rand_int(50000), $dur_secs, $when, $num_frames, $buf_sampling_rate, $slices_points := [], $source_buf_dur, $stats_points

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	
// [ "/cmd", "FluidBufOnsetSlice", "FluidBufOnsetSlice/processNew", 9207, 43, 0, -1, 0, -1, 44, 9, 0.13, 2, 5, 0, 1024, -1, -1, 1024, 1, DATA[40] ]

	// print FluidBufOnsetSlice (""+["FluidBufOnsetSlice/processNew", $proc_id, $source_buf, $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $metric, $threshold, $minSliceLength, $filterSize, $frameDelta, $windowSize, $hopSize, $fftSize, $freeWhenDone])
	$Servers($server_name).cmd(["FluidBufStats", "FluidBufStats/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $stats_buf.id(), $select, $numDerivs, $low, $middle, $high, $outliersCutoff, $weights, 1])
	
	whenever (($FluidBufStatsDone[0] == $server_name) && ($FluidBufStatsDone[1] == "/done")) // wait for analyse Done
	{
		// print free_replay FluidBufStatsDone $proc_id
		// $Servers($server_name).b_query($stats_buf.id())
		// $stats_buf.b_getn(0, 1)
		$Servers($server_name).cmd(["FluidBufStats", "FluidBufStats/free", $proc_id]) // free process into the server

		// $Servers($server_name).sync($proc_id)
		abort $when
		// $sync_inc += 1
	}
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $proc_id)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		print free_replay2 FluidBufStatsDone $proc_id
		// $num_frames := $buf_info[3]
		// $buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $stats_buf  	
		$Servers($server_name).cmd(["FluidBufStats", "FluidBufStats/free", $proc_id]) // free process into the server
		// $Servers($server_name).b_getn($stats_buf.id(), 0, $num_frames)
		// $Servers($server_name).sync($sync_inc)
		// print $sync_inc
		abort $when
	}	*/
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc
	{
		// print buf_setn_final $buf_setn
		// print free_replay3 FluidBufStatsDone $proc_id
		// $source_buf.dur()
		// $stats_points.push_back($buf_setn.take($num_frames*-1))
		// $stats_points.push_back($buf_setn.drop(4))

		// $stats_points.push_back($source_buf.dur()*$buf_sampling_rate)
		// $stats_points.push_back($num_frames)
		// print (""+$stats_points.flatten())
		// $flu_stats.add_pair($ana_name, $stats_points.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}*/
}


// [ "/cmd", "FluidBufFlatten", "FluidBufFlatten/processNew", 15608, 19, 0, -1, 0, 											  -1,                  20,          1, 1, DATA[40] ]
// FluidBufFlatten.processBlocking(server, source, startFrame: 0, numFrames: -1, startChan: 0, numChans: -1, destination, axis: 1, freeWhenDone: true, action)

@proc_def FluidBufFlatten($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $destination_buf = 0, $axis = 1)
{
	@local $proc_id, $when

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	
// [ "/cmd", "FluidBufOnsetSlice", "FluidBufOnsetSlice/processNew", 9207, 43, 0, -1, 0, -1, 44, 9, 0.13, 2, 5, 0, 1024, -1, -1, 1024, 1, DATA[40] ]

	// print FluidBufOnsetSlice (""+["FluidBufOnsetSlice/processNew", $proc_id, $source_buf, $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $metric, $threshold, $minSliceLength, $filterSize, $frameDelta, $windowSize, $hopSize, $fftSize, $freeWhenDone])
	$Servers($server_name).cmd(["FluidBufFlatten", "FluidBufFlatten/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $destination_buf.id(), $axis, 1])
	
	whenever (($FluidBufFlattenDone[0] == $server_name) && ($FluidBufFlattenDone[1] == "/done")) // wait for analyse Done
	{
		// print free_replay FluidBufFlattenDone $proc_id
		// $Servers($server_name).b_query($stats_buf.id())
		// $stats_buf.b_getn(0, 1)
		$Servers($server_name).cmd(["FluidBufFlatten", "FluidBufFlatten/free", $proc_id]) // free process into the server

		// $Servers($server_name).sync($proc_id)
		abort $when
		// $sync_inc += 1
	}
}

@global $flu_compose @persistent
if (@is_undef($flu_compose)) { $flu_compose := map{} }
// print (""+$flu_compose)
// [ "/cmd", "FluidBufCompose", "FluidBufCompose/processNew", 3520, 21, 		  0, 			  -1, 			   0, 			  -1, 		  1,  22, 							  0, 	             0,  		  0, 1, DATA[40] ]
// FluidBufCompose.process(server, source, startFrame: 0, numFrames: -1, startChan: 0, numChans: -1, gain: 1, destination, destStartFrame: 0, destStartChan: 0, destGain: 0, freeWhenDone: true, action)

@proc_def FluidBufCompose($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $gain = 1, $destination_buf = 0, $destStartFrame = 0, $destStartChan = 0, $destGain = 0)
{
	@local $proc_id, $src_buf_id, $dest_buf_id, $sync_inc := @rand_int(50000), $dur_secs, $when, $num_frames, $buf_sampling_rate, $slices_points := [], $source_buf_dur, $compose_points

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	
	if($source_buf.is_obj())
	{
		$src_buf_id := $source_buf.id()
	}
	else
	{
		$src_buf_id := $source_buf
	}
	if($destination_buf.is_obj())
	{
		$dest_buf_id := $destination_buf.id()
	}
	else
	{
		$dest_buf_id := $destination_buf
	}	
	// [ "/cmd", "FluidBufOnsetSlice", "FluidBufOnsetSlice/processNew", 9207, 43, 0, -1, 0, -1, 44, 9, 0.13, 2, 5, 0, 1024, -1, -1, 1024, 1, DATA[40] ]
	// print FluidBufOnsetSlice (""+["FluidBufOnsetSlice/processNew", $proc_id, $source_buf, $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $metric, $threshold, $minSliceLength, $filterSize, $frameDelta, $windowSize, $hopSize, $fftSize, $freeWhenDone])
	$Servers($server_name).cmd(["FluidBufCompose", "FluidBufCompose/processNew", $proc_id, $src_buf_id, $startFrame, $numFrames, $startChan, $numChans, $gain, $dest_buf_id, $destStartFrame, $destStartChan, $destGain, 1])
	
	whenever (($FluidBufComposeDone[0] == $server_name) && ($FluidBufComposeDone[1] == "/done")) // wait for analyse Done
	{
		// print free_replay FluidBufComposeDone $proc_id
		// $Servers($server_name).b_query($destination_buf.id())
		$Servers($server_name).cmd(["FluidBufCompose", "FluidBufCompose/free", $proc_id]) // free process into the server
		// $Servers($server_name).sync($proc_id)
		abort $when	
		// $sync_inc += 1
	}
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $proc_id)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		print free_replay2 FluidBufComposeDone $proc_id
		// $num_frames := $buf_info[3]
		// $buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $destination_buf  	
		$Servers($server_name).cmd(["FluidBufCompose", "FluidBufCompose/free", $proc_id]) // free process into the server
		// $Servers($server_name).b_getn($destination_buf.id(), 0, $num_frames)
		// $Servers($server_name).sync($sync_inc)
		// print $sync_inc
		abort $when	
	}	*/
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc
	{
		// print buf_setn_final $buf_setn
		// print free_replay3 FluidBufComposeDone $proc_id
		// $source_buf.dur()
		// $compose_points.push_back($buf_setn.take($num_frames*-1))
		// $compose_points.push_back($buf_setn.drop(4))

		// $compose_points.push_back($source_buf.dur()*$buf_sampling_rate)
		// $compose_points.push_back($num_frames)
		// print (""+$compose_points.flatten())
		// $flu_compose.add_pair($ana_name, $compose_points.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}*/
}

@proc_def FluidBufTransientSlice($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $indices_buf = 0, $order = 20, $blockSize = 256, $padSize = 128, $skew = 0, $threshFwd = 2, $threshBack = 1.1, $windowSize = 14, $clumpLength = 25, $minSliceLength = 1000)
{
	@local $proc_id, $sync_inc := 0, $dur_secs, $when, $num_frames, $buf_sampling_rate, $slices_points := [0]

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

	// print FluidBufOnsetSlice (""+["FluidBufOnsetSlice/processNew", $proc_id, $source_buf, $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $metric, $threshold, $minSliceLength, $filterSize, $frameDelta, $windowSize, $hopSize, $fftSize, $freeWhenDone])
	$Servers($server_name).cmd(["FluidBufTrSlice/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $order, $blockSize, $padSize, $skew, $threshFwd, $threshBack, $windowSize, $clumpLength, $minSliceLength]) 
	
	whenever (($FluidBufTrSliceDone[0] == $server_name) && ($FluidBufTrSliceDone[1] == "/done")) // wait for analyse Done
	{
		$Servers($server_name).b_query($indices_buf)
		$Servers($server_name).sync($sync_inc)
		$sync_inc += 1
	}
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 0)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		$num_frames := $buf_info[3]
		$buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $indices_buf  	
		$Servers($server_name).cmd(["FluidBufTrSlice/free", $proc_id]) // free process into the server
		$Servers("server1").b_getn($indices_buf, 0, $num_frames)
		$Servers($server_name).sync($sync_inc)
		// print $sync_inc
	}	
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 1)) // wait for server syc
	{
		print buf_setn_final $buf_setn
		$source_buf.dur()
		$slices_points.push_back($buf_setn.take($num_frames*-1))
		$slices_points.push_back($source_buf.dur()*$buf_sampling_rate)
		// print (""+$slices_points.flatten())
		$flu_onset.add_pair($ana_name, $slices_points.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}
}


@proc_def FluidBufAmpSlice($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $indices_buf = 0, $fastRampUp = 1, $fastRampDown = 1, $slowRampUp = 100, $slowRampDown = 100, $onThreshold = -144, $offThreshold = -144, $floor = -144, $minSliceLength = 2, $highPassFreq = 85)
{
	@local $proc_id, $sync_inc := 0, $dur_secs, $when, $num_frames, $buf_sampling_rate, $slices_points := [0]

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

	$Servers($server_name).cmd(["FluidBufAmpSlice/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $fastRampUp, $fastRampDown, $slowRampUp, $slowRampDown, $onThreshold, $offThreshold, $floor, $minSliceLength, $highPassFreq])
	
	whenever (($FluidBufAmpSliceDone[0] == $server_name) && ($FluidBufAmpSliceDone[1] == "/done")) // wait for analyse Done
	{
		$Servers($server_name).b_query($indices_buf)
		$Servers($server_name).sync($sync_inc)
		$sync_inc += 1
	}
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 0)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		$num_frames := $buf_info[3]
		$buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $indices_buf  	
		$Servers($server_name).cmd(["FluidBufAmpSlice/free", $proc_id]) // free process into the server
		$Servers("server1").b_getn($indices_buf, 0, $num_frames)
		$Servers($server_name).sync($sync_inc)
		// print $sync_inc
	}	
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 1)) // wait for server syc
	{
		print buf_setn_final $buf_setn
		$source_buf.dur()
		$slices_points.push_back($buf_setn.take($num_frames*-1))
		$slices_points.push_back($source_buf.dur()*$buf_sampling_rate)
		// print (""+$slices_points.flatten())
		$flu_onset.add_pair($ana_name, $slices_points.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}
}

@proc_def FluidBufNoveltySlice($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $indices_buf = 0, $algorithm = 0, $kernelSize = 3, $threshold = 0.5, $filterSize = 1, $minSliceLength = 2, $windowSize = 1024, $hopSize = -1, $fftSize = -1)
{
	@local $proc_id, $sync_inc := 0, $dur_secs, $when, $num_frames, $buf_sampling_rate, $slices_points := [0]

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

	$Servers($server_name).cmd(["FluidBufNoveltySlice/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $algorithm, $kernelSize, $threshold, $filterSize, $minSliceLength, $windowSize, $hopSize, $fftSize])
	
	whenever (($FluidBufNoveltySliceDone[0] == $server_name) && ($FluidBufNoveltySliceDone[1] == "/done")) // wait for analyse Done
	{
		$Servers($server_name).b_query($indices_buf)
		$Servers($server_name).sync($sync_inc)
		$sync_inc += 1
	}
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 0)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		$num_frames := $buf_info[3]
		$buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $indices_buf  	
		$Servers($server_name).cmd(["FluidBufNoveltySlice/free", $proc_id]) // free process into the server
		$Servers("server1").b_getn($indices_buf, 0, $num_frames)
		$Servers($server_name).sync($sync_inc)
		// print $sync_inc
	}	
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 1)) // wait for server syc
	{
		print buf_setn_final $buf_setn
		$source_buf.dur()
		$slices_points.push_back($buf_setn.take($num_frames*-1))
		$slices_points.push_back($source_buf.dur()*$buf_sampling_rate)
		// print (""+$slices_points.flatten())
		$flu_onset.add_pair($ana_name, $slices_points.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}
}


@proc_def FluidBufAmpGate($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $indices_buf = 0, $rampUp = 10, $rampDown = 10, $onThreshold = -90, $offThreshold = -90, $minSliceLength = 1, $minSilenceLength = 1, $minLengthAbove = 1, $minLengthBelow = 1, $lookBack = 0, $lookAhead = 0, $highPassFreq = 85, $trig = 1, $blocking = 0)
{
	@local $proc_id, $sync_inc := 0, $dur_secs, $when, $num_frames, $buf_sampling_rate, $slices_points := [0]

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

	$Servers($server_name).cmd(["FluidBufAmpGate/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $indices_buf, $rampUp, $rampDown, $onThreshold, $offThreshold, $minSliceLength, $minSilenceLength, $minLengthAbove, $minLengthBelow, $lookBack, $lookAhead, $highPassFreq, $trig, $blocking])
	
	whenever (($FluidBufAmpGateDone[0] == $server_name) && ($FluidBufAmpGateDone[1] == "/done")) // wait for analyse Done
	{
		$Servers($server_name).b_query($indices_buf)
		$Servers($server_name).sync($sync_inc)
		$sync_inc += 1
	}
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 0)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		$num_frames := $buf_info[3]
		$buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $indices_buf  	
		$Servers($server_name).cmd(["FluidBufAmpGate/free", $proc_id]) // free process into the server
		$Servers("server1").b_getn($indices_buf, 0, $num_frames)
		$Servers($server_name).sync($sync_inc)
		// print $sync_inc
	}	
	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == 1)) // wait for server syc
	{
		print buf_setn_final $buf_setn
		$source_buf.dur()
		$slices_points.push_back($buf_setn.take($num_frames*-1))
		$slices_points.push_back($source_buf.dur()*$buf_sampling_rate)
		// print (""+$slices_points.flatten())
		$flu_onset.add_pair($ana_name, $slices_points.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}

}		

/*[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1759, 0, 302592, 24064,0, -1, 53, 1, 127, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] 127 = all
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 508, 0, 69632,   7168, 0, -1, 17, 1, 7, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ]
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 406, 0, 51200,  18432, 0, -1, 14, 1, 6, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ]
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 298, 0, 1536,  6144,   0, -1, 11, 1, 4, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ]
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 199, 0, 1536,    6144, 0, -1, 8,  1, 8, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ]
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 211, 0, 69632,  7168,  0, -1, 8,  1, 8, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ]
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1, 0,   1536,    6144, 0, -1, 2,  1, 1, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 109, 0, 51200,  18432, 0, -1, 5,  1, 2, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] spread
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 616, 0, 100864, 13312, 0, -1, 20, 1, 3, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid spread
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 724, 0, 151552, 5632, 0, -1, 23,  1, 4, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] skewness
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 889, 0, 417280, 12800, 0, -1, 26, 1, 5, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid skewness
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 973, 0, 353280, 18944, 0, -1, 29, 1, 6, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] spread skewness
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1381, 0, 403968, 13312, 0, -1, 41, 1, 7, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid spread skewness
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1075, 0, 372224, 6656, 0, -1, 32, 1, 8, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] kurtosis
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1186, 0, 417280, 12800, 0, -1, 35, 1, 9, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid kurtosis
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1246, 0, 252416, 6656, 0, -1, 38, 1, 10, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] spread kurtosis
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1246, 0, 252416, 6656, 0, -1, 38, 1, 11, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] skewness kurtosis
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1246, 0, 252416, 6656, 0, -1, 38, 1, 12, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid spread kurtosis
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1246, 0, 252416, 6656, 0, -1, 38, 1, 13, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid skewness kurtosis
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1246, 0, 252416, 6656, 0, -1, 38, 1, 14, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] spread skewness kurtosis
[ "/cmd", "FluidBufSpectralShape", "FluidBufSpectralShape/processNew", 1246, 0, 252416, 6656, 0, -1, 38, 1, 15, 0, -1, 95, 0, 0, 1024, -1, -1, 1024, 1, DATA[40] ] centroid spread skewness kurtosis
*/

$SpectralShape := map{(["centroid"], 1), (["spread"], 2), (["centroid", "spread"], 3)}

// print (""+$SpectralShape(["centroid", "spread"]))
																	// server, source, startFrame: 0, numFrames: -1, startChan: 0, numChans: -1, features, 	select, minFreq: 0, maxFreq: -1, rolloffPercent: 95, unit: 0, power: 0, windowSize: 1024, hopSize: -1, fftSize: -1, padding: 1, freeWhenDone: true, action
@proc_def FluidBufSpectralShape($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $features_buf = 0, $extra1 = 1, $select = ["centroid"], $minFreq = 0, $maxFreq = -1, $rolloffPercent = 95, $unit = 0, $power = 0, $windowSize = 1024, $hopSize = -1, $fftSize = -1, $windowSize2 = 1024, $padding = 1)
{
	@local $proc_id, $sync_inc := @rand_int(50000), $dur_secs, $when, $num_frames, $buf_sampling_rate, $anal_result := [0]

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

	$Servers($server_name).cmd(["FluidBufSpectralShape", "FluidBufSpectralShape/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $features_buf.id(), $extra1, $SpectralShape($select), $minFreq, $maxFreq, $rolloffPercent, $unit, $power, $windowSize, $hopSize, $fftSize, $windowSize2, $padding])
	
	whenever (($FluidBufSpectralShapeDone[0] == $server_name) && ($FluidBufSpectralShapeDone[1] == "/done")) // wait for analyse Done
	{
		// print FluidBufSpectralShapeDone $FluidBufSpectralShapeDone
		// $Servers($server_name).b_query($features_buf)
		$Servers($server_name).cmd(["FluidBufSpectralShape", "FluidBufSpectralShape/free", $proc_id]) // free process into the server
		// $Servers($server_name).sync($proc_id)
		abort $when
		// $sync_inc += 1
	}
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $proc_id)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		$num_frames := $buf_info[3]
		$buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $indices_buf  	
		$Servers($server_name).cmd(["FluidBufSpectralShape", "FluidBufSpectralShape/free", $proc_id]) // free process into the server
		// $Servers($server_name).b_getn($features_buf, 0, $num_frames)
		$Servers($server_name).sync($sync_inc)
		// print $sync_inc
		abort $when
	}	*/
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc
	{
		print SpectralShape_buf_setn_final $buf_setn
		// $source_buf.dur()
		// $anal_result.push_back($buf_setn.take($num_frames*-1))
		// $anal_result.push_back($source_buf.dur()*$buf_sampling_rate)
		// // print (""+$anal_result.flatten())
		// $flu_onset.add_pair($ana_name, $anal_result.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}*/
}
// print (""+$flu_onset)

// [ "/cmd", "FluidBufLoudness", "FluidBufLoudness/processNew", 272, 0, 16896, 21504, 0, -1, 11, 1, 1, 1, 1, 1024, 512, 1024, 1, DATA[40] ]
// [ "/cmd", "FluidBufMFCC", "FluidBufMFCC/processNew", 15672, 10,       2.22336e+07,         12288,            0, 		  -1,       18,     1, 13, 13,        40, 40,            1,          20, 		  20000,             1024, 		    -1, 		 -1,       1024,              1, DATA[40] ]
// FluidBufMFCC.processBlocking(server, 						source, startFrame: 0, numFrames: -1, startChan: 0, numChans: -1, features, numCoeffs: 13, numBands: 40, startCoeff: 0, minFreq: 20, maxFreq: 20000, windowSize: 1024, hopSize: -1, fftSize: -1, padding: 1, freeWhenDone: true, action)
@proc_def FluidBufMFCC($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $features_buf = 0, $numCoeffs = 13, $numBands = 40, $startCoeff = 1, $minFreq = 20, $maxFreq = 20000, $windowSize = 1024, $hopSize = -1, $fftSize = -1, $padding = 1024)
{
	@local $proc_id, $sync_inc := @rand_int(50000), $dur_secs, $when, $num_frames, $buf_sampling_rate, $anal_result := [0]

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

	$Servers($server_name).cmd(["FluidBufMFCC", "FluidBufMFCC/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $features_buf.id(), 1, $numCoeffs, $numCoeffs, $numBands, $numBands, $startCoeff, $minFreq, $maxFreq, $windowSize, $hopSize, $fftSize, $padding, 1])
	
	whenever (($FluidBufMFCCDone[0] == $server_name) && ($FluidBufMFCCDone[1] == "/done")) // wait for analyse Done
	{
		// print FluidBufMFCCDone $FluidBufMFCCDone
		// $Servers($server_name).b_query($features_buf)
		$Servers($server_name).cmd(["FluidBufMFCC", "FluidBufMFCC/free", $proc_id]) // free process into the server
		// $Servers($server_name).sync($proc_id)
		abort $when
		// $sync_inc += 1
	}
}

// [ "/cmd", "FluidBufPitch", "FluidBufPitch/processNew", 1, 0, 0,         -1,			   0, 			-1,        1,     1, 3,          2,          20,          10000,       0,             1024,         512,         -1,       1024,   1, DATA[40] ]
// FluidBufPitch.processBlocking(server, source, startFrame: 0, numFrames: -1, startChan: 0, numChans: -1, features, select, algorithm: 2, minFreq: 20, maxFreq: 10000, unit: 0, windowSize: 1024, hopSize: -1, fftSize: -1, padding: 1, freeWhenDone: true, action)

@proc_def FluidBufPitch($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $features_buf = 0, $select = 3, $algorithm = 2, $minFreq = 20, $maxFreq = 10000, $unit = 0, $windowSize = 1024, $hopSize = 512, $fftSize = -1, $padding = 1024, $freeWhenDone = 1)
{
	@local $proc_id, $when

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

	$Servers($server_name).cmd(["FluidBufPitch", "FluidBufPitch/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $features_buf.id(), 1, $select, $algorithm, $minFreq, $maxFreq, $unit, $windowSize, $hopSize, $fftSize, $padding, $freeWhenDone])
	
	whenever (($FluidBufPitchDone[0] == $server_name) && ($FluidBufPitchDone[1] == "/done")) // wait for analyse Done
	{
		// print FluidBufPitchDone $FluidBufPitchDone
		// $Servers($server_name).b_query($features_buf)
		$Servers($server_name).cmd(["FluidBufPitch", "FluidBufPitch/free", $proc_id]) // free process into the server
		// $Servers($server_name).sync($proc_id)
		abort $when
		// $sync_inc += 1
	}
}


@obj_def FluidNormalize($server_name, $min = 0, $max = 1)
{
	@init 
    {
	    @local $proc_id

		$when := $MYSELF
		$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

		// [ "/cmd", "FluidNormalize", "FluidNormalize/new", 5462, 0, 1 ]
		$Servers($server_name).cmd(["FluidNormalize", "FluidNormalize/new", $proc_id,  $min, $max])
	}
	@proc_def fitTransform($dataset, $dataset_norm)
	{
		print fitTransform (""+$dataset.id()) (""+$dataset_norm.id())
		// [ "/cmd", "FluidNormalize", "FluidNormalize/setParams", 5463, 5463, 0, 1, -1, -1 ]
		$Servers($server_name).cmd(["FluidNormalize", "FluidNormalize/setParams", $proc_id, $proc_id, $min, $max, -1, -1])
		// [ "/cmd", "FluidNormalize", "FluidNormalize/fitTransform", 5474, 4, 5473 ]
		$Servers($server_name).cmd(["FluidNormalize", "FluidNormalize/fitTransform", $proc_id, $dataset.id(), $dataset_norm.id()])
	}
}

@proc_def FluidBufLoudness($server_name, $ana_name, $source_buf, $startFrame = 0, $numFrames = -1, $startChan = 0, $numChans = -1, $features_buf = 0, $select = 1, $kWeighting = 1, $truePeak = 1, $windowSize = 1024, $hopSize = 512, $padding = 1)
{
	@local $proc_id, $sync_inc := @rand_int(50000), $dur_secs, $when, $num_frames, $buf_sampling_rate, $anal_result := [0]

	$when := $MYSELF
	$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
	$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	
 													// [ "/cmd", "FluidBufLoudness", "FluidBufLoudness/processNew", 4, 0, 1536, 6144, 0, -1, 750000											, 1, 1, 1, 1, 1024, 512, 1024, 1, DATA[40] ]

	$Servers($server_name).cmd(["FluidBufLoudness", "FluidBufLoudness/processNew", $proc_id, $source_buf.id(), $startFrame, $numFrames, $startChan, $numChans, $features_buf.id(), 1, $select, $kWeighting, $truePeak, $windowSize, $hopSize, 1024, $padding])
	
	whenever (($FluidBufLoudnessDone[0] == $server_name) && ($FluidBufLoudnessDone[1] == "/done")) // wait for analyse Done
	{
		// print FluidBufLoudnessDone $FluidBufLoudnessDone
		// $Servers($server_name).b_query($features_buf)
		$Servers($server_name).cmd(["FluidBufLoudness", "FluidBufLoudness/free", $proc_id]) // free process into the server
		// $Servers($server_name).sync($proc_id)
		abort $when
		// $sync_inc += 1
	}
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $proc_id)) // wait for server syc
	{		
		// print buf_info2 $buf_info
		// print buf_frames ($buf_info[3])	
		// print buf_sampling_rate ($buf_info[5])
		$num_frames := $buf_info[3]
		$buf_sampling_rate := $buf_info[5]
		// print buffer_analyse $indices_buf  	
		$Servers($server_name).cmd(["FluidBufSpectralShape", "FluidBufSpectralShape/free", $proc_id]) // free process into the server
		// $Servers($server_name).b_getn($features_buf, 0, $num_frames)
		$Servers($server_name).sync($sync_inc)
		// print $sync_inc
		abort $when
	}	*/
/*	whenever (($server_sync[0] == $server_name) && ($server_sync[1] == $sync_inc)) // wait for server syc
	{
		print SpectralShape_buf_setn_final $buf_setn
		// $source_buf.dur()
		// $anal_result.push_back($buf_setn.take($num_frames*-1))
		// $anal_result.push_back($source_buf.dur()*$buf_sampling_rate)
		// // print (""+$anal_result.flatten())
		// $flu_onset.add_pair($ana_name, $anal_result.flatten())
		// $dur_secs := ($endPos - $startPos) / buf.sampleRate;

		abort $when	 // free antescofo process 
	}*/
}

// [ "/cmd", "FluidDataSet", "FluidDataSet/new", 263 ]

@obj_def FluidDataSet($server_name) //create objet/buffer with parameters
{
	@init 
    {
	    @local $proc_id, $sync := @rand_int(50000), $num_frames, $num_chnls, $buf_sampling_rate, $list_get_state := 0, $frame_list := [], $get_state := 0, $b_get


		$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) 

	    $Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/new", $proc_id]) // free process into the server
	}
	@fun_def addPoint($identifier, $buffer) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/addPoint", 264, "my-point", 13 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/addPoint", $proc_id, $identifier, $buffer.id()]) // free process into the server
	}
	@fun_def print() // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/print", 264 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/print", $proc_id]) // free process into the server
	}
	@fun_def setPoint($identifier, $buffer) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/print", 264 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/setPoint", $proc_id, $identifier, $buffer.id()]) // free process into the server
	}
	@fun_def updatePoint($identifier, $buffer) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/print", 264 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/updatePoint", $proc_id, $identifier, $buffer.id()]) // free process into the server
	}
	@fun_def deletePoint($identifier) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/print", 264 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/deletePoint", $proc_id, $identifier]) // free process into the server
	}	
	@fun_def fromBuffer($buffer, $transp = 0) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/fromBuffer", 275, 15, 0, 0, DATA[20] ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/fromBuffer", $proc_id, $buffer.id(), $transp, 0]) // free process into the server
	}	
	@fun_def toBuffer($buffer, $transp = 0) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/fromBuffer", 275, 15, 0, 0, DATA[20] ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/toBuffer", $proc_id, $buffer.id(), $transp, 0]) // free process into the server
	}	
	@fun_def write($file_name) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/write", 281, "/Users/josephfernandez/Library/Application Support/SuperCollider/tmp/temp_dataset.json" ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/write", $proc_id, $path_tmp+$file_name]) // free process into the server
	}				
	@fun_def read($file_name) // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/read", 283, "/Users/josephfernandez/Library/Application Support/SuperCollider/tmp/temp_dataset.json" ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/read", $proc_id, $path_tmp+$file_name]) // free process into the server
	}	
	@fun_def size() // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/size", 281 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/size", $proc_id]) // free process into the server
	}	
	@fun_def cols() // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/cols", 281 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/cols", $proc_id]) // free process into the server
	}	
	@fun_def dump() // seulement quand une un track a plusieurs instances du même module
	{ 
		// [ "/cmd", "FluidDataSet", "FluidDataSet/cols", 281 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/write", $proc_id, $relative_path_temp+"proc_id_data"]) // free process into the server
		//load json from disk to antescofo
	}		
	@fun_def clear() // seulement quand une un track a plusieurs instances du même module
	{ 
		// 	[ "/cmd", "FluidDataSet", "FluidDataSet/clear", 285 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/clear", $proc_id]) // free process into the server
		//load json from disk to antescofo
	}	
	@fun_def merge($datasetA, $datasetB) // merge dataset B into dataset A
	{ 
		// 	[ "/cmd", "FluidDataSet", "FluidDataSet/merge", 2874, 5460, 0 ]
		$Servers($server_name).cmd(["FluidDataSet", "FluidDataSet/clear", $datasetA, $datasetB, 0]) // free process into the server
		//load json from disk to antescofo
	}		
	@fun_def id() // merge dataset B into dataset A
	{ 
		return $proc_id
	}	
}

// [ "/cmd", "FluidUMAP", "FluidUMAP/new", 12300, 2, 5, 0.3, 200, 0.1 ]
// FluidUMAP.new(server, numDimensions: 2, numNeighbours: 15, minDist: 0.1, iterations: 200, learnRate: 0.1)

@obj_def FluidUMAP($server_name, $numDimensions = 2, $numNeighbours = 15, $minDist = 0.1, $iterations = 200, $learnRate = 0.1)
{
	@init 
    {
	    @local $proc_id

		$when := $MYSELF
		$proc_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$SC_Servers($server_name).add_pair("node_id", $proc_id + 1) // incremente le node_id dans le dico des serveurs	

		// [ "/cmd", "FluidNormalize", "FluidNormalize/new", 5462, 0, 1 ]
		$Servers($server_name).cmd(["FluidUMAP", "FluidUMAP/new", $proc_id, $numDimensions, $numNeighbours, $minDist, $iterations, $learnRate])

	}
	@proc_def fitTransform($dataset, $dataset_umap)
	{
		// print fitTransform (""+$dataset.id()) (""+$dataset_umap.id())
		// [ "/cmd", "FluidUMAP", "FluidUMAP/setParams", 12310, 12310, 2, 5, 0.3, 200, 0.1 ]
		$Servers($server_name).cmd(["FluidUMAP", "FluidUMAP/setParams", $proc_id, $proc_id, $numDimensions, $numNeighbours, $minDist, $iterations, $learnRate])

		// [ "/cmd", "FluidUMAP", "FluidUMAP/fitTransform", 12310, 8921, 12309 ]
		$Servers($server_name).cmd(["FluidUMAP", "FluidUMAP/fitTransform", $proc_id, $dataset.id(), $dataset_umap.id()])
	}
}

///// Analyse real time
/// Slice Audio

$onsetdetect := []

@obj_def onset_detect($server_name, $inst, $onset_algo = "Fluid_OnsetReplay", $thresh = 0.5, $antirebond = 1, $id = 0, $amp = 0) // del in ms
{
	@local $bus, $group_id, $input_id, $onset_id, $actif := 1, $action, $onebang := 1, $pause := 1 //, $nom, $inc
	@init 
	{
		print onset id $id
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs	

		$input_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $input_id, 1, $group_id, input, $inst, out, $bus, amp, $amp])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $input_id + 1) // incremente pour le prochain	

		$onset_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new([$onset_algo, $onset_id, 3, $input_id, "in", $bus, id, $id, thresh, $thresh])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $onset_id + 1) // incremente pour le prochain	
	}

	@abort
	{
		$Servers($server_name).n_free($group_id)
		print onset intrument $inst off 
	}
	@fun_def actif($y) {
  	      $actif := $y
  	}
  	@fun_def relaxtime($relaxt) {
  		// crea_track8 $track set 01_Perc_OnsetReplay relaxtime $relaxt
  		$Servers($server_name).n_set($onset_id, [relaxtime, $relaxt])
  	}
  	@fun_def antirebond($anti) {
  		$antirebond := $anti
  	}  	
  	@fun_def thresh($thrs) {
      	// crea_track8 $track set 01_Perc_OnsetReplay thresh $thresh
  		$Servers($server_name).n_set($onset_id, [thresh, $thrs])

    }

    @fun_def floor($floor) {
      	// crea_track8 $track set 01_Perc_OnsetReplay floor $floor
      	$Servers($server_name).n_set($onset_id, ["floor", $floor])
    }    
  	@proc_def pause($pse) 
  	{
  		// crea_track8 $track pause $pause //temps fade_out
  		$pause := 0
  		print onset pause
  		$Servers($server_name).n_set($input_id, ["amp", -120, "matrix_ramp", $pse])
		0.01s $Servers($server_name).n_run($group_id, 0)

  	}
  	@fun_def resume($rsme) {
  		// crea_track8 $track resume $resume //temps fade_in
  		$pause := 1
  		print onset resume
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($input_id, ["amp", $amp, "matrix_ramp", $rsme])
  	}  	
  	@proc_def free() 
  	{
  		// crea_track8 $track off $fade_out
     	// print $track $THISOBJ off 
     	print free onsetdetect id $id
     	$Servers($server_name).n_free($group_id) 	
    }
   	@fun_def id()
   	{
   		return $id
   	}  
   	@fun_def inst($instr, $am = 0)
   	{
   		$Servers($server_name).n_set($input_id, [input, $inst, "amp", $am])
   	}
	@whenever (($descriptors_receives[0] == $server_name) && $actif && ($descriptors_receives[1][0] == "/onsetdetect") && ($descriptors_receives[1][2] == $id))
	{
		// print onset $onsetdetect
		// if ($stop_detect){
			// group 
			// {
			// 	($del)ms iana_anal bang 
			// }
			// print onsetdetect id $id
			// $onset_id := $id
			// $nextevent := 1
			$onsetdetect := [$server_name, $id] // send to whenever
			$actif := 0
			let $descriptors_receives[1][2] := -1 // avoid whenever loop
			($antirebond) $actif := 1 //antirebond
			// print onsetdetect FINAL id $id inst $inst onset $onsetdetect
			
		// }
	}
}

$ampgatedetect := []

@obj_def ampgate_detect($server_name, $inst, $onset_algo = "Fluid_AmpGate", $params = [rampUp, 5, rampDown, 25, onThreshold, -12, offThreshold, -12, lookAhead, 480], $antirebond = 1, $id = 0, $amp = 0) // del in ms
{
	@local $bus, $group_id, $input_id, $onset_id, $actif := 1, $action, $onebang := 1, $pause := 1 //, $nom, $inc
	@init 
	{
		print ampgate id $id
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs	

		$input_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $input_id, 1, $group_id, input, $inst, out, $bus, amp, $amp])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $input_id + 1) // incremente pour le prochain	

		$onset_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new([$onset_algo, $onset_id, 3, $input_id, "in", $bus, id, $id].concat($params))  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $onset_id + 1) // incremente pour le prochain	
	}

	@abort
	{
		$Servers($server_name).n_free($group_id)
		print onset intrument $inst off 
	}
	@fun_def actif($y) {
  	      $actif := $y
  	}
  	@fun_def relaxtime($relaxt) {
  		// crea_track8 $track set 01_Perc_OnsetReplay relaxtime $relaxt
  		$Servers($server_name).n_set($onset_id, [relaxtime, $relaxt])
  	}
  	@fun_def antirebond($anti) {
  		$antirebond := $anti
  	}  	
  	@fun_def params($par) // tab [par, val]
  	{
      	// crea_track8 $track set 01_Perc_OnsetReplay thresh $thresh
  		$Servers($server_name).n_set($onset_id, $par)

    }

    @fun_def floor($floor) {
      	// crea_track8 $track set 01_Perc_OnsetReplay floor $floor
      	$Servers($server_name).n_set($onset_id, ["floor", $floor])
    }    
  	@proc_def pause($pse) 
  	{
  		// crea_track8 $track pause $pause //temps fade_out
  		$pause := 0
  		print onset pause
  		$Servers($server_name).n_set($input_id, ["amp", -120, "matrix_ramp", $pse])
		0.01s $Servers($server_name).n_run($group_id, 0)

  	}
  	@fun_def resume($rsme) {
  		// crea_track8 $track resume $resume //temps fade_in
  		$pause := 1
  		print onset resume
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($input_id, ["amp", $amp, "matrix_ramp", $rsme])
  	}  	
  	@proc_def free() 
  	{
  		// crea_track8 $track off $fade_out
     	// print $track $THISOBJ off 
     	print free onsetdetect id $id
     	$Servers($server_name).n_free($group_id) 	
    }
   	@fun_def id()
   	{
   		return $id
   	}  
   	@fun_def inst($instr, $am = 0)
   	{
   		$Servers($server_name).n_set($input_id, [input, $inst, "amp", $am])
   	}
	@whenever (($descriptors_receives[0] == $server_name) && $actif && ($descriptors_receives[1][0] == "/ampgatedetect") && ($descriptors_receives[1][2] == $id))
	{
		// print onset $onsetdetect
		// if ($stop_detect){
			// group 
			// {
			// 	($del)ms iana_anal bang 
			// }
			// print onsetdetect id $id
			// $onset_id := $id
			// $nextevent := 1
			$ampgatedetect := [$server_name, $id] // send to whenever
			$actif := 0
			let $descriptors_receives[1][2] := -1 // avoid whenever loop
			($antirebond) $actif := 1 //antirebond
			// print onsetdetect FINAL id $id inst $inst onset $onsetdetect
			
		// }
	}
}

$fluid_loudness := []
@obj_def fluid_loudness($server_name, $inst, $loudness_algo = "Fluid_Loudness", $lagTimeU = 0.001, $lagTimeD = 0.1, $kWeighting = 1, $truePeak = 1, $windowSize = 1024, $hopSize = 512, $trig_rate = 30, $id = 0, $amp = 0) // del in ms
{
	@local $bus, $group_id, $input_id, $onset_id, $actif := 1, $action, $onebang := 1, $pause := 1 //, $nom, $inc
	@init 
	{
		print onset id $id
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs	

		$input_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $input_id, 1, $group_id, input, $inst, out, $bus, amp, $amp])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $input_id + 1) // incremente pour le prochain	

		$onset_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new([$loudness_algo, $onset_id, 3, $input_id, "in", $bus, id, $id, "lagTimeU", $lagTimeU, "lagTimeD", $lagTimeD, "kWeighting", $kWeighting, "truePeak", $truePeak, "windowSize", $windowSize, "hopSize", $hopSize, "trig_rate", $trig_rate])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $onset_id + 1) // incremente pour le prochain	
	}

	@abort
	{
		$Servers($server_name).n_free($group_id)
		print onset intrument $inst off 
	}
	@fun_def actif($y) {
  	      $actif := $y
  	}
  	@fun_def lagTimeU($lagTimeU_p) {
  		// crea_track8 $track set 01_Perc_OnsetReplay relaxtime $relaxt
  		$Servers($server_name).n_set($onset_id, [lagTimeU, $lagTimeU_p])
  	}
  	@fun_def lagTimeD($lagTimeD_p) {
  		$Servers($server_name).n_set($onset_id, [lagTimeD, $lagTimeD_p])
  	}  
  	@fun_def thresh($thrs) {
      	// crea_track8 $track set 01_Perc_OnsetReplay thresh $thresh
  		$Servers($server_name).n_set($onset_id, [thresh, $thrs])

    }
    @fun_def floor($floor) {
      	// crea_track8 $track set 01_Perc_OnsetReplay floor $floor
      	$Servers($server_name).n_set($onset_id, ["floor", $floor])
    }    
  	@proc_def pause($pse) 
  	{
  		// crea_track8 $track pause $pause //temps fade_out
  		$pause := 0
  		print onset pause
  		$Servers($server_name).n_set($input_id, ["amp", -120, "matrix_ramp", $pse])
		0.01s $Servers($server_name).n_run($group_id, 0)

  	}
  	@fun_def resume($rsme) {
  		// crea_track8 $track resume $resume //temps fade_in
  		$pause := 1
  		print onset resume
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($input_id, ["amp", $amp, "matrix_ramp", $rsme])
  	}  	
  	@proc_def free() 
  	{
  		// crea_track8 $track off $fade_out
     	// print $track $THISOBJ off 
     	print free onsetdetect id $id
     	$Servers($server_name).n_free($group_id) 	
    }
   	@fun_def id()
   	{
   		return $id
   	}  
   	@fun_def inst($instr, $am = 0)
   	{
   		$Servers($server_name).n_set($input_id, [input, $inst, "amp", $am])
   	}
	@whenever (($descriptors_receives[0] == $server_name) && $actif && ($descriptors_receives[1][0] == "/fluid_loudness") && ($descriptors_receives[1][2] == $id))
	{
		// print onset $onsetdetect
		// if ($stop_detect){
			// group 
			// {
			// 	($del)ms iana_anal bang 
			// }
			// print fluid_loudness (""+$descriptors_receives)
			// $onset_id := $id
			// $nextevent := 1
			// $fluid_loudness := [$server_name, $id] // send to whenever
			$fluid_loudness := [$server_name, $id].concat($descriptors_receives[1].drop(3)) // send to whenever
			// print fluid_loudness (""+$fluid_loudness)
			// $actif := 0
			// let $descriptors_receives[1][2] := -1 // avoid whenever loop
			// ($antirebond) $actif := 1 //antirebond
			// print onsetdetect FINAL id $id inst $inst onset $onsetdetect
			
		// }
	}
}

$fluid_pitch := []

@obj_def fluid_pitch($server_name, $inst, $pitch_algo = "Fluid_Pitch", $lagTimeU = 0.001, $lagTimeD = 0.1, $algorithm = 2, $minFreq = 20, $maxFreq = 10000, $unit = 0, $windowSize = 1024, $hopSize = -1, $fftSize = -1, $trig_rate = 30, $id = 0, $amp = 0) // del in ms
{
	@local $bus, $group_id, $input_id, $onset_id, $actif := 1, $action, $onebang := 1, $pause := 1 //, $nom, $inc
	@init 
	{
		print onset id $id
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs	

		$input_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $input_id, 1, $group_id, input, $inst, out, $bus, amp, $amp])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $input_id + 1) // incremente pour le prochain	

		$onset_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new([$pitch_algo, $onset_id, 3, $input_id, "in", $bus, id, $id, "lagTimeU", $lagTimeU, "lagTimeD", $lagTimeD, "algorithm", $algorithm, "minFreq", $minFreq, "maxFreq", $maxFreq, "unit", $unit, "windowSize", $windowSize, "hopSize", $hopSize, "fftSize", $fftSize, "trig_rate", $trig_rate])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $onset_id + 1) // incremente pour le prochain	
	}

	@abort
	{
		$Servers($server_name).n_free($group_id)
		print onset intrument $inst off 
	}
	@fun_def actif($y) {
  	      $actif := $y
  	}
  	@fun_def lagTimeU($lagTimeU_p) {
  		// crea_track8 $track set 01_Perc_OnsetReplay relaxtime $relaxt
  		$Servers($server_name).n_set($onset_id, [lagTimeU, $lagTimeU_p])
  	}
  	@fun_def lagTimeD($lagTimeD_p) {
  		$Servers($server_name).n_set($onset_id, [lagTimeD, $lagTimeD_p])
  	}  
  	@fun_def thresh($thrs) {
      	// crea_track8 $track set 01_Perc_OnsetReplay thresh $thresh
  		$Servers($server_name).n_set($onset_id, [thresh, $thrs])

    }

    @fun_def floor($floor) {
      	// crea_track8 $track set 01_Perc_OnsetReplay floor $floor
      	$Servers($server_name).n_set($onset_id, ["floor", $floor])
    }    
  	@proc_def pause($pse) 
  	{
  		// crea_track8 $track pause $pause //temps fade_out
  		$pause := 0
  		print onset pause
  		$Servers($server_name).n_set($input_id, ["amp", -120, "matrix_ramp", $pse])
		0.01s $Servers($server_name).n_run($group_id, 0)

  	}
  	@fun_def resume($rsme) {
  		// crea_track8 $track resume $resume //temps fade_in
  		$pause := 1
  		print onset resume
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($input_id, ["amp", $amp, "matrix_ramp", $rsme])
  	}  	
  	@proc_def free() 
  	{
  		// crea_track8 $track off $fade_out
     	// print $track $THISOBJ off 
     	print free onsetdetect id $id
     	$Servers($server_name).n_free($group_id) 	
    }
   	@fun_def id()
   	{
   		return $id
   	}  
   	@fun_def inst($instr, $am = 0)
   	{
   		$Servers($server_name).n_set($input_id, [input, $inst, "amp", $am])
   	}
	@whenever (($descriptors_receives[0] == $server_name) && $actif && ($descriptors_receives[1][0] == "/fluid_pitch") && ($descriptors_receives[1][2] == $id))
	{
		// print onset $onsetdetect
		// if ($stop_detect){
			// group 
			// {
			// 	($del)ms iana_anal bang 
			// }
			// print: fluid_pitch "TAB[\"server5\", TAB[\"/fluid_pitch\", 147, 39, 770.487, 0.891751]]"

			// print fluid_pitch (""+$descriptors_receives)
			// $onset_id := $id
			// $nextevent := 1
			$fluid_pitch := [$server_name, $id].concat($descriptors_receives[1].drop(3)) // send to whenever
			// print fluid_pitch (""+$fluid_pitch)
			// $actif := 0
			// let $descriptors_receives[1][2] := -1 // avoid whenever loop
			// ($antirebond) $actif := 1 //antirebond
			// print onsetdetect FINAL id $id inst $inst onset $onsetdetect
			
		// }
	}
}
$fluid_spectralshape := []
@obj_def fluid_spectralshape($server_name, $inst, $shape_algo = "Fluid_SpectralShape", $lagTimeU = 0.001, $lagTimeD = 0.1, $minFreq = 0, $maxFreq = -1, $rolloffPercent = 95, $unit = 0, $power = 0, $windowSize = 1024, $hopSize = -1, $fftSize = -1, $maxFFTSize = -1, $trig_rate = 30, $id = 0, $amp = 0) // del in ms
{
	@local $bus, $group_id, $input_id, $onset_id, $actif := 1, $action, $onebang := 1, $pause := 1 //, $nom, $inc
	@init 
	{
		print onset id $id
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs	

		$input_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $input_id, 1, $group_id, input, $inst, out, $bus, amp, $amp])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $input_id + 1) // incremente pour le prochain	

		$onset_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new([$shape_algo, $onset_id, 3, $input_id, "in", $bus, id, $id, "lagTimeU", $lagTimeU, "lagTimeD", $lagTimeD, "minFreq", $minFreq, "maxFreq", $maxFreq, "rolloffPercent", $rolloffPercent, "unit", $unit, "power", $power, "windowSize", $windowSize, "hopSize", $hopSize, "fftSize", $fftSize, "maxFFTSize", $maxFFTSize, "trig_rate", $trig_rate])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $onset_id + 1) // incremente pour le prochain	
	}

	@abort
	{
		$Servers($server_name).n_free($group_id)
		print onset intrument $inst off 
	}
	@fun_def actif($y) {
  	      $actif := $y
  	}
  	@fun_def lagTimeU($lagTimeU_p) {
  		// crea_track8 $track set 01_Perc_OnsetReplay relaxtime $relaxt
  		$Servers($server_name).n_set($onset_id, [lagTimeU, $lagTimeU_p])
  	}
  	@fun_def lagTimeD($lagTimeD_p) {
  		$Servers($server_name).n_set($onset_id, [lagTimeD, $lagTimeD_p])
  	}  	
  	@fun_def thresh($thrs) {
      	// crea_track8 $track set 01_Perc_OnsetReplay thresh $thresh
  		$Servers($server_name).n_set($onset_id, [thresh, $thrs])

    }

    @fun_def floor($floor) {
      	// crea_track8 $track set 01_Perc_OnsetReplay floor $floor
      	$Servers($server_name).n_set($onset_id, ["floor", $floor])
    }    
  	@proc_def pause($pse) 
  	{
  		// crea_track8 $track pause $pause //temps fade_out
  		$pause := 0
  		print onset pause
  		$Servers($server_name).n_set($input_id, ["amp", -120, "matrix_ramp", $pse])
		0.01s $Servers($server_name).n_run($group_id, 0)

  	}
  	@fun_def resume($rsme) {
  		// crea_track8 $track resume $resume //temps fade_in
  		$pause := 1
  		print onset resume
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($input_id, ["amp", $amp, "matrix_ramp", $rsme])
  	}  	
  	@proc_def free() 
  	{
  		// crea_track8 $track off $fade_out
     	// print $track $THISOBJ off 
     	print free onsetdetect id $id
     	$Servers($server_name).n_free($group_id) 	
    }
   	@fun_def id()
   	{
   		return $id
   	}  
   	@fun_def inst($instr, $am = 0)
   	{
   		$Servers($server_name).n_set($input_id, [input, $inst, "amp", $am])
   	}
	@whenever (($descriptors_receives[0] == $server_name) && $actif && ($descriptors_receives[1][0] == "/fluid_spectralshape") && ($descriptors_receives[1][2] == $id))
	{
		// print onset $onsetdetect
		// if ($stop_detect){
			// group 
			// {
			// 	($del)ms iana_anal bang 
			// }
			// print fluid_spectralshape (""+$descriptors_receives)
			// $onset_id := $id
			// $nextevent := 1
			// $fluid_spectralshape := [$server_name, $id] // send to whenever
			$fluid_spectralshape := [$server_name, $id].concat($descriptors_receives[1].drop(3)) // send to whenever
			// print fluid_spectralshape (""+$fluid_spectralshape)			
			// $actif := 0
			// let $descriptors_receives[1][2] := -1 // avoid whenever loop
			// ($antirebond) $actif := 1 //antirebond
			// print onsetdetect FINAL id $id inst $inst onset $onsetdetect
			
		// }
	}
}

$fluid_chroma := []
@obj_def fluid_chroma($server_name, $inst, $shape_algo = "Fluid_Chroma", $lagTimeU = 0.001, $lagTimeD = 0.1, $trig_rate = 30, $id = 0, $amp = 0) // del in ms
{
	@local $bus, $group_id, $input_id, $onset_id, $actif := 1, $action, $onebang := 1, $pause := 1 //, $nom, $inc
	@init 
	{
		print onset id $id
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs	

		$input_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $input_id, 1, $group_id, input, $inst, out, $bus, amp, $amp])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $input_id + 1) // incremente pour le prochain	

		$onset_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new([$shape_algo, $onset_id, 3, $input_id, "in", $bus, id, $id, "lagTimeU", $lagTimeU, "lagTimeD", $lagTimeD, "trig_rate", $trig_rate])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $onset_id + 1) // incremente pour le prochain	
	}

	@abort
	{
		$Servers($server_name).n_free($group_id)
		print onset intrument $inst off 
	}
	@fun_def actif($y) {
  	      $actif := $y
  	}
  	@fun_def lagTimeU($lagTimeU_p) {
  		// crea_track8 $track set 01_Perc_OnsetReplay relaxtime $relaxt
  		$Servers($server_name).n_set($onset_id, [lagTimeU, $lagTimeU_p])
  	}
  	@fun_def lagTimeD($lagTimeD_p) {
  		$Servers($server_name).n_set($onset_id, [lagTimeD, $lagTimeD_p])
  	}  	
  	@fun_def thresh($thrs) {
      	// crea_track8 $track set 01_Perc_OnsetReplay thresh $thresh
  		$Servers($server_name).n_set($onset_id, [thresh, $thrs])

    }

    @fun_def floor($floor) {
      	// crea_track8 $track set 01_Perc_OnsetReplay floor $floor
      	$Servers($server_name).n_set($onset_id, ["floor", $floor])
    }    
  	@proc_def pause($pse) 
  	{
  		// crea_track8 $track pause $pause //temps fade_out
  		$pause := 0
  		print onset pause
  		$Servers($server_name).n_set($input_id, ["amp", -120, "matrix_ramp", $pse])
		0.01s $Servers($server_name).n_run($group_id, 0)

  	}
  	@fun_def resume($rsme) {
  		// crea_track8 $track resume $resume //temps fade_in
  		$pause := 1
  		print onset resume
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($input_id, ["amp", $amp, "matrix_ramp", $rsme])
  	}  	
  	@proc_def free() 
  	{
  		// crea_track8 $track off $fade_out
     	// print $track $THISOBJ off 
     	print free onsetdetect id $id
     	$Servers($server_name).n_free($group_id) 	
    }
   	@fun_def id()
   	{
   		return $id
   	}  
   	@fun_def inst($instr, $am = 0)
   	{
   		$Servers($server_name).n_set($input_id, [input, $inst, "amp", $am])
   	}
	@whenever (($descriptors_receives[0] == $server_name) && $actif && ($descriptors_receives[1][0] == "/fluid_chroma") && ($descriptors_receives[1][2] == $id))
	{
		// print onset $onsetdetect
		// if ($stop_detect){
			// group 
			// {
			// 	($del)ms iana_anal bang 
			// }
			// print fluid_chroma (""+$descriptors_receives)
			// $onset_id := $id
			// $nextevent := 1
			// $fluid_spectralshape := [$server_name, $id] // send to whenever
			$fluid_chroma := [$server_name, $id].concat($descriptors_receives[1].drop(3)) // send to whenever
			// print fluid_spectralshape (""+$fluid_spectralshape)			
			// $actif := 0
			// let $descriptors_receives[1][2] := -1 // avoid whenever loop
			// ($antirebond) $actif := 1 //antirebond
			// print onsetdetect FINAL id $id inst $inst onset $onsetdetect
			
		// }
	}
}


$fluid_melbands := []
@obj_def fluid_melbands($server_name, $inst, $shape_algo = "Fluid_MelBands", $lagTimeU = 0.001, $lagTimeD = 0.1, $trig_rate = 30, $id = 0, $amp = 0) // del in ms
{
	@local $bus, $group_id, $input_id, $onset_id, $actif := 1, $action, $onebang := 1, $pause := 1 //, $nom, $inc
	@init 
	{
		print onset id $id
		$bus := $SC_Servers($server_name)("bus_index") // current bus index for this server
		$SC_Servers($server_name).insert("bus_index", $bus+1) // inc bus de server  

	    $group_id := $SC_Servers($server_name)("node_id") // current node id for this server
		$Servers($server_name).g_new($group_id, 0, 1) // create group
		$SC_Servers($server_name).add_pair("node_id", $group_id + 1) // incremente le node_id dans le dico des serveurs	

		$input_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new(["AudioInput", $input_id, 1, $group_id, input, $inst, out, $bus, amp, $amp])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $input_id + 1) // incremente pour le prochain	

		$onset_id := $SC_Servers($server_name)("node_id")
   		$Servers($server_name).s_new([$shape_algo, $onset_id, 3, $input_id, "in", $bus, id, $id, "lagTimeU", $lagTimeU, "lagTimeD", $lagTimeD, "trig_rate", $trig_rate])  //target 2 justo despues del nodo 180 audioOut
		$SC_Servers($server_name).add_pair("node_id", $onset_id + 1) // incremente pour le prochain	
	}

	@abort
	{
		$Servers($server_name).n_free($group_id)
		print onset intrument $inst off 
	}
	@fun_def actif($y) {
  	      $actif := $y
  	}
  	@fun_def lagTimeU($lagTimeU_p) {
  		// crea_track8 $track set 01_Perc_OnsetReplay relaxtime $relaxt
  		$Servers($server_name).n_set($onset_id, [lagTimeU, $lagTimeU_p])
  	}
  	@fun_def lagTimeD($lagTimeD_p) {
  		$Servers($server_name).n_set($onset_id, [lagTimeD, $lagTimeD_p])
  	}  	
  	@fun_def thresh($thrs) {
      	// crea_track8 $track set 01_Perc_OnsetReplay thresh $thresh
  		$Servers($server_name).n_set($onset_id, [thresh, $thrs])

    }

    @fun_def floor($floor) {
      	// crea_track8 $track set 01_Perc_OnsetReplay floor $floor
      	$Servers($server_name).n_set($onset_id, ["floor", $floor])
    }    
  	@proc_def pause($pse) 
  	{
  		// crea_track8 $track pause $pause //temps fade_out
  		$pause := 0
  		print onset pause
  		$Servers($server_name).n_set($input_id, ["amp", -120, "matrix_ramp", $pse])
		0.01s $Servers($server_name).n_run($group_id, 0)

  	}
  	@fun_def resume($rsme) {
  		// crea_track8 $track resume $resume //temps fade_in
  		$pause := 1
  		print onset resume
		$Servers($server_name).n_run($group_id, 1)
		// scServer "n_set" $node_id_out amp 0
		$Servers($server_name).n_set($input_id, ["amp", $amp, "matrix_ramp", $rsme])
  	}  	
  	@proc_def free() 
  	{
  		// crea_track8 $track off $fade_out
     	// print $track $THISOBJ off 
     	print free onsetdetect id $id
     	$Servers($server_name).n_free($group_id) 	
    }
   	@fun_def id()
   	{
   		return $id
   	}  
   	@fun_def inst($instr, $am = 0)
   	{
   		$Servers($server_name).n_set($input_id, [input, $inst, "amp", $am])
   	}
	@whenever (($descriptors_receives[0] == $server_name) && $actif && ($descriptors_receives[1][0] == "/fluid_melbands") && ($descriptors_receives[1][2] == $id))
	{
		// print onset $onsetdetect
		// if ($stop_detect){
			// group 
			// {
			// 	($del)ms iana_anal bang 
			// }
			// print fluid_chroma (""+$descriptors_receives)
			// $onset_id := $id
			// $nextevent := 1
			// $fluid_spectralshape := [$server_name, $id] // send to whenever
			$fluid_melbands := [$server_name, $id].concat($descriptors_receives[1].drop(3)) // send to whenever
			// print fluid_spectralshape (""+$fluid_spectralshape)			
			// $actif := 0
			// let $descriptors_receives[1][2] := -1 // avoid whenever loop
			// ($antirebond) $actif := 1 //antirebond
			// print onsetdetect FINAL id $id inst $inst onset $onsetdetect
			
		// }
	}
}


////////////Treatements

// Del scrub

@obj_def del_scrub($track, $rec_buf_pvoc, $inst, $del_range, $density, $temp, $env = "rond") // del in ms
{
	@local $incr := 0, $incr2 := 0, $server_name, $whenever_actif := true, $track_bus, $dur_rec, $del, $dur_rec_onset := 0.1, $last_date := $NOW
	@init 
	{
		$server_name := $tracks($track).server_name()
		$track_bus := $tracks($track).$bus
		$dur_rec := $rec_buf_pvoc.dur()
		$del := @rand_range_compiled($del_range[0], $del_range[1])
		
		whenever ($onsetdetect[1] == $inst && $whenever_actif)
		{
			@local $timer := 0
			print start_rec
			if($incr == 0)
			{
				// $rec_buf_del_scrub.rec($bsn)
				$rec_buf_pvoc.rec($inst)
				$last_date := $NOW
			}
			else
			{
				if($incr == 1)
				{
					$whenever_actif := false
					// $rec_buf_pvoc.stop_record(0.1)
					$dur_rec_onset := $NOW - $last_date
					// print dur_0 $dur_rec_onset
					// $dur_rec_onset := $last_date
					$dur_rec_onset $whenever_actif := true
					$incr := 0
				}
			}
			$incr += 1
			$incr2 += 1
			if($incr2 == 1)
			{
				$THISOBJ.dels()
			}
		}
		
	}
	@fun_def env($ev) {
	$env := $ev
    }
	@proc_def dels()
	{
		loop $del 
		{
			@local $rate := @rand_range_compiled(0.1, 4), $local_dur // , group_id = $group_id

			if($incr < 1)
			{
				$dur_rec_onset := $rec_buf_pvoc.$rec_pos // position de rec
			}
			$local_dur := $dur_rec_onset * $rate.inv()
			// print rate $rate
			// print local_dur $local_dur
			// print dur $dur_rec_onset
			// print (""+[["TPlayPvocBuf", "buf", $rec_buf_pvoc.id(), "rate", $rate], ["OutEnv1_HOA7", env, $envs($server_name)($env), dur, $local_dur, coords, [@rand_range_compiled(0.5, 6), @rand_range_compiled(-180, 180), 0], amp, 0, globTBus, $track_bus]])
			$tracks($track).group_add([["TPlayPvocBuf", "buf", $rec_buf_pvoc.id(), "rate", $rate], ["OutEnv1_HOA7", env, $envs($server_name)($env), dur, $local_dur, coords, [@rand_range_compiled(0.5, 6), @rand_range_compiled(-180, 180), 0], amp, 0, globTBus, $track_bus]])
			// $tracks($track).set_group_id($group_id, "TPlayPvocBuf", "rate", 0.5)
			$del := @rand_range_compiled($del_range[0], $del_range[1])
		}
	}
}

$formants := map{("sopranoA", [[800, 1150, 2900, 3900, 4950], [0, -6, -32, -20, -50].dB2a_tab(), [80, 90, 120, 130, 140]]),
		("sopranoE", [[350, 2000, 2800, 3600, 4950], [0, -20, -15, -40, -56].dB2a_tab(), [60, 100, 120, 150, 200]]),
		("sopranoI", [[270, 2140, 2950, 3900, 4950], [0, -12, -26, -26, -44].dB2a_tab(), [60, 90, 100, 120, 120]]),
		("sopranoO", [[450, 800, 2830, 3800, 4950], [0, -11, -22, -22, -50].dB2a_tab(), [70, 80 ,100, 130, 135]]),
		("sopranoU", [[325, 700, 2700, 3800, 4950], [0, -16, -35, -40, -60].dB2a_tab(), [50, 60, 170, 180, 200]]),
		("altoA", [[800, 1150, 2800, 3500, 4950], [0, -4, -20, -36, -60].dB2a_tab(), [80, 90, 120, 130, 140]]),
		("altoE", [[400, 1600, 2700, 3300, 4950], [0, -24, -30, -35, -60].dB2a_tab(), [60, 80, 120, 150, 200]]),
		("altoI", [[350, 1700, 2700, 3700, 4950], [0, -20, -30, -36, -60].dB2a_tab(), [50, 100, 120, 150, 200]]),
		("altoO", [[450, 800, 2830, 3500, 4950], [0, -9, -16, -28, -55].dB2a_tab(), [70, 80, 100, 130, 135]]),
		("altoU", [[325, 700, 2530, 3500, 4950], [0, -12, -30, -40, -64].dB2a_tab(), [50, 60, 170, 180, 200]]),
		("counterTenorA", [[660, 1120, 2750, 3000, 3350], [0, -6, -23, -24, -38].dB2a_tab(), [80, 90, 120, 130, 140]]),
		("counterTenorE", [[440, 1800, 2700, 3000, 3300], [0, -14, -18, -20, -20].dB2a_tab(), [70, 80, 100, 120, 120]]),
		("counterTenorI", [[270, 1850, 2900, 3350, 3590], [0, -24, -24, -36, -36].dB2a_tab(), [40, 90, 100, 120, 120]]),
		("counterTenorO", [[430, 820, 2700, 3000, 3300], [0, -10, -26, -22, -34].dB2a_tab(), [40, 80, 100, 120, 120]]),
		("counterTenorU", [[370, 630, 2750, 3000, 3400], [0, -20, -23, -30, -34].dB2a_tab(), [40, 60, 100, 120, 120]]),
		("tenorA", [[650, 1080, 2650, 2900, 3250], [0, -6, -7, -8, -22].dB2a_tab(), [80, 90, 120, 130, 140]]),
		("tenorE", [[400, 1700, 2600, 3200, 3580], [0, -14, -12, -14, -20].dB2a_tab(), [70, 80, 100, 120, 120]]),
		("tenorI", [[290, 1870, 2800, 3250, 3540], [0, -15, -18, -20, -30].dB2a_tab(), [40, 90, 100, 120, 120]]),
		("tenorO", [[400, 800, 2600, 2800, 3000], [0, -10, -12, -12, -26].dB2a_tab(), [40, 80, 100, 120, 120]]),
		("tenorU", [[350, 600, 2700, 2900, 3300], [0, -20, -17, -14, -26].dB2a_tab(), [40, 60, 100, 120, 120]]),
		("bassA", [[600, 1040, 2250, 2450, 2750], [0, -7, -9, -9, -20].dB2a_tab(), [60, 70, 110, 120, 130]]),
		("bassE", [[400, 1620, 2400, 2800, 3100], [0, -12, -9, -12, -18].dB2a_tab(), [40, 80, 100, 120, 120]]),
		("bassI", [[250, 1750, 2600, 3050, 3340], [0, -30, -16, -22, -28].dB2a_tab(), [60, 90, 100, 120, 120]]),
		("bassO", [[400, 750, 2400, 2600, 2900], [0, -11, -21, -20, -40].dB2a_tab(), [40, 80, 100, 120, 120]]),
		("bassU", [[350, 600, 2400, 2675, 2950], [0, -20, -32, -28, -36].dB2a_tab(), [40, 80, 100, 120, 120]]) }

		// format freqs, amps and decay to BBandPass Ugen

		forall $key, $val in $formants
		{
			@local $temp := ([ $val[2][$x] / $val[0][$x] | $x in $val[0].size() ])
			$formants($key).remove(2)
			$formants($key).insert(2, $temp)
		}



// $sc_struct := map { 
// 	(0, [104, 100]), // group 0 == top group
// 	(104, [106, 107, 108, 105]),
// 	(100, [102, 103, 101]),
// 	(102, MAP{ ("synth", "mDust"), ("freq", 100), ("amp", 3)}),
// 	(103, MAP{ ("synth", "tAdCVerb")}),
// 	(101, MAP{ ("synth", "audioOut8")}),
// 	(105, MAP{ ("synth", "audioOut8")}), 
// 	(106, MAP{ ("synth", "windowtest3"), ("freq", 111)}), 
// 	(107, MAP{ ("synth", "windowtest3"), ("freq", 222)}), 
// 	(108, MAP{ ("synth", "windowtest3"), ("freq", 333)}) 
// }




// @push_back($sc_struct("top"),"group1") 
// @push_back($sc_struct("top"),"group2") 
// $sc_struct := map { 
// 	(0, [104, 100]), // group 0 == top group
// 	(104, [106, 107, 108, 105]),
// 	(100, [102, 103, 101]),
// 	(102, MAP{ ("synth", "mDust"), ("freq", 100), ("amp", 3) }),
// 	(103, MAP{ ("synth", "tAdCVerb"), ("amp", 3) }),
// 	(101, MAP{ ("synth", "audioOut8")}),
// 	(105, MAP{ ("synth", "audioOut8")}), 
// 	(106, MAP{ ("synth", "windowtest3")}), 
// 	(107, MAP{ ("synth", "windowtest3")}), 
// 	(108, MAP{ ("synth", "windowtest3")}) 
// }

// $sc_struct := map { 
// 	("top", ["group1", "group2"]),
// 	("group1", [101, 100]),
// 	("group2", [104, 105, 106, 103]),

// 	(101, MAP{ ("kind", "mDust"), ("freq", 100), ("amp", 3) }),
// 	(100, MAP{ ("kind", "audioOut8_100")}),
// 	(104, MAP{ ("kind", "audioOut8_104")}), 
// 	(103, MAP{ ("kind", "windowOut_103")}), 
// 	(105, MAP{ ("kind", "windowOut_105")}), 
// 	(106, MAP{ ("kind", "windowOut_106")}) 
// }


// print (""+$sc_struct)

// 1 print (""+@domain($sc_struct))
// print (""+@range($sc_struct))
// print (""+($sc_struct))
// // print (""+$track_proc("group_100")(104))
// print (""+$synths_map)	

// notifyserver2 1
// dumpOSCserver2 1